// Modular Combat FGD file
// Based on Raeven0's updated HL2/HL2DM FGD, 1.0.8b
//
//	v1.0.0
//	* Added faction specific spawn entities, removed hl2dm team spawn entities
//


// Raeven0's original update notes below:
//

//
// Half-Life 2/HL2DM FGD file
// Based on Valve's base.fgd, halflife2.fgd, and hl2mp.fgd
//
// ******************************
//
// Raeven0 (Raeven0@gmail.com), Jun 06, 1.0.8b
// 
// * Quickly added a readonly MoveSpeed() to ropes so that Hammer will render them
//
// ______________________________
//
// Raeven0 (Raeven0@editlife.net), Dec 05, 1.0.8
// With extra help from Groundflyer (jaxon_groundflyer@hotmail.com)
//
// * Removed the following nonfunctional entities:  env_rotorwash; info_teleporter_countdown; prop_vehicle_driveable; script_tauremoval; vgui_screen
// * Removed all triggers' Pushables flag (it only works for func_pushable, which is not in any FGD and is pointless anyway)
// * Added available soundscape names to env_soundscape
// * Added _minlight key to worldspawn
// * Added Trigger base to trigger_autosave and trigger_changelevel (thanks, swiss_cheese9797)
// * Added Parentname base to phys_thruster and phys_torque (thanks, AberantObscurity)
// * Added HDR and other light keys, new areaportal keys, and the rest of Valve's new engine changes (the ones I could find)
// * Added body(integer) and SetBodyGroup(integer) to Studiomodel base; removed these from all children of Studiomodel
// * Added Parentname and Studiomodel bases to monster_generic, generic_actor, and cycler_actor
// * Added func_physbox_multiplayer, spark_shower
// * Added the Targetname base to npc_heli_nobomb and npc_heli_avoidbox, and rearranged their bases in logical order
// * Added sequence(integer) to prop_ragdoll
// * Added three new flags to env_blood
// * Changed item_ammo_ar2 entities to use proper models
// * Changed all studio() to studioprop() so that model bounding boxes follow the rotated model
// * Implemented func_wall, func_illusionary, func_wall_toggle, info_teleport_destination, and trigger_once at the end of the FGD for people bent on using them
// * Improved entity documentations
// * Improved prop_door_rotating (thanks, Mr. Wisecarver)
//
// ______________________________
//
// Raeven0 (Raeven0@editlife.net), Jul 05, 1.0.7
//
// * Removed the following nonfunctional entities:  BaseSpeaker base; Inputfilter base; KeyFrame base; weapon_brickbat
// * Removed a redundant func_healthcharger entry and a redundant phys_constraintsystem entry
// * Removed func_wall_toggle; use func_brush instead
// * Removed unused "Type" property and "Angles" base from env_alyxemp
// * Removed "Credits" (option 1) from game_text's effects; 0 and 1 give the same effect, so I randomly chose to keep 0
// * Removed unused radius from env_soundscape_proxy
// * Removed unused duration from env_flare
// * Removed note from func_precipitation that HL2 lacks rain/snow materials
// * Commented out iffy npc_citizen citizentype "Unique" (4)
// * Added item_sodacan for cans that need I/O
// * Added note that env_beverage and item_sodacan need a models/can.mdl, and added a link to Groundflyer's custom can
// * Added RenderFields inheritance to Studiomodel base as well as several other entities that needed it--
//	I'm pretty sure this is going to work without problems, but obviously I can't test every single entity
// * Added a proper flag 4 to env_fade
// * Added properties and inputs to light_environment to allow it to be dynamic
// * Added ApplyScore(void) input to game_score
// * Added _exponent key back to light_spot since it's used by RAD
// * Added MoveLinear base for func_movelinear and func_water_analog
// * Allowed "Default" tracer, as well as other gunfire sounds, to be used in env_gunfire
// * Changed SetSpeed(void) to SetSpeed(integer) in func_conveyer
// * Corrected Negated(choices) default value in BaseFilter
// * Corrected spawnobject(choices) list in BreakableBrush base
// * Correct default model and sound for physics_cannister
// * Corrected redundancies in item_item_crate
// * Corrected mistake of removing orientationtype(choices) from path_track
// * Improved entity documentations in general
// * Improved BaseTank's (and tank entities') properties and documentation
// * Merged RenderFields and Shadow bases and moved _minlight key to new RenderFields base
// * Organized entity ordering within the FGD:  they're alphabetized, mostly, and groups of related entities (such as "Ladders") are all together
//
// ______________________________
//
// Raeven0 (Raeven0@editlife.net), May 05, 1.0.6b
//
// * Removed or commented out the following broken or redundant entities:
//	env_extinguisherjet, env_funnel, func_extinguishercharger, keyframe_track, move_keyframed
// * Removed broken flag from move_rope/keyframe_rope
// * Removed broken permission flags from info_node
// * Removed broken MaximumState(choices) property from ai_goal_follow, and put its Formation choices in order
// * Added new HL2DM entities:  npc_tripmine, npc_satchel
// * Added a new HL2 entity:  npc_grenade_frag
// * Added a new base Remap for the two remap entities
// * Added a read-only error(integer) key to func_breakable_surf
// * Added choices for vehicle script files
// * Added sphere(_distance) helper to lights
// * Added developer entity "player" (it was commented out prior to this)
// * Added Alpha(integer) input in RenderFields base
// * Made the following changes to env_beam:  removed broken framrate(integer) property; renamed framestart(integer)'s
//	SmartEdit name; removed obsolete Toggle flag; renamed and rewrote flags and properties to be more accurate;
//	changed "Amplitude" input to "Noise" as this is the correct name
// * Made the following changes to path_track:  commented out the "Fire Once" flag; made it
//	draw a line to its alternate path; commented out the orientationtype(choices) property
// * Changed func_areaportal's default state to Open as this is the more useful state
// * Changed the Mover base to include a proper name for PositionInterpolator value 2
// * Gave logic_collision_pair the Targetname base
// * Made env_explosion's flags easier to understand and added flag 8192
// * Re-implemented "World Space Glow" rendermode (thanks, Gobanzo_Mon)
// * Implemented most of Valve's changes (http://www.valve-erc.com/srcsdk/fgd_changes.html) from 9 Mar
//	and prior after checking their validity--thanks, Valve authors
//
// ______________________________
//
// Raeven0 (Raeven0@editlife.net), Feb 05, 1.0.6
//
// * Commented out more nonfunctional entities:
//	BaseBrush base, TriggerOnce base, move_track, weapon_extinguisher, trigger_once, info_lighting_relative
// * Removed broken properties from cycler and added working inputs, outputs, and properties
//	I am leaving the cycler entity in, at least this time.  It's the worst possible
//	way to place a model, but it could be useful for testing purposes with model animations,
//	because you can shoot it to advance the model a frame in its animation.
//	HL2 thinks a cycler is some sort of NPC.
// * Removed Angles base from keyframe_rope
// * Removed broken models from npc_citizen
// * Removed redundant Kill(void) input from item_ammo_crate
// * Added weapon_alyxgun, weapon_annabelle, weapon_stunstick, and weapon_slam to game_player_equip
// * Added weapon_slam
// * Added UseRandomTime(integer) input to logic_timer
// * Added the Color(color255) input to the RenderFields base
//	I'm going to *try* putting this input in that base.  I hope someone tells me if it doesn't work there.
// * Moved Shadow base above Studiomodel base and had the latter call on the former (to save space)
// * Added sphere(MaxRange) to env_microphone
// * Added Parentname base to ai_relationship
// * Added lowerleft, lowerright, upperleft, and upperright vectors to func_breakable_surf, to prevent Hammer calling foul on the entity
// * Added key no_decomp (a very simple decompile prevention method) to worldspawn
// * Modified env_screenoverlay's properties to allow for choosing materials from the texture browser
// * Corrected more errors in spelling, punctuation, grammar, and usage
// * Corrected my own mistake of not including an Ignite(void) input for prop_physics_respawnable
// * Changed "Inverse Mass Scale" back to "Mass Scale" (I would have sworn it was inverse)
// * Changed RenderFields base (tried to make it better reflect HL2 renderfields)
// * Changed worldspawn's default sky (the old default was buggy), its help text, and removed all bases
// * Changed lights a little; streamlined base calling, removed unneeded properties, such as that
// * Changed "Start constrained" to "Start asleep" in weapons, and changed all instances of "Start asleep" to "Start asleep (don't fall to ground)"
//
// ______________________________
//
// Raeven0 (Raeven0@editlife.net), Jan 05, version 1.0.5
//
// * Removed base FGD entirely (it's better to have one FGD per mod)
// * Removed or commented out the following nonfunctional or redundant entities:
//	func_ladder, func_wall, func_water, func_illusionary, game_score, game_player_team, game_player_hurt, info_teleport_destination, test_*
// * Removed all inputs and outputs from info_null and info_lighting (they didn't need them)
// * Removed obsolete flag from trigger_playermovement
// * Removed pitch/yaw/roll from env_splash
// * Removed redundant Pitch(integer) from env_sun
// * Removed the following unneeded BaseClasses:
//	prop_detail_base, vgui_screen_base, WorldBase
// * Removed redundant Kill(void) input from func_vehicleclip
// * Removed nonfunctional EnablePhyscannonPickup and DisablePhyscannonPickup from func_physbox
// * Commented out all master(string) properties from all entities.  If anyone can find an entity that can actually function as a master, I'd be glad to uncomment them.
//
// * Added an entity called "player."  Any inputs sent to "player" will actually be passed to all the clients; however, having a player entity in the map crashes HL2.
//	I've contacted amckern, who works with CST (Source's map compiler), to see if he can have the player entity removed automatically, to avoid HL2 crashing; until then,
//	the entity will either be commented out or marked "Developer Only."
// * Added info_lighting_relative with the Parentname base
// * Merged HL2 and HL2DM FGDs into one file, because HL2DM adds only two entities
// * Merged Weapon and Item bases; had them call on the Parentname base; added Ignite(void) input to WeaponItemBase
// * Moved all HL2DM-specific entities to the bottom of the FGD
// * Added note to func_precipitation that HL2 does not have snow or rain materials
// * Added note to point_message that the entity will not work in HL2DM
// * Added Toggle(void) input to func_brush
// * Added Targetname and Angles BaseClasses to PlayerClass BaseClass, allowing spawn points to have inputs and such
// * Added physdamagescale(float) property and physdamagescale(float) input to func_physbox
// * Added fademindist(float) and fademaxdist(float) inputs to BasePropPhysics base
// * Added Mover base to move_rope, replacing its own Position Interpolator property
// * Added option 2 to PositionInterpolator(choices) property in Mover base, and improved the help of that property
// * Created new base BaseDecal to save space in decal entities
// * Corrected problem with env_tonemap_controller SetTonemapScale input
// * Corrected a few errors in spelling, punctuation, grammar, and usage
// * Corrected filter_activator_team team-numbering
// * Changed scale(string) and framerate(string) to scale(float) and framerate(float) in env_sprite; also, added a default value of 1 to env_sprite's scale(float)
// * Universally changed "Mass Scale" and its help to read "Inverse Mass Scale" to be more descriptive
// * Gave info_ladder_dismount the Targetname BaseClass
// * Gave env_steam the Targetname BaseClass
// * Gave func_useableladder the Origin BaseClass
// * Gave env_sun the Targetname BaseClass
// * Plugged a few radii properties into a sphere() helper
// * Modified game_player_equip to include a list of everything it can give, gave it a proper Use input, and corrected a problem where choosing No would give the weapon anyway
// * Changed m_SoundName(string) to m_SoundName(sound) in point_tesla
//
// * Fixed redundant BaseClass calling in the Trigger, prop_dynamic_base, and BaseNPCMaker bases as well as the following entities:
//	env_gunfire; env_smokestack; func_monitor; func_physbox; item_item_crate; logic_timer; trigger_hurt; trigger_remove; trigger_vphysics_motion
// * Improved the entity help of:
//	prop_detail, item_item_crate, env_fog_controller, ambient_generic, sky_camera
// * Corrected BaseClass ordering in:
//	info_projecteddecal; func_physbox; env_headcrabcanister; script_tauremoval; env_citadel_energy_core; env_alyxemp; prop_ragdoll; info_node_air_hint; material_modify_control; func_vehicleclip; prop_physics; point_camera; prop_dynamic
//	  The BaseClasses will ideally be arranged such that the Name property is always at the top,
//	  followed by any classes special to the entity.  I am open to suggestions as to the best way
//	  to arrange the BaseClasses following Targetname (such as Origin, Parentname, and Angles).
// * In order to keep the Name universally at the top, I had to create another BaseClass solely for the targetname(target_source) property.  It's called NameBase and can safely be listed as the first base in all circumstances.
// * Tried to apply some sort of good organization to my comments; failed miserably
//

//-------------------------------------------------------------------------
//
// General Game Data
//
//-------------------------------------------------------------------------

@mapsize(-16384, 16384)

//-------------------------------------------------------------------------
//
// Base Classes
//
//-------------------------------------------------------------------------
@BaseClass = NameBase
[
	targetname(target_source) : "Name" : : "The name that other entities refer to this entity by."
]

@BaseClass base(NameBase) = Targetname 
[ 
	// Inputs
	input Kill(void) : "Removes this entity from the world."
	input KillHierarchy(void) : "Removes this entity and all its children from the world."
	input AddOutput(string) : "Adds an entity I/O connection to this entity. Format: <output name> <targetname>:<inputname>:<parameter>:<delay>:<max times to fire (-1 == infinite)>. Very dangerous, use with care."
	input FireUser1(void) : "Causes this entity's OnUser1 output to be fired."
	input FireUser2(void) : "Causes this entity's OnUser2 output to be fired."
	input FireUser3(void) : "Causes this entity's OnUser3 output to be fired."
	input FireUser4(void) : "Causes this entity's OnUser4 output to be fired."

	// Outputs	
	output OnUser1(void) : "Fired in response to FireUser1 input."
	output OnUser2(void) : "Fired in response to FireUser2 input."
	output OnUser3(void) : "Fired in response to FireUser3 input."
	output OnUser4(void) : "Fired in response to FireUser4 input."
]

@BaseClass = Parentname
[ 
	parentname(target_destination) : "Parent" : : "The name of this entity's parent in the movement hierarchy. Entities with parents move with their parent."

	// Inputs
	input SetParent(string) : "Changes the entity's parent in the movement hierarchy."
	input SetParentAttachment(string) : "Change this entity to attach to a specific attachment point on its parent. Entities must be parented before being sent this input. The parameter passed in should be the name of the attachment."
	input ClearParent(void) : "Removes this entity from the the movement hierarchy, leaving it free to move independently."

]

@BaseClass = Angles
[ 
	angles(angle) : "Pitch Yaw Roll (Y Z X)" : "0 0 0" : "This entity's orientation in the world. Pitch is rotation around the Y axis, " +
		"yaw is the rotation around the Z axis, roll is the rotation around the X axis."
]

@BaseClass = Origin
[ 
	origin(origin) : "Origin (X Y Z)" : : "The position of this entity's center in the world. Rotating entities typically rotate around their origin."
]

// This base is only kept because beams and lasers need it.
// Otherwise, it should be merged with RenderFields.
@BaseClass = RenderFxChoices
[
	renderfx(choices) :"Render FX" : 0 : "Preset pattern of changes to FX Amount for this entity.  May not work with all models." =
	[
		0: "Normal"
		1: "Slow Pulse"
		2: "Fast Pulse"
		3: "Slow Wide Pulse"
		4: "Fast Wide Pulse"
		9: "Slow Strobe"
		10: "Fast Strobe"
		11: "Faster Strobe"
		12: "Slow Flicker"
		13: "Fast Flicker"
		5: "Slow Fade Away"
		6: "Fast Fade Away"
		7: "Slow Become Solid"
		8: "Fast Become Solid"
		14: "Constant Glow"
		15: "Distort"
		16: "Hologram (Distort + fade)"
		23: "Cull By Distance (TEST)"
		24: "Spotlight FX"
		26: "Fade Near"
	]
]

// Used in HL1 to control transparency of a texture.  Conceivably still useful
// in HL2.  This base also controls shadows and _minlight.
@BaseClass base(RenderFxChoices) = RenderFields 
[
	rendermode(choices) : "Render mode override" : 0 : "Used to set a non-standard rendering mode on this entity.  All render overrides implement FX Amount and FX Color.  'World Space Glow' is the same as 'Additive,' but if the sprite's origin is obscured, the entire sprite will be invisible." =
	[
		0: "Normal - no override"
		//1: "Color"  ***same as 2, commented out***
		2: "Texture - use FX Amount and FX Color"
		3: "Glow - sprites get bigger w/distance"
		4: "Solid - brushes absorb bullets?"
		5: "Additive - erase sprite background"
		//7: "Additive Fractional Frame"  ***same as 5, commented out***
		9: "World Space Glow - see below"
		10: "Don't Render"
	]
	renderamt(integer) : "FX amount (0 - 255)" : 255 : "The FX Amount controls transparency in rendermodes that support it.  255 is fully opaque; 0 is fully transparent."
	rendercolor(color255) : "FX color (R G B)" : "255 255 255" : "The FX Color controls an overlay color for the entity.  See also the Color input.  Use white (255 255 255) for no modification to color."

	disableshadows(choices) : "Disable shadows" : 0 : "Prevent this entity from casting dynamic shadows, if it is capable." =
	[
		0 : "No"
		1 : "Yes"
	]
	disablereceiveshadows(choices) : "Disable receiving shadows" : 0 : "Prevents dynamic shadows (e.g. player and prop shadows) from appearing on this entity." =
	[
		0 : "No"
		1 : "Yes"
	]

	_minlight(string) : "Minimum light level" : "0.0" : "Minimum amount of light with which to light this entity.  0 means pitch black; 2 means fullbright."

	input Color(color255) : "Set the entity's FX Color."
	input Alpha(integer) : "Set the entity's FX Amount."
	input DisableShadow(void) : "Turn shadow off."
	input EnableShadow(void) : "Turn shadow on."
]

@BaseClass base(RenderFields) = Studiomodel
[
	model(studio) : "World Model" : : "The model to use for this entity.  Must be a valid .MDL somewhere in the mod directory; to specify a model, write 'models/somefolder/mymodel.mdl'.  Don't use backslashes, and don't write any directories above 'models'."
	skin(integer) : "Skin" : 0 : "Some models have multiple versions of their textures, called skins. Set this to a number other than 0 to use that skin instead of the default."
	body(integer) : "Body Group" : 0 : "Some models have multiple sub-models, called body groups. Set this to a number other than 0 to use that body group instead of the default. Different body groups can be discerned by using Model Viewer."

	// Inputs
	input Ignite(void) : "Set the object afire."
	input Skin(integer) : "Change the model skin to the specified number."
	input SetBodyGroup(integer) : "Change the model's bodygroup to the specified number."

	// Outputs
	output OnIgnite(void) : "Fired when this object catches fire."
]

@BaseClass = BasePlat
[
 	input Toggle(void) : "Toggles the platform's state."
	input GoUp(void)	: "Tells the platform to go up."
	input GoDown(void) : "Tells the platform to go down."
]

@BaseClass = EnableDisable
[
	StartDisabled(choices) : "Start Disabled" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]

	// Inputs
	input Enable(void) : "Enable this entity."
	input Disable(void) : "Disable this entity."
]

// Inherit from this to get the ability to only include an object in a range of dx levels.
// NOTE!!: MAKE SURE THAT YOU DON'T USE THIS WITH ANYTHING THAT WILL BREAK SAVE-GAMES SWITCHING
// BETWEEN DXLEVELS!!!!
@BaseClass = DXLevelChoice
[ 
	mindxlevel(choices) : "Minimum DX Level" : 0 : "Remove this object from the map if VBSP is run using a lower dxlevel than..." = 
	[
		0 : "DX6 (default)"
		70 : "DX7"
		80 : "DX8"
	]
	maxdxlevel(choices) : "Maximum DX Level" : 0 : "Remove this object from the map if VBSP is run using a higher dxlevel than..." = 
	[
		70 : "DX7"
		80 : "DX8"
		0 : "DX9 (default)"
	]
]

@BaseClass = Global 
[ 
	globalname(string) : "Global Entity Name" : "" : "Name by which this entity is linked to another entity in a different map. When the player transitions to a new map, entities in the new map with globalnames matching entities in the previous map will have the previous map's state copied over their state."
]

@BaseClass = DamageFilter
[ 
	damagefilter(target_destination) : "Damage Filter" : "" : "Name of the filter entity that controls which entities can damage us."
	input SetDamageFilter(string) : "Sets the entity to use as damage filter. Pass in an empty string to clear the damage filter."
]

@BaseClass = ResponseContext
[
	input AddContext(string) : "Adds a context to this entity's list of response contexts. The format should be 'key:value'."
	input RemoveContext(string) : "Remove a context from this entity's list of response contexts. The name should match the 'key' of a previously added context."
	input ClearContext(void) : "Removes all contexts in this entity's list of response contexts."

	// Pre-defined contexts at server startup time (set by mapper)
	ResponseContext(string) : "Response Contexts" : "" : "Response system context(s) for this entity. Format should be: 'key:value,key2:value2,etc'. When this entity speaks, the list of keys & values will be passed to the response rules system."
]

@BaseClass base(Targetname, DamageFilter, RenderFields) = Breakable
[
	ExplodeDamage(float) : "Explosion Damage" : 0 : "If non-zero, when this entity breaks it will create an explosion that causes the specified amount of damage. See also 'Explosion Radius'."
	ExplodeRadius(float) : "Explosion Radius" : 0 : "If non-zero, when this entity breaks it will create an explosion with a radius of the specified amount. See also 'Explosion Damage'."
	PerformanceMode(choices) : "Performance Mode" : 0 : "Used to limit the amount of gibs produced when this entity breaks, for performance reasons." =
	[
		0	: "Normal"
		1	: "Limit Gibs"
		2   : "Full Gibs on All Platforms"
	]

	// Inputs
	input Break(void) : "Break the breakable."
	input SetHealth(integer) : "Set a new value for the breakable's health. If the breakable's health reaches zero it will break."
	input AddHealth(integer) : "Add health to the breakable. If the breakable's health reaches zero it will break."
	input RemoveHealth(integer) : "Remove health from the breakable. If the breakable's health reaches zero it will break."

	// Outputs	
	output OnBreak(void) : "Fired when this breakable breaks."
	output OnHealthChanged(float) : "Fired when the health of this breakable changes, passing the new value of health as a decimal percentage of max health."
	output OnPhysCannonDetach(void) : "Fired when the physcannon has ripped this breakable off of the wall. Only fired if ACT_PHYSCANNON_DETACH is defined in the model this breakable is using."
]

@BaseClass base(Breakable, Parentname, Global) = BreakableBrush
[
	spawnflags(flags) =
	[
		1 : "Only Break on Trigger" : 0
		2 : "Break on Touch" : 0
		4 : "Break on Pressure" : 0
		512: "Break immediately on Physics" : 0
		1024: "Don't take physics damage" : 0
	]

	propdata(choices) : "Prop Data" : 0 : "Set to the best approximation of the size and material of this entity's brushes. If set, it will override this entity's health and damage taken from various weapons. See the prodata.txt file in the scripts directory of your mod to get a detailed list of what each propdata entry specifies." =
	[
		0	: "None"
		1	: "Wooden.Tiny"
		2	: "Wooden.Small"
		3	: "Wooden.Medium"
		4	: "Wooden.Large"
		5	: "Wooden.Huge"
		6	: "Metal.Small"
		7	: "Metal.Medium"
		8	: "Metal.Large"
		9	: "Cardboard.Small"
		10	: "Cardboard.Medium"
		11	: "Cardboard.Large"
		12	: "Stone.Small"
		13	: "Stone.Medium"
		14	: "Stone.Large"
		15	: "Stone.Huge"
		16	: "Glass.Small"
		17	: "Plastic.Small"
		18	: "Plastic.Medium"
		19	: "Plastic.Large"
		20	: "Pottery.Small"
		21	: "Pottery.Medium"
		22	: "Pottery.Large"
		23	: "Pottery.Huge"
		24	: "Glass.Window"
	]

	health(integer) : "Strength" : 1 : "Number of points of damage to take before breaking. 0 means don't break."
	material(choices) :"Material Type" : 0 : "Set to the material type of the brush. Used to decide what sounds to make when damaged, and what gibs to produce when broken." =
	[
		0: "Glass"
		1: "Wood"
		2: "Metal"		
		3: "Flesh"
		4: "CinderBlock"
		5: "Ceiling Tile"
		6: "Computer"
		7: "Unbreakable Glass"
		8: "Rocks"
	]
	explosion(choices) : "Gibs Direction" : 0 : "Used to decide which direction to throw gibs when broken." =
	[
		0: "Random"
		1: "Relative to Attack"
		2: "Use Precise Gib Dir"
	]

	gibdir(angle) : "Precise Gib Direction" : "0 0 0" : "Specifies the direction to throw gibs when this breakable breaks. Be sure to select Use Precise Gib Dir in the Gibs Direction field!"

	nodamageforces(choices) : "Damaging it Doesn't Push It" : 0 : "Used to determine whether or not damage should cause the brush to move." =
	[
		0: "No"
		1: "Yes"
	]

	// Inputs
	input EnableDamageForces(void) : "Damaging the entity applies physics forces to it."
	input DisableDamageForces(void) : "Damaging the entity does *not* apply physics forces to it."

	gibmodel(string) : "Gib Model" : "" : "Used by HL1Port to specify a custom gib model to break into, overriding the 'Material Type'."
	spawnobject(choices) : "Spawn On Break" : 0 : "When broken, an entity of the selected type will be created." =
	[
		1:	"item_battery"
		2:	"item_healthkit"
		3:	"item_ammo_pistol"
		4:	"item_ammo_pistol_large"
		5:	"item_ammo_smg1"
		6:	"item_ammo_smg1_large"
		7:	"item_ammo_ar2"
		8:	"item_ammo_ar2_large"
		9:	"item_box_buckshot"
		13:	"item_smg1_grenade"
		16:	"weapon_stunstick"
		18:	"weapon_ar2"
		21:	"weapon_smg1"
		23:	"weapon_slam"
		24:	"weapon_shotgun"
	]
	explodemagnitude(integer) : "Explode Magnitude" : 0 : "If non-zero, when this entity breaks it will create an explosion that causes the specified amount of damage."
	pressuredelay(float) : "Pressure Delay" : 0 : "Delay, in seconds, after 'broken' by pressure before breaking apart (allows for sound to play before breaking apart)."
]

// This is used in prop_static_base, else we would merge it with BreakableProp.
@BaseClass = Fade
[
	fademindist(float) : "Start Fade Distance" : -1 : "If the player is less than this distance from the prop, it will be rendered at normal opacity.  (Values less than zero mean use the end fade distance.)"
	fademaxdist(float) : "End Fade Distance" : 0 : "If the player is greater than this distance from the prop, it will not be rendered.  (Zero means don't fade and always show at normal opacity.)"
	fadescale(float) : "Fade Scale" : 1 : "If worldspawn specifies fade distances, or the engine is running below DX7, props are forcibly faded out (provided the Start and End Fade Dist are _not_ set above).  "+
		"This value is an inverse scalar for manipulating the forced fade distances.  (<1 make greater distances, and >1 make shorter distances.)"

	input fademindist(float) : "Changes the Start Fade Distance of the prop."
	input fademaxdist(float) : "Changes the End Fade Distance of the prop."
]

@BaseClass base(Breakable, Fade) = BreakableProp
[
	spawnflags(flags) =
	[
		16 : "Take Damage On Touch" : 0
		32 : "Take Damage On Pressure" : 0
	]
	pressuredelay(float) : "Pressure Delay" : 0 : "Delay, in seconds, after 'broken' by pressure before breaking apart (allows for sound to play before breaking apart)."

	input EnablePhyscannonPickup(void) : "Makes the breakable able to picked up by the physcannon."
	input DisablePhyscannonPickup(void) : "Makes the breakable not able to picked up by the physcannon."
]

@BaseClass base(Targetname, Angles, RenderFields, DamageFilter, ResponseContext) color(0 200 200) = BaseNPC
[
	target(target_destination) : "Target Path Corner" : : "If set, the name of a path corner entity that this NPC will walk to, after spawning."
	squadname(String) : "Squad Name" : : "NPCs that are in the same squad (i.e. have matching squad names) will share information about enemies, and will take turns attacking and covering each other."
	hintgroup(String) : "Hint Group" : "" : "Hint groups are used by NPCs to restrict their hint-node searching to a subset of the map's hint nodes. Only hint nodes with matching hint group names will be considered by this NPC."
	hintlimiting(choices) : "Hint Limit Nav" : 0 : "Limits NPC to using specified hint group for navigation requests, but does not limit local navigation." =
	[
		0 : "No"
		1 : "Yes"
	]

	spawnflags(Flags) = 
	[
		1 : "Wait Till Seen" : 0
		2 : "Gag (No IDLE sounds until angry)" : 0
		4 : "Fall to ground (unchecked means *teleport* to ground)" : 1
		8 : "Drop Healthkit" : 0
		16 : "Efficient - Don't acquire enemies or avoid obstacles" : 0
		128: "Wait For Script" : 0
		256: "Long Visibility/Shoot" : 0
		512: "Fade Corpse" : 0
		1024: "Think outside PVS" : 0
		2048: "Template NPC (used by npc_maker, will not spawn)" : 0
		4096: "Do Alternate collision for this NPC (player avoidance)" : 0
		8192: "Don't drop weapons" : 0
	]

	//initialidle(string) : "Initial Idle Activity" :: "Activity the NPC should use to idle until becomes alert"
	sleepstate(choices) : "Sleep State" : 0 : "Holds the NPC in stasis until specified condition. See also 'Wake Radius' and 'Wake Squad'." =
	[
		0 : "None"
		1 : "Waiting for threat"
		2 : "Waiting for PVS"
		3 : "Waiting for input"
	]

	wakeradius(float) : "Wake Radius" : 0 : "Auto-wake if player within this distance"
	wakesquad(choices) : "Wake Squad" : 0 : "Wake all of the NPCs squadmates if the NPC is woken" =
	[
		0 : "No"
		1 : "Yes"
	]

	physdamagescale(float) : "Physics Impact Damage Scale" : "1.0" : "Scales damage energy when this character is hit by a physics object. With a value of 0 the NPC will take no damage from physics."

	// Outputs
	output OnDamaged(void) : "Fired when this NPC takes damage."
	output OnDeath(void) : "Fired when this NPC is killed." 
	output OnHalfHealth(void) : "Fired when this NPC reaches half of its maximum health."
	output OnHearWorld(void) : "Fired when this NPC hears a sound (other than combat or the player)."
	output OnHearPlayer(void) : "Fired when this NPC hears the player."
	output OnHearCombat(void) : "Fired when this NPC hears combat sounds."
	output OnFoundEnemy(string) : "Fired when this NPC establishes line of sight to its enemy (outputs entity)."
	output OnLostEnemyLOS(void) : "Fired when this NPC loses line of sight to its enemy."
	output OnLostEnemy(void) : "Fired when this NPC loses its enemy. Usually due to the enemy being killed/removed, or because this NPC has selected a newer, more dangerous enemy."
	output OnFoundPlayer(string) : "Fired when this NPC establishes line of sight to its enemy, and that enemy is a player (outputs player entity)."
	output OnLostPlayerLOS(void) : "Fired when this NPC loses line of sight to its enemy, and that enemy is a player."
	output OnLostPlayer(void) : "Fired when this NPC loses its enemy, and that enemy was a player. Usually due to the enemy being killed/removed, or because this NPC has selected a newer, more dangerous enemy."
	output OnDamagedByPlayer(void) : "Fired when this NPC is hurt by a player."
	output OnDamagedByPlayerSquad(void) : "Fired when this NPC is hurt by a player OR by one of the player's squadmates."
	output OnDenyCommanderUse(void) : "Fired when this NPC has refused to join the player's squad."
	output OnWake(void) : "Fired when this NPC comes out of a sleep state."

	// Inputs
	input SetRelationship(string) : "Changes this entity's relationship with another entity or class. Format: <entityname/classname> <D_HT/D_FR/D_LI/D_NU> <priority>"
	input SetHealth(integer) : "Set this NPC's health."
	input SetBodyGroup(integer) : "Changes the NPC's model bodygroup to the specified number."
	input physdamagescale(float) : "Sets the value that scales damage energy when this character is hit by a physics object. NOTE: 0 means this feature is disabled for backwards compatibility."
	input Ignite(void) : "Ignite, burst into flames"
	input Break(void) : "Break, smash into pieces"
	input StartScripting(void) : "Enter scripting state. In this state, NPCs ignore a variety of stimulus that would make them break out of their scripts: They ignore danger sounds, ignore +USE, don't idle speak or respond to other NPC's idle speech, and so on."
	input StopScripting(void) : "Exit scripting state."
	input Assault(string) : "Start an assault. Parameter passed in should be the name of the rally point."
	input SetSquad(string) : "Set the name of this NPC's squad. It will be removed from any existing squad automatically. Leaving the parameter blank will remove the NPC from any existing squad."
	input Wake(void) : "Wakes up the NPC if it is sleeping."
	input ForgetEntity(string) : "Clears out the NPC's knowledge of a named entity."
	input GagEnable(void) : "Turn on the NPC Gag flag."
	input GagDisable(void) : "Turn off the NPC Gag flag."
	input IgnoreDangerSounds(float) : "Ignore danger sounds for the specified number of seconds."
]

@PointClass base(Targetname, Parentname, Angles) iconsprite("editor/info_target.vmt") = info_npc_spawn_destination : "NPC Spawn Destination. (Consult npc_template_maker help for more info)"
[
	ReuseDelay(float) : "Reuse Delay" : 1 : "After an NPC is spawned at this destination, the delay before this destination is eligible for selection again."
	RenameNPC(string) : "New NPC Name" : "" : "If an NPC spawns at this destination, change that NPC's targetname to this."

	// Outputs
	output OnSpawnNPC(void) : "Fired when an NPC spawns at this destination."
]

@BaseClass base(Targetname, Angles, EnableDisable) iconsprite("editor/npc_maker.vmt") color(0 0 255) = BaseNPCMaker
[
	StartDisabled(choices) : "Start Disabled" : 1 =
	[
		0 : "No"
		1 : "Yes"
	]

	spawnflags(Flags) = 
	[
		// Only in npc_maker, npc_template_maker uses flag from template NPC
		16	: "Fade Corpse"		 : 0
		32	: "Infinite Children" : 0
		64	: "Do Not Drop" : 0
		128	: "Don't Spawn While Visible" : 0
	]

	MaxNPCCount(integer) : "Num. of NPCs" : 1 : "Number of NPCs that will spawn before this spawner is exhausted."
	SpawnFrequency(string) : "Frequency" : "5" : "How often (in seconds) a new NPC will be spawned. If set to -1, a new NPC will be made when the last NPC dies."
	MaxLiveChildren(integer) : "Max Live NPCs" : 5 : "Maximum number of live children allowed at any one time (New ones will not be made until one dies). If set to -1, no limit is applied."
	
	// Outputs
	output OnSpawnNPC(string) : "Fired when an NPC is spawned. The activator is the NPC, and the string is the name of the NPC." 
	output OnAllSpawned(void) : "Fired when the spawned is exhausted (all children have been spawned)."
	output OnAllSpawnedDead(void) : "Fired when the spawner is exhausted (all children have been spawned) and all spawned children have died."

	// Inputs
	input Spawn(void) : "Spawns an NPC."
	input Toggle(void) : "Toggles the spawner enabled/disabled state."
	input AddMaxChildren(integer) : "Adds to the number of NPCs that can spawn before the spawner is exhausted. If an exhausted spawner is given some children to spawn, it still wont begin spawning until it is re-enabled with the Enable input."
	input SetMaxChildren(integer) : "Sets the number of NPCs that can spawn before the spawner is exhausted. If an exhausted spawner is given some children to spawn, it still wont begin spawning until it is re-enabled with the Enable input."
	input SetMaxLiveChildren(integer) : "Sets the maximum number of NPCs that can be alive at any one time from this spawner."
	input SetSpawnFrequency(float) : "Sets how often (in seconds) a new NPC will be spawned."
]

@PointClass base(BaseNPCMaker) iconsprite("editor/npc_maker.vmt") = npc_template_maker : "An entity that creates NPCs. The NPCs it creates are clones of a template NPC. NPCs are spawned around this maker's origin, or at specified destination points."
[
	spawnflags(Flags) = 
	[
		256	: "Always use radius spawn" : 0
		512 : "Don't preload template models" : 0
	]

	TemplateName(target_destination) : "Name of template NPC" : "" : "Template NPC that this maker should be creating clones of."

	Radius(float) : "Radius" : 256 : "Radius around this maker within which NPCs are to be placed. Spawned NPCs will try and find empty space within this radius to spawn."

	DestinationGroup(target_destination) : "Name of Destination Group" : : "If you'd like spawned NPCs to be created at an info_npc_spawn_destination entity, enter the name of that entity here. If you have more than one destination entity by that name, the Destination Criteria will be used to select one from the group."
	CriterionVisibility(Choices) : "Dest. Criterion: Visible to player?" : 2 : "Should the NPC try to spawn at a destination that the player can see? Only applicable if a Destination Group is being used." =
	[
		0 : "Yes"
		1 : "No"
		2 : "Don't Care"
	]
	CriterionDistance(Choices) : "Dest. Criterion: Distance to player?" : 2 : "Should the NPC try to spawn nearest to or farthest from the player's current location? Only applicable if a Destination Group is being used." =
	[
		0 : "Nearest"
		1 : "Farthest"
		2 : "Don't Care"
	]

	//Inputs
	input SpawnNPCInRadius(void)	: "Spawn an NPC somewhere within the maker's radius."
	input SpawnNPCInLine(void)	: "Spawn an NPC somewhere within a line behind the maker."
	input ChangeDestinationGroup(string) : "Switch to a different set of Destination entities."
]


@BaseClass base( BaseNPC ) = BaseHelicopter
[
	InitialSpeed(string) : "Initial Speed" : "0" : "Sets the helicopter's desired speed that it should try to reach as soon as it's spawned."
	target(target_destination) : "Target path_track" : : "If set, the name of a path_track entity that this NPC will fly to after spawning."

	// Inputs
	input MoveTopSpeed(void) : "The helicopter will immediately move at top speed toward its current goal, or in its current orientation if it's on top of its goal."
	input ChangePathCorner(target_destination)	: "Tell the helicopter to move to a path corner on a new path."
	input SelfDestruct(void)		: "Self Destruct."
	input Activate(void)			: "Activate. Use to wake up a helicopter that spawned with the 'Await Input' spawnflag on."
	input SetTrack(target_destination) : "Set a track for the helicopter to adhere to. The helicopter will do nothing if he's on the same path, and will move to the closest point on the specified track if he's on a different path."
	input FlyToSpecificTrackViaPath(target_destination) : "The helicopter will first fly to the closest point on the path if he's on a different path. Then he'll fly along the path to the specified track point."
	input StartPatrol(void) : "Start patrolling back and forth along the current track."
	input StopPatrol(void) : "Stop patrolling back and forth along the track. This will cause the helicopter to come to rest at the track which he's currently flying toward."
	input ChooseFarthestPathPoint(void) : "When tracking an enemy, choose the point on the path furthest from the enemy, but still in firing range."
	input ChooseNearestPathPoint(void) : "When tracking an enemy, choose the point on the path nearest from the enemy."
	input StartBreakableMovement(void) : "The helicopter is now allowed to disobey direct commands to go to particular points if he senses an enemy. He will move to the closest point (or farthest point, if ChooseFarthestPathPoint is used), on the path if he senses an enemy."
	input StopBreakableMovement(void) : "The helicopter can not disobey direct commands. He will continue to fly along his patrol path or to his specified target even if he senses an enemy."

	spawnflags(Flags) =
	[
		// AWAIT INPUT will make the helicopter spawn disabled, awaiting 
		// the "Activate" input to start acting.
		32 : "No Rotorwash" : 0
		64 : "Await Input" : 0
	]
]

@BaseClass base(Targetname, Global, Parentname, Origin, EnableDisable) = Trigger
[
	spawnflags(flags) = 
	[
		1: "Clients" : 1
		2: "NPCs" : 0
		8: "Physics Objects" : 0
		16: "Only Player Ally NPCs (overrides 'NPCs')" : 0
		32: "Only Clients in Vehicles (disallow if not)" : 0
		64: "Everything (won't override anything--if used, check this *only*)" : 0
		512: "Only Clients *Not* in Vehicles (disallow if in)" : 0
	]

	filtername(filterclass) : "Filter Name" : : "Filter to use to see if activator triggers me. See filter_activator_name for more explanation."

	// Inputs
	input Toggle(void) : "Toggles this trigger between enabled and disabled states."

	// Outputs
	output OnStartTouch(void) : "Fired when an entity starts touching this trigger. The touching entity must pass this trigger's filters to cause this output to fire."
	output OnEndTouch(void) : "Fired when an entity stops touching this trigger. Only entities that passed this trigger's filters will cause this output to fire."
	output OnEndTouchAll(void) : "Fires when an entity stops touching this trigger, and no other entities are touching it. Only entities that passed this trigger's filters are considered."
]

//-------------------------------------------------------------------------
//
// World
//
//-------------------------------------------------------------------------
@SolidClass = worldspawn : "This is the world entity. Each map can only contain one, and it's automatically created for you.  Changes to the world affect the entire map.\n\n"+
	"The world entity is composed of all of the map's brushes not tied to entities."
[
	message(string) : "Map Description / Title"
	skyname(string) : "SkyBox Texture Name" : "sky_day01_01" : "The set of sky textures to use for this map."
	chaptertitle(string) : "Chapter Title Message" : "" : "Chapter Title that appears onscreen when this level starts."
	startdark(choices) : "Level Fade In" : 0 =
	[	
		0 : "No"
		1 : "Yes"
	]
	gametitle(choices) : "Display Game Title" : 0 : "Game Title appears onscreen when this level starts." = 
	[	
		0 : "No"
		1 : "Yes"
	]
	newunit(choices) : "New Level Unit" : 0 : "Used to clear out savegame data of previous levels to keep the savegame size as small as possible. Only set it to Yes if the player cannot return to any previous levels." = 
	[
		0 : "No, keep current"
		1 : "Yes, clear previous levels"
	]
	no_decomp(choices) : "Disallow Decompiling" : : "If Yes, then new versions of VMEX will refuse to decompile your map." =
	[
		"" : "No"
		1 : "Yes"
	]
	maxoccludeearea(float) : "Max occludee area" : "0" : "Prevents occlusion testing for entities that take up more than X% of the screen." 
	minoccluderarea(float) : "Min occluder area" : "0" : "Prevents this occluder from being used if it takes up less than X% of the screen." 
	maxpropscreenwidth(float) : "Start Fade Pixels" : -1 : "Number of pixels wide at which all props in the level start to fade (<0 = use fademaxdist). This number is ignored if the prop has a specific fade distance specified."
	minpropscreenwidth(float) : "End Fade Pixels" : 0 : "Minimum number of pixels wide at which the prop is visible (0 = don't fade out). This number is ignored if the prop has a specific fade distance specified."
	detailmaterial(material) : "Detail Material" : "detail/detailsprites" : "Defines a custom detail material for client-spawned details."
	detailvbsp(string) : "Detail .VBSP" : "detail.vbsp" : "Defines a .VBSP file to use for client-spawned details, in the mod directory."
	_minlight(float) : "Map-wide minimum light level" : 0 : "Forces the minimum intensity of light throughout the map to be at least this.  Expressed as a float from 0.0 to 2.0, with 0.0 being pitch black (default) and 2.0 being fullbright."
]

@PointClass base(Targetname) iconsprite("editor/ambient_generic.vmt") sphere(radius) = ambient_generic : "Universal ambient sound.  Use it to play and control a single sound.\n\n"+
	"Custom WAVs must be in standard PCM format.  Custom MP3s must not have a sample rate higher than 44.1KHz.  It's okay to use exceedingly long sounds, but try to keep the sound's filesize down."
[
	message(sound) : "Sound Name" : "" : "Name of the GameSound entry for the sound to play.  Also supports direct .wav/.mp3 filenames.  If you supply a WAV/MP3, it must be within '<moddir>/sound' and you must use slashes (/), not backslashes."
	health(integer) : "Full Volume" : 10 : "The final volume of the sound after fading in.  10 is the loudest; 1 is the softest.  The default is 10."
	preset(choices) :"Dynamic Presets" : 0 : "A preset pattern of volume, pitch, etc. to apply for this sound. 'Haunted,' for instance, changes the pitch, volume, and tempo of the sound to create a haunted-house effect." =
	[
		0: "None"
		1: "Huge Machine"
		2: "Big Machine"
		3: "Machine"
		4: "Slow Fade in"  
		5: "Fade in"
		6: "Quick Fade in"
		7: "Slow Pulse"
		8: "Pulse"
		9: "Quick pulse"
		10: "Slow Oscillator"
		11: "Oscillator"
		12: "Quick Oscillator"
		13: "Grunge pitch"
		14: "Very low pitch"
		15: "Low pitch"
		16: "High pitch"
		17: "Very high pitch"
		18: "Screaming pitch"
		19: "Oscillate spinup/down"
		20: "Pulse spinup/down"
		21: "Random pitch"
		22: "Random pitch fast"
		23: "Incremental Spinup"
		24: "Alien"
		25: "Bizzare"
		26: "Planet X"
		27: "Haunted"
	]
	volstart(integer) : "Start Volume" : 0 : "The starting volume of this sound. When the entity is triggered, the volume will either go down to 0 or up to the Full Volume, depending on which input you send the ambient_generic."
	fadein(integer) : "Fade in time (0-100)" : 0 : "Time taken to fade the sound from 0 volume to 100% volume.  Measured as a percentage of the sound's length."
	fadeout(integer) : "Fade out time (0-100)" : 0 : "Time taken to fade the sound from 100% volume to 0 volume.  Measured as a percentage of the sound's length."
	pitch(integer) : "Full Pitch" : 100 : "Sound pitch, expressed as a range from 1 to 255, where 100 is the sound's default pitch."
	pitchstart(integer) : "Start Pitch" : 100 : "The starting pitch of the sound."
	spinup(integer) : "Spin up time (0-100)" : 0 : "Same as fade in time, but for pitch, not volume."
	spindown(integer) : "Spin down time (0-100)" : 0 : "Same as fade out time, but for pitch, not volume."
	lfotype(choices) : "LFO type" : 0 : "The type of vibrato to apply to the sound.  (LFO = low-frequency oscillator = vibrato)" =
	[
		0 : "Off"
		1 : "Square: full up or down, never middle"
		2 : "Triangle:  fade between up and down"
		3 : "Random"
	]
	lforate(integer) : "LFO rate (0-1000)" : 0 : "Rate of pitch changes if an LFO type is specified."
	lfomodpitch(integer) : "LFO mod pitch (0-100)" : 0 : "Amount by which to change the pitch if an LFO type is selected."
	lfomodvol(integer) : "LFO mod vol (0-100)" : 0 : "Amount by which to change the volume if an LFO type is selected."
	cspinup(integer) : "Incremental Spinup Count (1-100)" : 0 : "When nonzero, scales the amount by which the pitch of the sound is increased with each PlaySound input until the pitch reaches the maximum supported."
	radius(string) : "Max Audible Distance" : "1250" : "Maximum distance at which this sound is audible."
	spawnflags(flags) =
	[
		1 : "Play everywhere" : 0
		16 : "Start Silent (use for triggerable sounds)" : 1
		32 : "Is NOT Looped (only affects auto-looped WAVs)" : 1
	]
	SourceEntityName(target_destination) : "Source Entity Name" : : "If an entity is specified, sound will come from the named entity instead of this ambient."

	// Inputs
	input Pitch(integer) : "Set the sound pitch, expressed as a range from 1 to 255, where 100 is the sound's default pitch."
	input PlaySound(void) : "Start the sound."
	input StopSound(void) : "Stop the sound if it is playing."
	input ToggleSound(void) : "Toggle the sound between playing and stopping."
	input Volume(integer) : "Set the sound volume, expressed as a range from 0 to 10, where 10 is the loudest."
]

//-------------------------------------------------------------------------
// A VGUI screen -- This is broken without code modifications
// (and if you're modifying code for it, you should know how it works!)
//-------------------------------------------------------------------------
//@PointClass base(Targetname, Parentname, Angles) size(-4 -4 -4, 4 4 4) = vgui_screen
//[
//	panelname(string) : "Panel Name"
//	overlaymaterial(material) : "Overlay Material (optional)"
//	width(integer) : "Panel Width"
//	height(integer) : "Panel Height"
//
//	input SetActive(void)
//	input SetInactive(void)
//]

//-------------------------------------------------------------------------
//
// Cyclers
//
//-------------------------------------------------------------------------
@PointClass base(Targetname, Parentname, Angles, Studiomodel) studioprop() = cycler : "An entity used to display a model for testing purposes. Shooting it with cycle through the model's animations.  Cycler is a very bad way of placing a model; however, for testing purposes, " +
	"it could be useful.  You should use a prop_dynamic, prop_physics, or some other prop instead for realistic purposes."
[
	spawnflags(flags) =
	[
		1: "Not Solid" : 0
	]
	sequence(integer) : "Sequence" : 0 : "Default animation sequence for the model to be playing after spawning."

	input SetSequence(string) : "Set the cycler's sequence."
	input Break(void) : "Break the cycler; same input as Kill, but the cycler entity isn't removed."
]

//-------------------------------------------------------------------------
//
// Point-based environmental effects
//
//-------------------------------------------------------------------------
@PointClass base(Targetname) = env_zoom : "A HL2 single-player entity that can be used to control the size of the player's view cone (FOV stands for Field Of View).  This creates a zoom effect, as a 50-degree cone must be expanded in size to fit the screen (since the normal FOV encompasses 90 degrees)."
[
	FOV(integer) : "Target FOV" : 75 : "Size of view cone in degrees when this entity is active."
	Rate(float) : "Seconds to Reach Target" : "1.0" : "Amount of time it should take to reach the specified FOV."

	input Zoom(void) : "Start controlling the player's FOV."
	input UnZoom(void) : "Stop controlling the player's FOV."

	spawnflags(flags) =
	[
		1: "Allow other zoom effects (like suit zoom) to override this one" : 0
	]
]

@PointClass base(Targetname) = env_screenoverlay: "This entity superimposes materials onto the screen of the player who sends it an input.  Useful for view effects like drunkenness, or teleporter afterimages, etc. "+
	"Because these are actually displayed on the player's screen, it's recommended that they be translucent.  Try the materials in 'overlays/'."
[
	OverlayName1(material) : "Overlay Name 1" : "" : "Name of the first overlay material to display."
	OverlayTime1(float) : "Overlay Duration 1" : "1.0" : "Amount of time that the first overlay should be displayed for, after which it will begin showing the second overlay.  Use -1 for a permanent display."
	OverlayName2(material) : "Overlay Name 2" : "" : "Name of the second overlay material to display. If left blank, overlay displaying will finish, and this entity will consider itself done."
	OverlayTime2(float) : "Overlay Duration 2" : "1.0" : "Amount of time that the second overlay should be displayed for, after which it will begin showing the third overlay.  Use -1 for a permanent display."
	OverlayName3(material) : "Overlay Name 3" : "" : "Name of the third overlay material to display. If left blank, overlay displaying will finish, and this entity will consider itself done."
	OverlayTime3(float) : "Overlay Duration 3" : "1.0" : "Amount of time that the third overlay should be displayed for, after which it will begin showing the fourth overlay.  Use -1 for a permanent display."
	OverlayName4(material) : "Overlay Name 4" : "" : "Name of the fourth overlay material to display. If left blank, overlay displaying will finish, and this entity will consider itself done."
	OverlayTime4(float) : "Overlay Duration 4" : "1.0" : "Amount of time that the fourth overlay should be displayed for, after which it will begin showing the fifth overlay.  Use -1 for a permanent display."
	OverlayName5(material) : "Overlay Name 5" : "" : "Name of the fifth overlay material to display. If left blank, overlay displaying will finish, and this entity will consider itself done."
	OverlayTime5(float) : "Overlay Duration 5" : "1.0" : "Amount of time that the fifth overlay should be displayed for, after which it will begin showing the sixth overlay.  Use -1 for a permanent display."
	OverlayName6(material) : "Overlay Name 6" : "" : "Name of the sixth overlay material to display. If left blank, overlay displaying will finish, and this entity will consider itself done."
	OverlayTime6(float) : "Overlay Duration 6" : "1.0" : "Amount of time that the sixth overlay should be displayed for, after which it will begin showing the seventh overlay.  Use -1 for a permanent display."
	OverlayName7(material) : "Overlay Name 7" : "" : "Name of the seventh overlay material to display. If left blank, overlay displaying will finish, and this entity will consider itself done."
	OverlayTime7(float) : "Overlay Duration 7" : "1.0" : "Amount of time that the seventh overlay should be displayed for, after which it will begin showing the eighth overlay.  Use -1 for a permanent display."
	OverlayName8(material) : "Overlay Name 8" : "" : "Name of the eighth overlay material to display. If left blank, overlay displaying will finish, and this entity will consider itself done."
	OverlayTime8(float) : "Overlay Duration 8" : "1.0" : "Amount of time that the eighth overlay should be displayed for, after which it will begin showing the ninth overlay.  Use -1 for a permanent display."
	OverlayName9(material) : "Overlay Name 9" : "" : "Name of the ninth overlay material to display. If left blank, overlay displaying will finish, and this entity will consider itself done."
	OverlayTime9(float) : "Overlay Duration 9" : "1.0" : "Amount of time that the ninth overlay should be displayed for, after which it will begin showing the tenth overlay.  Use -1 for a permanent display."
	OverlayName10(material) : "Overlay Name 10" : "" : "Name of the tenth overlay material to display. If left blank, overlay displaying will finish, and this entity will consider itself done."
	OverlayTime10(float) : "Overlay Duration 10" : "1.0" : "Amount of time that the tenth overlay should be displayed for, after which this entity will stop displaying overlays.  Use -1 for a permanent display."

	// Inputs
	input	StartOverlays(void)	: "Start displaying the first overlay."
	input	StopOverlays(void) : "Stop displaying any overlays."
	input	SwitchOverlay(float) : "Switch to displaying a specific overlay. Pass in the desired overlay number in the parameter."
]

@PointClass base(Targetname) = env_texturetoggle : "An entity that allows you to change the animated texture frame on a brush entity that uses animated textures."
[
	target(target_destination) : "Target Brush(es)" 

	input	IncrementTextureIndex(void) : "Increment target brush's current texture frame by one."
	input	SetTextureIndex(integer) : "Set target brush's texture frame to the specified index."
]

@PointClass base(Targetname, Parentname) = env_splash : "An entity that creates a splash effect at its origin, not necessarily in water. If the 'find water surface' spawnflag is set, it will instead trace down below itself to find the water surface on which to create splashes. "+
	"The 'diminish with depth' flag will measure the distance between the entity and the closest solid face directly below it and scale the effect inversely based on that distance; if the nearest solid face is >108 units away, the splash will not occur."
[
	scale(float) : "Scale of the splash" : "8.0" : "A rough scalar for the size of the effect.  16.0 should create a splash about the size of a player."

	// Inputs
	input Splash(void) : "Create a splash effect."

	spawnflags(flags) =
	[
		1: "Automatically find water surface (place entity above water)" : 0
		2: "Diminish with depth (shallow water makes a bigger splash)" : 0
	]
]

@PointClass base(Targetname, Parentname) color(180 10 180) = env_particlelight : "An entity that can be used to light the smoke particles emitted by env_smokestack entities."
[
	Color(color255)		: "Color"		: "255 0 0" : "Color emitted by this light." 
	Intensity(integer)	: "Intensity"	: 5000 : "Brightness of the light."

	directional(choices) : "Directional" : 0 : "If this is specified, then this light will use the bump map on the particles. Each particle system can have one ambient and one directional light." =
	[
		0 : "No (ambient)"
		1 : "Yes (directional)"
	]

	PSName(target_destination) : "Particle System Entity" : "" : "Set this to the name of the env_smokestack that you want this light to affect."
]

@PointClass base(Targetname, Angles) color(255 0 0) = env_sun : "An entity to draw a sun on the sky.  This is an effect only, and does not generate light; for light, use a 'light_environment' entity.  The sun will shine through most models."
[
	target(target_destination) : "Viewer entity" : : "Name of an entity used to determine where the sun is in the skybox. The sun will be drawn on the sky on the line from this entity to the env_sun entity."
	
	use_angles(choices) : "Use Angles" : 0 : "The old way to orient env_sun is to point it at a target. The new way is to specify the angles. If you want to specify the sun's angles, set this property to YES." = 
	[
		0 : "No"
		1 : "Yes"
	]

	rendercolor(color255)		: "Sun Color (R G B)" : "100 80 80"
	size(integer) : "Size" : 16

	input TurnOn(void)			: "Enable sun rendering."
	input TurnOff(void)			: "Disable sun rendering."
	input SetColor(color255)	: "Change the sun's color."
]

@PointClass base(Targetname) = game_ragdoll_manager : "An entity to control the number of ragdolls in the world, for performance reasons." 
[
	MaxRagdollCount(integer)	: "Max Ragdoll Count" : -1 : "Sets the max number of ragdolls that can be in the world at a time (if they are flagged to fade). Set to -1 if you want to use the default value (g_ragdoll_maxcount)."
	input SetMaxRagdollCount(integer)	: "Set the Max Ragdoll Count."
]

@PointClass base(Targetname, Angles) color(255 128 0) sphere(MinDist) sphere(MaxDist) sphere(OuterMaxDist) sphere(GlowProxySize) = env_lightglow : "Extension of env_sprite.  An entity that places an additive glow in the world, mostly used as a halo over light sources.  In order to turn off this effect, send it a Color input with parameter '0 0 0'."
[
	rendercolor(color255)	: "Color (R G B)"	: "255 255 255"
	VerticalGlowSize(integer)		: "Vertical Size" : 30 : "Vertical diameter of the ellipse.  Constant; does not change with distance."
	HorizontalGlowSize(integer)		: "Horizontal Size" : 30 : "Horizontal diameter of the ellipse.  Constant; does not change with distance."
	MinDist(integer)				: "Minimum Distance" : 64 : "The sprite will be invisible if the camera is closer to it than this distance."
	MaxDist(integer)				: "Maximum Distance" : 256 : "The sprite will be fully visible if the camera is further from it than this distance."
	OuterMaxDist(integer)			: "Outer Maximum Distance" : 0 : "Once the maximum distance is reached, the sprite will begin to fade out again, becoming invisible once the camera is further than this distance from it.  Disabled if less than the max distance."
	GlowProxySize(float) : "Glow Proxy Geometry Size" : "2.0" : "Size of the glow to be rendered for visibility testing. Must be larger than the distance from the sprite center to empty space. So if this glow is inside geometry (like a light bulb), set this value to be bigger than the bulb's radius.  Any time a sphere of this radius would be visible (poking through any nearby geometry), the glow will be rendered."

	// Inputs
	input Color(color255)	: "Change the render color of the glow."

	spawnflags(flags) =
	[
		1: "Visible only from front - camera must be within 90 degrees of Angles to see" : 0
	]
]

@PointClass base(Targetname) iconsprite("editor/env_fade") = env_fade : "An entity that controls screen fades."
[
	spawnflags(flags) =
	[
		1: "Fade From" : 0
		2: "Modulate" : 0
		4: "Only affect activator" : 1
		8: "Stay Out" : 0
	]
	duration(string) : "Duration (seconds)" : "2" : "The time that it will take to fade the screen in or out."
	holdtime(string) : "Hold Fade (seconds)" : "0" : "The time to hold the faded in/out state."
	renderamt(integer) : "Fade Alpha" : 255 : "Alpha of the fade, where 0 = fully transparent and 255 = fully opaque." 
	rendercolor(color255) : "Fade Color (R G B)" : "0 0 0"
	
	// Inputs
	input Fade(void) : "Start the screen fade."

	// Outputs
	output OnBeginFade(void) : "Fired when the fade has begun."
]

@PointClass base(Targetname) = env_player_surface_trigger : "An entity that monitors the material of the surface the player is standing on, and fires outputs whenever it changes to/from a specific material."
[
	gamematerial(choices) : "Game Material to Watch" : "0" : "The material to watch. When the player stands on/off this material, this entity's outputs will be fired." =
	[
		0 : "None (player's in the air)"
		67 : "Concrete"
		77 : "Metal"
		68 : "Dirt"
		86 : "Vent"
		71 : "Grate"
		84 : "Tile"
		83 : "Slosh"
		87 : "Wood"
		80 : "Computer"
		89 : "Glass"
		70 : "Flesh"
		73 : "Clip"
		79 : "Foliage"
		78 : "Sand"
	]
	
	// Inputs
	input Enable(void) : "Start watching the player's surface."
	input Disable(void) : "Stop watching the player's surface."

	// Outputs
	output OnSurfaceChangedToTarget(void) : "Fired when the player moves onto the specified game material."
	output OnSurfaceChangedFromTarget(void) : "Fired when the player moves off the specified game material."
]

@PointClass size( -4 -4 -4, 4 4 4 ) base(Targetname, Parentname) = env_ar2explosion :
	"AR2 explosion visual effect.  Big, volume-filling brown cloud.  Does not cause damage or emit sound."
[
	input Explode(Void) : "Make the explosion effect."
	material(material) : "Particle Material" : "particle/particle_noisesphere" : "The material to use for each particle in the explosion."
]

@PointClass base(Targetname, Parentname, RenderFxChoices) size(-4 -4 -4, 4 4 4) line(255 255 255, targetname, LightningStart, targetname, LightningEnd) sphere(Radius) = env_beam : "An entity that creates a visible beam between two points. The points can be attached to entities to make the beam move around."
[
	renderamt(integer) : "Brightness (1 - 255)" : 100
	rendercolor(color255) : "Beam Color (R G B)" : "255 255 255"
	Radius(integer) : "Radius" : 256 : "In the absence of an ending entity, beams will be drawn from the starting entity to a random point within this radius."
	life(string) : "Life (seconds 0 = infinite)" : "1" : "Amount of time before the beam dies. Setting to zero will make the beam stay forever."
	BoltWidth(float) : "Width of beam" : 2 : "Pixel width of the beam."
	NoiseAmplitude(float) : "Amount of noise (0-255)" : 0 : "The amount of noise in the beam. 0 is a perfectly straight beam."
	texture(sprite) : "Sprite Name" : "sprites/laserbeam.spr" : "The material used to draw the beam."
	TextureScroll(integer) : "Texture Scroll Rate (0-100)" : 35 : "Rate at which the beam texture should scroll along the beam."
	framestart(integer) : "Sprite Frame to Use" : 0 : "The frame of the sprite material that should be used."
	StrikeTime(string) : "Strike again time (secs)" : "1" : "When the life is nonzero, the beam strikes, dies, then strikes again after this amount of time.  Can be negative to allow multiple beams at once."
	damage(string) : "Damage / second" : "0" : "How much damage this beam does per second to things it hits when it is continually on, or instantaneously if it strikes. For continuous damage, the value should be greater than 10 or it may not work."
	LightningStart(target_destination) : "Start Entity" : "" : "Entity that the beam starts at."
	LightningEnd(target_destination) : "Ending Entity" : "" : "Entity that the beam ends at."
	spawnflags(flags) = 
	[
		1 : "Start On" : 0
		4 : "Random Strike Again Time" : 0
		8 : "Create Ring" : 0
		16: "StartSparks (nonzero life only)" : 0
		32: "EndSparks (nonzero life only)" : 0
		64: "Decal End (nonzero life only)" : 0
		128: "Shade Start (zero life only)" : 0
		256: "Shade End (zero life only)" : 0
		512: "Taper Out (zero life only)" : 0
	]

	TouchType(choices) : "Touch Type (tripwire)" : 0 : "If you want the beam to fire an output when touched by entities, choose the entity type here." =
	[	
		0 : "Not a tripwire"
		1 : "Player Only"
		2 : "NPC Only"
		3 : "Player or NPC"
		4 : "Player or NPC or Physprop"
	]

	filtername(filterclass) : "Filter Name" : : "Filter to use to see if activator triggers me. See filter_activator_name for more explanation."

	// Inputs
	input TurnOn(void) : "Turns the beam on."
	input TurnOff(void) : "Turns the beam off."
	input Toggle(void) : "Toggles the beam between on and off."
	input StrikeOnce(void) : "Causes the beam to strike once. It will stay on for its set Life and then turn off (it will never turn off if Life is set to zero)."
	input Alpha(integer) : "Sets the beam's alpha (0 - 255)."
	input Color(color255) : "Sets the beam's render color (R G B)."
	input Noise(float) : "Set the amplitude of beam noise (0 - 255)."
	input ScrollSpeed(float) : "Set the scroll speed in units per second (0 - 100)."
	input Width(float) : "Set the width of the beam, in pixels."

	// Outputs
	output OnTouchedByEntity(void)			: "Fired when an entity touches the beam. Only fired if the entity passes the 'Touch Type' choice."
]

@PointClass base(Targetname, Parentname) size(-4 -4 -4, 4 4 4) = env_beverage : "Used to dispense a number of cool, refreshing beverages.\n\nWARNING:  There is no 'models/can.mdl'!  You will need to create your own!  If you're willing to download a custom one, try this link:\nhttp://www.editlife.net/files/can/canmdl02.zip"
[
	health(integer) : "Capacity" : 10 : "Number of cans in the dispenser."
	beveragetype(choices) : "Skin (beverage type)" : 0 = 
	[
		0 : "0 (Cola)"
		1 : "1 (Lemon-Lime)"
		2 : "2 (Diet Cola)"
		3 : "3 (Orange)"
		4 : "4 (Cream Soda)"
		5 : "5 (Root Beer)"
		6 : "Random"
	]

	input Activate(void) : "Dispense a beverage."
]
@PointClass base(Targetname, Parentname, Angles) studioprop("models/can.mdl") = item_sodacan : "A lone soda can.\n\nWARNING:  There is no 'models/can.mdl'!  You will need to create your own!  If you're willing to download a custom one, try this link:\nhttp://www.editlife.net/files/can/canmdl02.zip"
[
	skin(choices) : "Skin (beverage type)" : 0 = 
	[
		0 : "0 (Cola)"
		1 : "1 (Lemon-Lime)"
		2 : "2 (Diet Cola)"
		3 : "3 (Orange)"
		4 : "4 (Cream Soda)"
		5 : "5 (Root Beer)"
	]

	input skin(integer) : "Set the skin (beverage type) of the can"
	input Ignite(void) : "Set the can afire."

	output OnIgnite(void) : "Fired when the can is set on fire."
]

@PointClass base(Targetname, Parentname) size(-16 -16 -16, 16 16 16) color(255 0 0) = env_blood : "An entity used to spawn blood effects.  Can also work to emulate spurts of water..." 
[
	spraydir(angle) : "Spray Direction (Pitch Yaw Roll)" : "0 0 0" : "The general direction in which the blood should spray, and the direction to trace to apply the decal."
	color(choices) : "Blood Color" : 0 : "Blood may actually appear grey unless the map is displayed in fullbright." =
	[
		0 : "Red (Human)"
		1 : "Yellow (Alien)"
	]
	amount(float) : "Amount of blood" : "10"
	spawnflags(flags) =
	[
		1: "Random Direction" : 0
		//2: "Blood Stream" : 0 // The material for this one is nonexistent D:<
		4: "Spray From Activating Player (If no activator, use local player)" : 0
		8: "Spray Decals" : 0
		16: "Emit Blood Cloud" : 0
		32: "Shoot Blood Drops" : 1
		64: "Emit Gore" : 0
	]

	input EmitBlood(void) : "Triggers the blood effect."
]

@SolidClass base(Targetname, Parentname) = env_bubbles : "An entity used to create a volume in which to spawn bubbles." 
[
	density(integer) : "Bubble density" : 2
	frequency(integer) : "Bubble frequency" : 2
	current(integer) : "Speed of Current" : 0 : "The speed of the water current in the volume, used to move the bubbles."
	spawnflags(Flags) = 
	[
		1 : "Start Off" 	: 0
	]

	input Activate(void) : "Activates the bubbles."
	input Deactivate(void) :  "Deactivates the bubbles."
	input Toggle(void) :  "Toggles the bubbles on and off."
	input SetDensity(integer) : "Sets the bubble density."
	input SetFrequency(integer) : "Sets bubble emission rate in bubbles per second."
	input SetCurrent(integer) : "Sets current speed in units per second."
]

@PointClass color(0 0 255) sidelist(sides) iconsprite("editor/env_cubemap.vmt") = env_cubemap : "A very important entity that serves as a reference point from which the engine will build cubemaps.  "+
	"A cubemap is a 'snapshot' of the area immediately around an env_cubemap entity.  Reflective surfaces don't know on their own what they should be reflecting; instead, they seek out the nearest "+
	"env_cubemap entity and use its associated 'snapshot' to determine what they should be reflecting.\n\n"+
	"As such, env_cubemap entities should be placed near any static reflective surface, such as a pane of glass or a water surface.  There should also be env_cubemap entities placed at strategic "+
	"locations throughout the map such that a model can move from one area to a visually disparate one (such as moving from a blue room to a yellow hallway) while keeping reflections accurate for "+
	"the area it's currently in.\n\nIn order for cubemaps to accurately be applied to models, you must run the 'buildcubemaps' command in the in-game console.  You may need to reload the map afterwards."
[
	cubemapsize(choices) : "Cubemap Size" : 0 =
	[
		0 : "Default (recommended)"
		1 : "1x1"
		2 : "2x2"
		3 : "4x4"
		4 : "8x8"
		5 : "16x16"
		6 : "32x32"
		7 : "64x64"
		8 : "128x128"
		9 : "256x256"
	]
	sides(sidelist) : "Brush faces" : : "Force these faces to use this env_cubemap."
]

@PointClass base( Targetname, Parentname, Angles ) size( -8 -8 -8, 8 8 8 ) = env_dustpuff : "An entity that can emit dust puffs."
[
	scale(float) : "Scale"	: 8 : "Size of the dust puff."
	speed(float) : "Speed"	: 16 : "Speed at which the dust particles should move."

	color(color255) : "Dust color" : "128 128 128"

	// Inputs
	input SpawnDust(void) : "Spawn a dust puff."
]

@PointClass base( Targetname, Parentname, Angles ) size( -8 -8 -8, 8 8 8 ) = env_effectscript : 
	"An entity that allows you to script special visual effects via a script file."
[
	model(studio) : "Script Model" : "models/Effects/teleporttrail.mdl" : "Model to use for animation sequences."
	scriptfile(string) : "Script File" : "scripts/effects/testeffect.txt" : "Name of the script to use for this model." 

	// Inputs
	input SetSequence(string) : "Sets the script model's sequence."
]

@SolidClass base(Targetname, Parentname, Angles) = env_embers : "An entity used to create a volume in which to spawn fire embers." 
[
	particletype(choices) : "Ember type" : 0 =
	[
		0 : "Normal"
		1 : "Smooth Fade"
		2 : "Pulled"
	]

	density(integer) : "Density (particles per second)" : 50
	lifetime(integer) : "Particle Lifetime (seconds)" : 4
	speed(integer) : "Particle Speed (units per second)" : 32
	rendercolor(color255) : "Ember Color (R G B)" : "255 255 255"	

	spawnflags(Flags) = 
	[
		1 : "Start On" 	: 0
		2 : "Toggle"	: 0
	]
]

@PointClass base(Targetname) size(-4 -4 -4, 4 4 4) color(0 180 0) = env_entity_igniter :"An entity that catches a target entity on fire. If the entity is an animating model, it will have sprite flames attached to its skeleton. Otherwise the entity will emit particle flame puffs."
[
	target(target_destination) : "Entity to ignite" : : "Name of the entity to catch on fire."
	lifetime(float) : "Lifetime in seconds" : 10 : "Duration of flames."
	
	input Ignite(void) : "Ignite the target entity."
]

@PointClass base(Targetname, Parentname) iconsprite("editor/env_explosion.vmt") = env_explosion : "An entity that creates an explosion at its origin." 
[
	iMagnitude(Integer) : "Magnitude" : 100 : "Power of the explosion.  Used to determine how much damage to deal over how much distance, and how large to make the explosion sprite."
	iRadiusOverride(Integer) : "Radius Override" : 0 : "If specified, the radius in which the explosion damages entities.  If unspecified, the radius will be based on the magnitude."
	fireballsprite(sprite) : "Fireball Sprite" : "sprites/zerogxplode.spr"
	rendermode(choices) : "Render Mode" : 5 : "Rendering mode to use for the sprite." =
	[
		0: "Normal (no transparency)"
		// 4: "Solid"
		5: "Additive (erase black background)"
	]
	spawnflags(flags) =
	[
		1: "No Damage" : 0
		2: "Repeatable" : 0
		4: "No Fireball" : 0
		16: "No Decal" : 0
		32: "No Sparks" : 0
		64: "No Sound" : 0
		128: "Random Orientation for Explosion Sprite" : 0
		256: "No Fireball Smoke" : 0
		512: "No particles" : 0
		1024: "No Light" : 0
		2048: "Don't clamp sprite scale to >= 10" : 0
		4096: "Don't clamp sprite scale to <= 50" : 0
		8192: "Don't damage underwater objects" : 0
	]

	// Inputs
	input Explode(void) : "Triggers the explosion."
]

@PointClass size( -4 -4 -4, 4 4 4 ) base(Targetname, Parentname, Angles) = env_flare : "The flare used by Combine soldiers to light dark tunnels before ambushing."
[
	scale(float) : "Scale" : 1 : "Scale of the flare's sprite."
	
	spawnflags(Flags) =
	[
		1 : "No Dynamic Light" : 0
		2 : "No Smoke" : 0
		4 : "Infinite Duration" : 0
		8 : "Start off" : 0
	]

	input Start(float) : "Start the flare for <parameters> seconds.  -1 means don't die."
	input Die(float) : "Fizzle out and die over <parameters> seconds.  Don't send this input unless the flare has already been started!"
	input Launch(float) : "Launch the flare in the direction of its angles with the specified speed."
]

@PointClass base(Targetname, Parentname, EnableDisable) iconsprite("editor/env_fire") color(0 180 0) = env_fire : "An entity that handles a single flame at its origin. The flame causes heat 'damage' to other env_fire entities around it, and will eventually ignite non-flaming env_fire entities nearby, causing the fire to spread."
[
	health(integer) : "Duration" : 30 : "Amount of time the fire will burn."
	firesize(integer) : "Size" : 64 : "Height (in world units) of the flame."
	fireattack(integer) : "Attack" : 4 : "Amount of time the fire takes to grow to full strength."
	firetype(choices) : "Type" : 0 =
	[
		0 : "Natural"
		1 : "Plasma"
	]
	spawnflags(flags) =
	[
		1:	"Infinite Duration" : 0
		2:	"Smokeless" : 0
		4:	"Start On" : 0
		8:	"Start Full" : 0
		16:	"Don't drop" : 0
		32: 	"No glow" : 0
		128: 	"Delete when out" : 0
	]

	ignitionpoint(float) : "Ignition Point" : 32 : "Amount of heat 'damage' to take before this flame should ignite."
	damagescale(float) : "Damage Scale" : "1.0" : "Scales damage done by the flame."

	// Inputs
	input StartFire(void)			: "Start the fire."
	input Extinguish(float)			: "Puts out the fire permanently in the number of seconds specified."
	input ExtinguishTemporary(float): "Puts out the fire temporarily in the number of seconds specified."

	// Outputs
	output OnIgnited(void)			: "Fires when the fire is first ignited."
	output OnExtinguished(void)		: "Fires when the fire is fully extinguished."
]

@PointClass base(Targetname, Parentname) iconsprite("editor/env_firesource") color(255 255 0) sphere(fireradius) = env_firesource : "An entity that provides heat to all nearby env_fire entities without actually creating a flame."
[
	spawnflags(flags) =
	[
		1:	"Start On" : 0
	]

	fireradius(float) : "Radius" : 128 : "The radius around this entity in which to provide heat."
	firedamage(float) : "Intensity / Damage" : 10 : "Amount of heat 'damage' to apply to env_fire entities within the radius."

	// Inputs
	input Enable(void)				: "Enable fire source."
	input Disable(void)				: "Disable fire source."
]

@PointClass base(Targetname, Parentname) size(-4 -4 -4, 4 4 4) color(255 255 0) sphere(fireradius) = env_firesensor : "An entity that detects changes in heat nearby."
[
	spawnflags(flags) =
	[
		1:	"Start On" : 1
	]

	fireradius(float) : "Radius" : 128 : "The radius around this entity in which to detect heat changes."
	heatlevel(float) : "Heat level" : 32 : "The target heat level to check for.  Outputs are fired when the heat moves over this target level (increasing or decreasing)."
	heattime(float) : "Time at level" : 0 : "The amount of time the heat level must spend over the target level before the 'OnHeatLevelStart' output is fired."

	// Inputs
	input Enable(void)				: "Enable fire sensor."
	input Disable(void)				: "Disable fire sensor."
	output OnHeatLevelStart(void)	: "Fires when the heat level has been sustained for the specified length of time."
	output OnHeatLevelEnd(void)		: "Fires when the heat level drops below the target level."
]

@PointClass base(Targetname, DXLevelChoice, Angles) iconsprite("editor/fog_controller.vmt") color(255 255 255) = env_fog_controller : "An entity that controls the fog and view distance in the map.  "+
	"If Fog Blend is enabled, then looking in the direction of this entity's angles or in the direction specified by Primary Fog Direction "+
	"shows primary fog; looking the other way shows secondary fog, and looking somewhere between shows a fade from one to the other."
[
	// Inputs
	input SetStartDist(float) : "Set the fog start distance."
	input SetEndDist(float) : "Set the fog end distance."
	input TurnOn(void) : "Turn the fog on."
	input TurnOff(void) : "Turn the fog off."
	input SetColor(color255) : "Set the primary fog color."
	input SetColorSecondary(color255) : "Set the secondary fog color."
	input SetFarZ(integer): "Set the far clip plane distance."
	input SetAngles(string) : "Set the angles to use for the secondary fog direction."

	// Starting fog parameters for the level. These are selectable per LOD.	
	fogenable(choices) : "Fog Enable" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]
	fogblend(choices) : "Fog Blend" : 0 : "Whether to use the secondary fog color as well as the primary." =
	[
		0 : "No"
		1 : "Yes"
	]
	fogcolor(color255) : "Primary Fog Color" : "255 255 255"
	fogcolor2(color255) : "Secondary Fog Color" : "255 255 255"
	use_angles(choices) : "Use Angles for Fog Dir" : 0 : "Use this entity's pitch, yaw, and roll as the primary fog direction instead of the vector below." =
	[
		0 : "No"
		1 : "Yes"
	]
	fogdir(string) : "Primary Fog Direction" : "1 0 0" : "A vector that determines the directions of the primary and secondary fog."
	fogstart(string) : "Fog Start" : "500.0" : "Distance from the camera at which visibility begins to decrease."
	fogend(string) : "Fog End" : "2000.0" : "Distance from the camera at which fog completely obscures anything behind it."
	
	farz(string) : "Far Z Clip Plane (-1 = disable)" : "-1" : "Nothing but sky will be rendered beyond this distance from the camera."
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = env_global : "An entity to control a global game state.  This state can later be checked by other entities.  "+
	"For instance, pressing a button in map A can set the 'button_is_pressed' state, which would cause a logic_auto in map B to open a door that would have been closed "+
	"had the button in map A not been pressed.  To create your own states, simply write them into the 'Global State' text field."
[
	globalstate(choices) : "Global State to Set" : : "The state to set on, off, or dead." =
	[
		"gordon_precriminal" : "Gordon pre-criminal" 
		"antlion_allied" : "Antlions are player allies" 
		"suit_no_sprint" : "Suit sprint function not yet enabled" 
		"super_phys_gun" : "Super phys gun is enabled" 
		"friendly_encounter" : "Friendly encounter sequence (lower weapons, etc.)"
		"gordon_invulnerable" : "Gordon is invulnerable"
		"no_seagulls_on_jeep" : "Don't spawn seagulls on the jeep"
	]

	initialstate(choices) : "Initial State" : 1 =
	[
		0 : "Off"
		1 : "On"
		2 : "Dead"
	]
	spawnflags(flags) =
	[
		1 : "Set Initial State" : 0
	]

	// Inputs
	input TurnOn(void) : "Set state of global to ON."
	input TurnOff(void) : "Set state of global to OFF."
	input Toggle(void) : "Toggles state of global between ON and OFF."
	input Remove(void) : "Set state of global to DEAD."
]

@PointClass base(Targetname, Parentname, EnableDisable) = env_gunfire : "Gunfire Effect"
[
	target(target_destination) : "Target" : "" : "Shoot at this target. REMEMBER - this is an effect only! It does not do damage!"

	minburstsize(integer) : "Min Burst Size" : 2 : "Minimum number of rounds in a burst."
	maxburstsize(integer) : "Max Burst Size" : 7 : "Maximum number of rounds in a burst."

	minburstdelay(float) : "Min Delay Between Bursts" : 2 : "Minimum delay between bursts. (seconds)"
	maxburstdelay(float) : "Max Delay Between Bursts" : 5 : "Maximum delay between bursts. (seconds)"

	rateoffire(float) : "Rate of fire" : 10 : "Expressed as rounds per second"

	spread(choices) : "Bullet spread" : 5 : "The 'cone of inaccuracy' of the shots fired by this entity." =
	[
		0 : "Perfect accuracy"
		1 : "1 Degree"
		5 : "5 Degrees"
		10 : "10 Degrees"
		15 : "15 Degrees"
	]

	bias(choices) : "Bullet distribution should be..." : 1 : "How to distribute bullets within the spread. Even distribution is a true scatter throughout the spread. Biased towards the outside makes the shots 'miss' the target by tending towards the outside of the spread." =
	[
		1 : "Evenly distributed"
		-1 : "Biased towards the outside"
	]

	collisions(choices) : "Collision detection" : 0 : "Whether/how to handle bullet collision detection. NOTE: If you select NONE, this entity will be very cheap to use, but all bullets will stop short at their target's position in space and there will be no impact effects. Normal collision detection does the same things NPCs do when they fire their guns (except harm anything)." =
	[
		0 : "None. Cheap for performance."
		1 : "Normal collision detection."
	]

	shootsound(sound) : "Shoot Sound" : "Weapon_AR2.NPC_Single" : "Gunfire sound to make.  Weapon_AR2.NPC_Single = AR2; Weapon_SMG1.NPC_Single = SMG1"

	tracertype(choices) : "Tracer" : "" : "Type of tracer to display" = 
	[
		""		: "Default"
		"AR2TRACER"	: "AR2"
	]
]

@PointClass base(Targetname,Angles,Parentname) sphere(DamageRadius) studioprop("models/props_combine/headcrabcannister01b.mdl") = env_headcrabcanister : "Headcrab canister"
[
	spawnflags(Flags) = 
	[
		1	:  "No Impact Sound"		: 0
		2	:  "No Launch Sound"		: 0
		4096 : "Start Impacted"			: 0
		8192 : "Land at initial position" : 0
		16384 : "Wait for input to open" : 0
		32768 : "Wait for input to spawn headcrabs" : 0
		65536 : "No smoke" : 0
		131072	: "No shake" : 0
		262144	: "Remove on impact" : 0
		524288	: "No impact effects" : 0
	]
	HeadcrabType(choices) : "Which headcrab to spawn?" : 0 =
	[
		0 : "Normal headcrabs"
		1 : "Fast Headcrabs"
		2 : "Poison Headcrabs"
	]
	HeadcrabCount(integer)	: "Headcrab count"		: 6		: "Number of headcrabs to spawn on impact"
	FlightSpeed(float)		: "Flight Speed"		: 3000  : "Speed to fly through the air"
	FlightTime(float)		: "Flight Time"			: 5	    : "Time to fly through the air in seconds"
	StartingHeight(float)	: "Starting Height"		: 0		: "Relative height from the landing position at which the canister should be launched. Positive values mean launch it above the impact point, negative values mean launch it below."
	MinSkyboxRefireTime(float) : "Min Refire Time"	: 0		: "Min number of seconds before the cannister is refired. This will only work for cannisters placed in the skybox."
	MaxSkyboxRefireTime(float) : "Max Refire Time"	: 0		: "Max number of seconds before the cannister is refired. This will only work for cannisters placed in the skybox."
	SkyboxCannisterCount(integer)	: "Cannister count"		: 1		: "Number of cannisters to fire in the skybox (0 means fire continuously, forever)."
	Damage(float)			: "Impact damage"		: 150	: "Max damage the canister applies on impact"
	DamageRadius(float)		: "Impact damage radius": 750	: "Max radius of the impact damage for the canister"
	SmokeLifetime(float)	: "Smoke Duration" : 30 : "Duration that the canister smokes.  -1 means always smoke."

	// Inputs
	input FireCanister(void) : "Fire the canister"
	input OpenCanister(void) : "Opens the canister (must be called after the OnImpacted output is fired)"
	input SpawnHeadcrabs(void) : "Spawns headcrabs (must be called after the OnImpacted output is fired and after OpenCanister is triggered, if the Wait for Input to open spawnflag is checked.)"
	input StopSmoke(void) : "Stops the smoke if it's on"

	// Outputs
	output OnLaunched(string) : "Fired when the canister is launched"
	output OnImpacted(void) : "Fires when canister hits the ground"
	output OnOpened(void) : "Fires when canister has finished opening"
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = env_hudhint : "An entity to control the display of HUD hints. HUD hints are used to show the player what key is bound to a particular command."
[
	message(string) : "Hint Text (localized)" : "" : "This should be set to match the desired HUD hint entry in the hl2\resource\valve_english.txt."

	// Inputs
	input ShowHudHint(void) : "Shows the hint message."
]

@PointClass base(Targetname, Parentname, RenderFxChoices) size(-4 -4 -4, 4 4 4) line(255 255 255, targetname, LaserTarget) = env_laser : "An entity that creates a laser beam between itself and a given target.  Unlike env_beam, this laser does not pass through solid objects."
[
	LaserTarget(target_destination) : "Target of Laser" : : "Name of entity, or entities, to strike at. The target is randomly chosen if there are multiple entities matching the given name."
	renderamt(integer) : "Brightness (1 - 255)" : 100
	rendercolor(color255) : "Beam Color (R G B)" : "255 255 255"
	width(float) : "Width of Beam" : 2 : "The width of the laser beam, in pixels."
	NoiseAmplitude(integer) : "Amount of noise (0-255)" : 0 : "The amount of noise in the beam. 0 is a perfectly straight beam."
	texture(sprite) : "Sprite Name" : "sprites/laserbeam.spr" : "The material used to draw the laser beam."
	EndSprite(sprite) : "End Sprite" : "" : "If specified, this sprite will be drawn at the end of the laser beam."
	TextureScroll(integer) : "Texture Scroll Rate (0-100)" : 35 : "Rate at which the beam texture should scroll along the beam."
	framestart(integer) : "Starting Frame" : 0 : "The frame to start the beam texture on."
	damage(string) : "Damage / second" : "100" : "How much damage this laser does. per second. to things it hits."
	dissolvetype(choices) : "Dissolve Type" : "None" =
	[
		-1 : "None"
		0 : "Energy"
		1 : "Heavy electrical"
		2 : "Light electrical"
	]
	spawnflags(flags) = 
	[
		1 : "Start On" : 0
		16: "StartSparks" : 0
		32: "EndSparks" : 0
		64: "Decal End" : 0
	]

	// Inputs
	input TurnOn(void) : "Turns the laser on."
	input TurnOff(void) : "Turns the laser off."
	input Toggle(void) : "Toggles the laser between on and off."
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = env_message : "An entity that draws a text message from titles.txt on player's HUDs."
[
	message(string) : "Message" : : "The message to display.  Must be a valid entry in titles.txt."
	spawnflags(flags) =
	[
		1: "Play Once" : 0
		2: "All Clients" : 0
	]
	messagesound(sound) : "Sound Effect" : "" : "When the message is shown, this sound effect will be played, originating from this entity."
	messagevolume(string) : "Volume 0-10" : "10" : "Volume of the sound effect."
	messageattenuation(Choices) : "Sound Radius" : 0 =
	[
		0 : "Small Radius"
		1 : "Medium Radius"
		2 : "Large  Radius"
		3 : "Play Everywhere"
	]
	
	// Inputs
	input ShowMessage(void) : "Shows the message and plays the sound."
	
	// Outputs
	output OnShowMessage(void) : "Fired when the message is activated."
]

@PointClass base(Targetname, Parentname, Angles) = env_muzzleflash : "Muzzle Flash" 
[
	parentattachment(string) : "Parent Attachment" : "" : "The name of an attachment on the parent to hierarchically attach to."
	scale(float) : "Scale" : "1" : "Size of the muzzle flash."
	
	input Fire(void) : "Fires the effect once."
]

@PointClass base( Targetname, Parentname, Angles ) size( -8 -8 -8, 8 8 8 ) = env_particlescript : 
	"An entity that has special animation events that can be fired by a model with an animation inside its .qc designed for use by this entity."
[
	model(studio) : "Script Model" : "models/Ambient_citadel_paths.mdl" : "Model to use for animation sequences."

	// Inputs
	input SetSequence(string) : "Sets the script model's sequence."
]

@PointClass base(Targetname, Parentname) sphere(radius) iconsprite("editor/env_physexplosion.vmt") = env_physexplosion : "An entity that creates an explosion at its origin. If the no-damage spawnflag is set, the explosion won't be visible, but will apply force to any physics objects within its radius."
[
	magnitude(string) : "Magnitude" : "100" : "Amount of physics force applied by the explosion."
	radius(string) : "Clamp Radius (0 = auto)" : "0" : "If specified, the radius in which the explosion damages entities. If unspecified, the radius will be based on the magnitude."
	targetentityname(target_destination) : "Limit to Entity" : "" : "If specified, the explosion will only affect the matching entity."
	spawnflags(flags) =
	[
		1 : "No Damage - Only Force" : 1
	]

	// Inputs
	input Explode(void) : "Trigger the explosion."
]

@PointClass base(Targetname, Parentname) line(255 255 255, targetname, directionentityname) iconsprite("editor/env_physexplosion.vmt") = env_physimpact : "An entity that will cause a physics impact on another entity."
[
	angles(string) : "Pitch Yaw Roll (Y Z X)" : "0 0 0" : "Direction to project the impact."
	magnitude(integer) : "Magnitude" : 100 : "Strength of the impact."
	distance(integer) : "Distance" : 0 : "How far to project the impact (if 0 uses a default value)."
	directionentityname(target_destination) : "Point to Entity" : "" : "If set, 'Distance' and Angle settings are ignored and the direction and distance to the target entity will be used."

	spawnflags(flags) =
	[
		1: "No fall-off" : 0
		2: "Infinite Length" : 0
		4: "Ignore Mass" : 0
	]

	input Impact(void) : "Trigger the impact"
]

@PointClass sphere(radius) iconsprite("editor/env_shake.vmt") base(Targetname, Parentname) = env_shake : "An entity to control screen shake on players." 
[
	spawnflags(flags) =
	[
		1: "Global shake" : 0
		4: "Shake air" : 0
		8: "Shake physics" : 0
		16: "Shake ropes" : 0
	]

	amplitude(float) : "Amplitude (0-16)" : "4" : "The amount of noise in the screen shake. Should be a range between 0 and 16."
	radius(float) : "Effect Radius" : "500" : "The radius around this entity in which to affect players."
	duration(float) : "Duration (seconds)" : "1" : "The length of time for which to shake the player's screens."
	frequency(float) : "Frequency" : "2.5" : "The frequency used to apply the screen shake. Should be a value between 0 and 255, where 0.1 = jerk, and 255.0 = rumble."

	// Inputs
	input Amplitude(string) : "Set the amplitude (0-16)"
	input Frequency(string) : "Set the frequence. Should be a value between 0 and 255, where 0.1 = jerk, and 255.0 = rumble."
	input StartShake(void) : "Start the shake."
	input StopShake(void) : "Stop the shake."
]

@BaseClass base(Targetname, Parentname) = gibshooterbase
[
	angles(string) : "Gib Direction (Pitch Yaw Roll)" : "0 0 0" : "The direction the gibs will fly."
	m_iGibs(integer) : "Number of Gibs" : 3 : "Total number of gibs to shoot each time I'm activated."
	delay(string) : "Delay between shots" : "0" : "Delay (in seconds) between shooting each gib. If 0, all gibs shoot at once."
	gibangles(string) : "Gib Angles (Pitch Yaw Roll)" : "0 0 0" : "The orientation of the spawned gibs."
	m_flVelocity(integer) : "Gib Velocity" : 200 : "Speed of the fired gibs"
	m_flVariance(string) : "Course Variance" : "0.15" : "How much variance in the direction gibs are fired."
	m_flGibLife(string) : "Gib Life" : "4" : "Time in seconds for gibs to live +/- 5%"

	spawnflags(Flags) = 
	[
		1 : "Repeatable" 	: 0
	]

	// Inputs
	input Shoot(void) : "Force the gibshooter to create and shoot a gib."
]

@PointClass base(gibshooterbase) iconsprite("editor/gibshooter.vmt") = gibshooter : 
	"An entity that shoots out gibs. Style of body part depends on language type."
[
]

@PointClass base(gibshooterbase, RenderFields) iconsprite("editor/env_shooter.vmt") = env_shooter : "An entity that shoots models, or sprites, out of its origin."
[
	shootmodel(studio) : "Model" : "" : "Thing to shoot out.  Can be a .mdl or a .vmt."
	shootsounds(choices) :"Material Sound" : -1 =
	[
		-1: "None"
		0: "Glass"
		1: "Wood"
		2: "Metal"
		3: "Flesh"
		4: "Concrete"  
	]
	simulation(choices) :"Simulate" : 0 =
	[
		0: "Point"
		1: "Physics"
		2: "Ragdoll"
	]

	skin(integer) : "Gib Skin" : 0 : "Some models have multiple versions of their textures, called skins. Set this to a number other than 0 to use that skin on all gibs produced by this shooter."

	spawnflags(flags) =
	[
		2 : "On fire" : 0
		4 : "strict remove after lifetime" : 0
	]
]

@PointClass base(gibshooterbase, RenderFields) iconsprite("editor/env_shooter.vmt") = env_rotorshooter : "An entity that creates gibs when it's within the influence of a helicopter's rotor wash."
[
	shootmodel(studio) : "Model" : "" : "Thing to shoot out.  Can be a .mdl or a .vmt."
	shootsounds(choices) : "Material Sound" : -1 =
	[
		-1: "None"
		0: "Glass"
		1: "Wood"
		2: "Metal"
		3: "Flesh"
		4: "Concrete"  
	]
	simulation(choices) : "Simulate" : 0 : "Type of physical stimulation to use for the gib." =
	[
		0: "Point"
		1: "Physics"
		2: "Ragdoll"
	]

	skin(integer) : "Gib Skin" : 0 : "Some models have multiple versions of their textures, called skins. Set this to a number other than 0 to use that skin on all gibs produced by this shooter."

	spawnflags(flags) =
	[
		2 : "On fire" : 0
	]

	rotortime(float) : "Time Under Rotor" : "1" : "The average time it has to be under the rotor before it shoots a gib."
	rotortimevariance(float) : "Time variance" : "0.3" : "The random amount to vary the time it has to be under the rotor before it shoots a gib."
]

@PointClass base(Targetname, Parentname, Angles, RenderFields) color(255 255 255) = env_smokestack : "An entity that spits out a constant stream of smoke, or any other sprite/material--thus it is more accurately a Particle Emitter than a Smokestack. You can place up to two env_particlelight entities near the smoke stack to add extra light to its particles. Pitch/Yaw/Roll define Forward; sprites are launched Upward (Up is determined relative to Forward) with a force determined by Speed, and are randomly pushed horizontally with a force no greater than SpreadSpeed."
[
	InitialState(choices) : "Initial State" : 0 = 
	[
		0 : "Off"
		1 : "On"
	]

	BaseSpread(integer)		: "Particle Spread" : 20 : "Particles will be no farther than this from the env_smokestack when spawned."
	SpreadSpeed(integer)	: "Horizontal Speed (SpreadSpeed)" : 15 : "Particles are pushed in a random horizontal direction at this speed (units/second)."
	Speed(integer)			: "Speed" : 30 : "The speed at which particles move upward after they've spawned.  Pitch/Yaw/Roll define the forward direction, not the upward direction."
	StartSize(integer)		: "Particle Start Size"	: 20 : "Size of the particles when they're first emitted."
	EndSize(integer)		: "Particle End Size" : 30 : "Size of the particles at the point they fade out completely."
	Rate(integer)			: "Emission Rate" : 20 : "Rate at which to emit particles (i.e., particles to emit per second)."
	JetLength(integer)		: "Length of Particle Trail" : 180 : "Length of the smokestack. Lifetime of the particles is defined as speed divided by length."
	WindAngle(integer)		: "Wind X/Y Angle" : 0 : "This specifies the wind direction. It is an angle in the XY plane, regardless of the smokestack's Pitch/Yaw/Roll. WindSpeed specifies the strength of the wind."
	WindSpeed(integer)		: "Wind Speed" : 0 : "The strength of the wind.  0 disables, naturally."
	SmokeMaterial(string)	: "Particle Material" : "particle/SmokeStack.vmt" : "Material to emit in the form of a flying sprite or particle."
	twist(integer)			: "Twist" : 0 : "If nonzero, regardless of any other properties, all emitted particles will attempt to spin around the env_smokestack at this rate, in degrees per second."
	
	rendercolor(color255)	: "Base Color (R G B)" : "255 255 255" : "The color of the smoke particles before particle lighting is applied."

	renderamt(integer)		: "Translucency" : 255 : "The alpha translucency of the smoke particles.  0 is transparent; 255 is the material's normal opacity."
	
	// Inputs
	input TurnOn(void)		: "Turn on the smokestack."
	input TurnOff(void)		: "Turn off the smokestack."
	input Toggle(void)		: "Toggle the smokestack between on and off state."
	input JetLength(integer): "Set the length of the particle trail."
	input Rate(integer)		: "Set the rate at which to emit smoke particles (particles per second)."
	input Speed(integer)	: "Set the speed at which the smoke particles move after they're spawned."
	input SpreadSpeed(integer) : "Set the amount of random spread in the velocity of the smoke particles after they're spawned."
]

@PointClass base(Targetname, Parentname) color(200 50 0) size(-8 -8 -8, 8 8 8) = env_smoketrail : "An entity that creates a smoke trail." 
[
	opacity(float) : "Sprite Opacity" : "0.75" : "Opacity of the sprites (range from 0 - 1)."
	spawnrate(float) : "Spawn Rate" : "20" : "Number of particles to emit each second."
	lifetime(float) : "Particle Life Time" : "5.0" : "Number of seconds until each particle dies."
	startcolor(color255) : "Start Color" : "192 192 192" : "Starting color of the emitted particles."
	endcolor(color255)	 : "End Color"	: "160 160 160"	: "Ending color of the emitted particles."
	emittime(float) : "Emitter Life Time" : "0" : "Number of seconds until the env_smoketrail stops emitting particles. 0 means never stop emitting particles."
	minspeed(float) : "Minimum Random Speed" : "10" : "Minimum randomly-directed speed to use for emitted particles."
	maxspeed(float) : "Maximum Random Speed" : "20" : "Maximum randomly-directed speed to use for emitted particles."
	mindirectedspeed(float) : "Minimum Directed Speed" : "0" : "Minimum speed along the env_smoketrail's forward direction (x axis) to use for emitted particles."
	maxdirectedspeed(float) : "Maximum Directed Speed" : "0" : "Maximum speed along the env_smoketrail's forward direction (x axis) to use for emitted particles."
	startsize(float) : "Starting particle size" : "15" : "Starting particle size."
	endsize(float) : "Ending particle size" : "50" : "Ending particle size."
	spawnradius(float) : "Spawn radius" : "15" : "Distance from env_smoketrail at which particles are emitted."

	firesprite(sprite) : "Fire Sprite" : "sprites/firetrail.spr"
	smokesprite(sprite) : "Smoke Puff" : "sprites/whitepuff.spr"
]

@PointClass base(Targetname,Parentname) iconsprite("editor/env_soundscape.vmt") = env_soundscape_proxy : "An entity that acts like a soundscape but gets all of its sound parameters from another env_soundscape entity."
[
	MainSoundscapeName(target_destination) : "Soundscape Entity" : "" : "The soundscape to get all sound parameters from."
]

@PointClass base(Targetname,Parentname,EnableDisable) sphere(radius) iconsprite("editor/env_soundscape.vmt") line(255 255 255, targetname, position0) line(255 255 255, targetname, position1) line(255 255 255, targetname, position2) line(255 255 255, targetname, position3) line(255 255 255, targetname, position4) line(255 255 255, targetname, position5) line(255 255 255, targetname, position6) line(255 255 255, targetname, position7) = env_soundscape :
	"An entity to control sound in an area. The active soundscape at any time is the last one that had line-of-sight to the player, and was within the radius.  Please see http://developer.valvesoftware.com/wiki/List_of_HL2_Soundscapes for a list of soundscapes."
[
	radius(integer) : "Radius" : 128 : "If set to -1, then the player can hear the soundscape as long as he can see it (regardless of distance to it)."
	soundscape(string) : "Soundscape" : "Nothing" : "The name of the soundscape to use. Corresponds to an entry in the soundscapes*.txt file in the hl2/scripts directory."
	position0(target_destination) : "Sound Position 0" : "" : "A sound position that will be referenced inside the soundscape text file. Usually used to position a set of sounds within the world."
	position1(target_destination) : "Sound Position 1" : "" : "A sound position that will be referenced inside the soundscape text file. Usually used to position a set of sounds within the world."
	position2(target_destination) : "Sound Position 2" : "" : "A sound position that will be referenced inside the soundscape text file. Usually used to position a set of sounds within the world."
	position3(target_destination) : "Sound Position 3" : "" : "A sound position that will be referenced inside the soundscape text file. Usually used to position a set of sounds within the world."
	position4(target_destination) : "Sound Position 4" : "" : "A sound position that will be referenced inside the soundscape text file. Usually used to position a set of sounds within the world."
	position5(target_destination) : "Sound Position 5" : "" : "A sound position that will be referenced inside the soundscape text file. Usually used to position a set of sounds within the world."
	position6(target_destination) : "Sound Position 6" : "" : "A sound position that will be referenced inside the soundscape text file. Usually used to position a set of sounds within the world."
	position7(target_destination) : "Sound Position 7" : "" : "A sound position that will be referenced inside the soundscape text file. Usually used to position a set of sounds within the world."

	// Inputs
	input Enable(void) : "Enable the soundscape."
	input Disabled(void) : "Disable the soundscape."
	input ToggleEnabled(void) : "Toggle the soundscape enabled state."

	output OnPlay(void) : "Fired when this soundscape becomes the active one."
]

@PointClass base(env_soundscape) sphere() iconsprite("editor/env_soundscape.vmt") = env_soundscape_triggerable : "An entity that works like env_soundscape except that it works in conjunction with trigger_soundscape to determine when a player hears it."
[
]

@PointClass base(Targetname, ResponseContext) iconsprite("editor/ambient_generic.vmt") = env_speaker : "Announcement Speaker"
[
	delaymin(string) : "Min Delay Between Announcements" : "15"
	delaymax(string) : "Max Delay Between Announcements" : "135"
	spawnflags(flags) =
	[
		1: "Start Silent" : 0
		2: "Play Everywhere" : 0
	]
	rulescript(string) : "Context rule script" : "" : "Script file containing rules for playing appropriate sounds."
	concept(string) : "Concept name" : "" : "High level concept name used as primary search key."

	input TurnOn(void) : "Turn on the random announcements."
	input TurnOff(void) : "Turn off the random announcements."
	input Toggle(void) : "Toggle the random announcements off and on."
]

@PointClass base(Targetname, Parentname, Angles) iconsprite("editor/env_spark.vmt") = env_spark : "An entity used to create sparks at its origin." 
[
	MaxDelay(string) : "Max Delay" : "0" : "The longest delay between sparks (in seconds)."
	Magnitude(choices) : "Magnitude" : 1 : "The size of the sparks." =
	[
		1 : "Small"
		2 : "Medium"
		5 : "Large"
		8 : "Huge"
	]

	TrailLength(choices) : "Spark Trail Length" : 1 =
	[
		1 : "Short"
		2 : "Medium"
		3 : "Long"
	]

	spawnflags(flags) =
	[
		64: "Start ON" : 0
		128: "Glow" : 0
		256: "Silent" : 0
		512: "Directional" : 0
	]
	
	// Inputs
	input StartSpark(void) : "Start the spark effect."
	input StopSpark(void) : "Stop the spark effect."
	input ToggleSpark(void) : "Toggle the on/off state of the spark effect."
	input SparkOnce(void) : "Spark once."
]

@PointClass base(Targetname, Angles) = spark_shower : "A shower of sparks.  This entity must be used in conjunction with a point_template because the spark shower only occurs when the entity is spawned.  Sparks fly in the direction of Angles." []

@PointClass base(Targetname, Parentname, RenderFields,DXLevelChoice) size(-2 -2 -2, 2 2 2) sprite() color(20 140 20) sphere(GlowProxySize) = env_sprite : "An entity that controls the drawing of a sprite in the world." 
[
	framerate(float) : "Framerate" : "10.0" : "Rate at which the sprite should animate, if at all."
	model(sprite) : "Sprite Name" : "sprites/glow01.spr" : "Material of the sprite to be drawn."
	scale(float) : "Scale" : "1" : "Scale multiplier of the sprite."
	spawnflags(flags) =
	[
		1: "Start on" : 0
		2: "Play Once" : 0
	]

	GlowProxySize(float) : "Size of Glow Proxy Geometry." : "2.0" : "Size of the glow to be rendered for visibility testing. Must be larger than the distance from the sprite center to empty space.  So if this glow is inside geometry (like a light bulb), set this value to be bigger than the bulb's radius. Any time a sphere of this radius would be visible (poking through any nearby geometry), the glow will be rendered."
	
	// Inputs
	input Alpha(integer) : "Set the sprite's alpha (0 - 255)."
	input Color(color255) : "Set the sprite's color (R G B)."
	input SetScale(float) : "Set the sprite's scale (0 - 8.0)."
	input HideSprite(void) : "Hide the sprite. Won't be drawn until the 'ShowSprite' input is received."
	input ShowSprite(void) : "Show the sprite."
	input ToggleSprite(void) : "Toggle the sprite between hidden and shown."
]

@PointClass size( -4 -4 -4, 4 4 4 ) base(Targetname) = env_starfield : "Starfield effect - puts some star particles in front of the player's face that fly toward him."
[
	input TurnOn(void) : "Turn on"
	input TurnOff(void) : "Turn off"
	input SetDensity(float) : "Set the density of the starfield. It's a multiplier, so 1 is the default."
]

@PointClass base(Targetname, Parentname, Angles) studioprop("models/editor/spot_cone.mdl") color(255 255 255) = env_steam : "An entity used to create a jet of steam."
[
	spawnflags(flags) =
	[
		1 : "Emissive" : 0
	]

	InitialState(choices) : "Initial State" : 0 = 
	[
		0 : "Off"
		1 : "On"
	]

	//Type of particle to spew out
	type(choices) : "Particle Type" : 0 =
	[
		0 : "Normal"
		1 : "Heat Wave"
	]

	SpreadSpeed(integer) : "Spread Speed" : 15 : "The amount of random spread in the particle's velocity after they spawn."
	Speed(integer) : "Speed" : 120 : "The default speed at which the particles move after they spawn."
	StartSize(integer) : "Particle start size"	: 10 : "The initial size of the particles after they spawn."
	EndSize(integer) : "Particle end size" : 25 : "The size of the particles at the point at which they are removed."
	Rate(integer) : "Emission rate" : 26 : "The rate of particle emission. i.e. particles per second."
	rendercolor(color255) : "Color (R G B)" : "255 255 255"
	JetLength(integer) : "Length of steam jet" : 80 : "The length of the jet determines the lifetime of each particle."
	renderamt(integer) : "Translucency" : 255
	
	// Inputs
	input TurnOn(void) : "Turns the steam jet on."
	input TurnOff(void) : "Turns the steam jet off."
	input Toggle(void) : "Toggles the steam jet between on and off."
	input JetLength(integer) : "Sets the length of steam jet."
	input Rate(integer) : "Sets the particle emission rate in particles per second."
	input Speed(integer) : "Sets the default speed of the particles in units per second."
	input SpreadSpeed(integer) : "Sets the spread speed in units per second."
]

@PointClass base(Targetname, Parentname, Angles) size(-4 -4 -4, 4 4 4) color(0 180 0) sphere(startradius) sphere(goalradius) = env_terrainmorph : 
	"Pulls nearby displacement vertices in the direction defined by this entity's Pitch/Yaw/Roll when it receives a BeginMorph input. "+
	"This is an EFFECT ONLY--the clipping hulls on the brush are not changed.  An imaginary sphere is drawn around this entity with a radius "+
	"defined by Start Radius, and all points within this sphere are pulled; as the effect reaches the end of its duration, this imaginary "+
	"sphere's radius changes to Goal Radius, allowing more or fewer points to be pulled.  Vertices are pulled to this entity's position, "+
	"unless the Displacement Fraction is not 1 (it's a scalar for the distance pulled)."
[
	startradius(integer) : "Start Radius" : 500 : "Radius of the effect when morphing begins.  Only this value is used if the effect is flagged to occur instantly."
	goalradius(integer) : "Goal Radius" : 100 : "Radius of the effect at the end of morphing."

	duration(integer) : "Duration" : 3 : "The morph will take place over this period of time (seconds) unless the Instant flag is set."

	fraction(integer) : "Displacement Fraction" : 1 : "Scalar for the distance pulled (see documentation).  If >1, clipping will occur in the "+
		"form of plateaus, because displacement vertices cannot be pulled further than this entity."

	// Inputs
	input BeginMorph(void) : "Begin Morph"

	spawnflags(flags) =
	[
		1: "Instant" : 0 
	]
]

@PointClass base(Targetname) = env_tonemap_controller : "This entity controls the HDR tonemapping for the player, which means absolutely nothing to most people.  Essentially, a mapper uses this if he wants to modify how wide a player's pupils are open, to create special lighting effects.  Usually, modifying this is not necessary."
[
	input SetTonemapScale(float) : "Set the player's tonemap scale--the openness of his pupils.  Parameter should be a value between 0 and 2, where 0 is the eyes fully closed, 1 is the unchanged autoexposure (default), and 2 is the eye fully wide open.  Fades back to 1 via the current TonemapRate."
	input BlendTonemapScale(string) : "SetTonemapScale performed over a length of time.  Parameter should be a value between 0 and 2 followed by a length of time in seconds.  This appears jumpy, as if the TonemapRate fights the transition."
	input SetTonemapRate(string) : "Set the TonemapRate, the rate at which the player's eyes adjust to light.  Higher values denote faster adjustments."
	input SetAutoExposureMin(string) : "Set AutoExposureMin, the minimum amount that the player's pupils are allowed to be open when automatically adjusting.  Overrides AutoExposureMax if Min>Max."
	input SetAutoExposureMax(string) : "Set AutoExposureMax, the maximum amount that the player's pupils are allowed to be open when automatically adjusting."
	input SetBloomScale(string) : "Set BloomScale, a scalar for the size of light bloom effects."
	input UseDefaultAutoExposure(void) : "Use the default AutoExposureMin and AutoExposureMax values."
	input UseDefaultBloomScale(void) : "Use the default BloomScale."
]

@PointClass base(Targetname) iconsprite("editor/env_wind.vmt") = env_wind : "An entity to control wind in the map. Unfinished."
[
	gustsound(sound) : "Gust Sound Filename" : "" : "Sound to be played to simulate the gusting wind."
	minwind(integer) : "Min normal speed" : 20 : "Minimum speed of the wind while idling."
	maxwind(integer) : "Max normal speed" : 50 : "Maximum speed of the wind while idling."

	mingust(integer) : "Min gust speed" : 100 : "Minimum speed of wind gusts."
	maxgust(integer) : "Max gust speed" : 250 : "Maximum speed of wind gusts."

	mingustdelay(integer) : "Min gust delay" : 10 : "Minimum time delay between random gusts."
	maxgustdelay(integer) : "Max gust delay" : 20 : "Maximum time delay between random gusts."

	gustdirchange(integer) : "Max gust dir change (degrees)" : 20 : "Maximum amount that the wind's direction changes due to a gust."
]

//-------------------------------------------------------------------------
//
// Ladders
//
//-------------------------------------------------------------------------

@PointClass base(Targetname, Parentname, Origin) sweptplayerhull() = func_useableladder : "A Half-Life 2 ladder. Handles player auto mount/unmount. See also 'func_ladderendpoint', used to specify the two endpoints of a ladder, and 'info_ladder_dismount', used to specify ladder auto-dismount points."
[
	spawnflags(flags) =
	[
		1: "Fake Ladder" : 0
	]

	point0(vector) : "Start" : : "Ladder end point."
	point1(vector) : "End" : : "Ladder end point."

	StartDisabled(choices) : "Start Disabled" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]

	// Inputs
	input Enable(void) : "Enable this ladder."
	input Disable(void) : "Disable this ladder."

	output OnPlayerGotOnLadder(void) : "Fired whenever a player gets on this ladder."
	output OnPlayerGotOffLadder(void) : "Fired whenever a player gets off this ladder."
]

@PointClass base(Targetname, Parentname, Angles) size( -16 -16 0, 16 16 72 ) color(127 127 127) = func_ladderendpoint : "An entity used to specify the endpoints of a ladder. To be valid, a full sized player hull traced between the start and end points must not be obstructed at level activation time. The angle determines in which direction the player leaves the ladder if the player presses the +jump button."
[
	target(target_destination) : "Other" : : "A ladder goes between any two func_ladderendpoints pointing at each other."
]

@PointClass base(Targetname, Parentname) size( -16 -16 0, 16 16 4 ) color(255 128 255)= info_ladder_dismount : "An entity to handle endpoints for multiple ladders that are too close to each other."
[
	target(target_destination) : "LadderName" : : "If multiple ladders are near multiple endpoints, use this to stop them from interfering with each other."
]

//-------------------------------------------------------------------------
//
// Game Entities
//
//-------------------------------------------------------------------------
@PointClass base(Targetname) iconsprite("editor/game_end.vmt") = game_end : "An entity that ends a multiplayer game." 
[
//	master(string) : "Master (Obsolete)" : : "Legacy support: The name of a master entity. If the master hasn't been activated, this entity will not activate."
	input EndGame(void) : "End the multiplayer game."
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) color(160 160 255) = game_player_equip : "An entity that drops weapons on the activating player.  Also determines the weapons with which players spawn."
[
	spawnflags(flags) =
	[
		1 : "Use Only (don't equip on spawn)" : 1
	]
//	master(string) : "Team Master (Obsolete)" : : "Legacy support: The name of a master entity. If the master hasn't been activated, this entity will not activate."

	item_suit(choices) : "Give HEV suit" : "" =
	[
		"" : "No"
		1 : "Yes"
	]

	weapon_crowbar(choices) : "Give crowbar" : "" =
	[
		"" : "No"
		1 : "Yes"
	]

	weapon_stunstick(choices) : "Give stunstick" : "" =
	[
		"" : "No"
		1 : "Yes"
	]

	weapon_physcannon(choices) : "Give physcannon (gravity gun)" : "" =
	[
		"" : "No"
		1 : "Yes"
	]

	weapon_pistol(choices) : "Give pistol (pistol)" : "" =
	[
		"" : "No"
		1 : "Yes"
	]

	weapon_357(choices) : "Give 357 (revolver)" : "" =
	[
		"" : "No"
		1 : "Yes"
	]

	weapon_alyxgun(choices) : "Give alyxgun (Alyx's pistol)" : "" =
	[
		"" : "No"
		1 : "Yes"
	]

	weapon_smg1(choices) : "Give smg1 (SMG)" : "" =
	[
		"" : "No"
		1 : "Yes"
	]

	weapon_shotgun(choices) : "Give shotgun (shotgun)" : "" =
	[
		"" : "No"
		1 : "Yes"
	]

	weapon_annabelle(choices) : "Give annabelle (Grigori's shotgun)" : "" =
	[
		"" : "No"
		1 : "Yes"
	]

	weapon_ar2(choices) : "Give ar2 (Combine AR)" : "" =
	[
		"" : "No"
		1 : "Yes"
	]

	weapon_rpg(choices) : "Give rpg (RPG launcher)" : "" =
	[
		"" : "No"
		1 : "Yes"
	]

	weapon_crossbow(choices) : "Give crossbow (crossbow)" : "" =
	[
		"" : "No"
		1 : "Yes"
	]

	weapon_frag(choices) : "Give frag (grenade)" : "" =
	[
		"" : "No"
		1 : "Yes"
	]

	weapon_slam(choices) : "Give slam (HL2DM)" : "" =
	[
		"" : "No"
		1 : "Yes"
	]

	weapon_bugbait(choices) : "Give bugbait (pheropods)" : "" =
	[
		"" : "No"
		1 : "Yes"
	]

	item_ammo_pistol(choices) : "Give pistol ammo pack" : "" =
	[
		"" : "No"
		1 : "Yes"
	]

	item_ammo_pistol_large(choices) : "Give pistol ammo box" : "" =
	[
		"" : "No"
		1 : "Yes"
	]

	item_ammo_357(choices) : "Give 357 ammo pack" : "" =
	[
		"" : "No"
		1 : "Yes"
	]

	item_ammo_357_large(choices) : "Give 357 ammo box" : "" =
	[
		"" : "No"
		1 : "Yes"
	]

	item_ammo_smg1(choices) : "Give SMG ammo pack" : "" =
	[
		"" : "No"
		1 : "Yes"
	]

	item_ammo_smg1_grenade(choices) : "Give SMG grenade" : "" =
	[
		"" : "No"
		1 : "Yes"
	]

	item_ammo_smg1_large(choices) : "Give SMG ammo box" : "" =
	[
		"" : "No"
		1 : "Yes"
	]

	item_box_buckshot(choices) : "Give shotgun ammo box" : "" =
	[
		"" : "No"
		1 : "Yes"
	]

	item_ammo_ar2(choices) : "Give Combine AR ammo pack" : "" =
	[
		"" : "No"
		1 : "Yes"
	]

	item_ammo_ar2_altfire(choices) : "Give Combine AR energy ball" : "" =
	[
		"" : "No"
		1 : "Yes"
	]

	item_ammo_ar2_large(choices) : "Give Combine AR ammo box" : "" =
	[
		"" : "No"
		1 : "Yes"
	]

	item_rpg_round(choices) : "Give RPG round" : "" =
	[
		"" : "No"
		1 : "Yes"
	]

	item_ammo_crossbow(choices) : "Give crossbow bolts" : "" =
	[
		"" : "No"
		1 : "Yes"
	]

	item_healthvial(choices) : "Give health vial" : "" =
	[
		"" : "No"
		1 : "Yes"
	]

	item_healthkit(choices) : "Give health kit" : "" =
	[
		"" : "No"
		1 : "Yes"
	]

	item_battery(choices) : "Give battery" : "" =
	[
		"" : "No"
		1 : "Yes"
	]

	input Use(void) : "Causes this entity to give the activator weapons."
]

@PointClass base(Targetname) iconsprite("editor/game_text.vmt") = game_text : "An entity that displays text on player's screens." 
[
	spawnflags(flags) =
	[
		1: "All Players" : 0
	]

	message(string) : "Message Text" : "" : "Message to display onscreen."
	x(string) : "X (0 - 1.0 = left to right) (-1 centers)" : "-1" : "Horizontal position on the player's screens to draw the text. The value should be between 0 and 1, where 0 is the far left of the screen and 1 is the far right. -1 centers the text."
	y(string) : "Y (0 - 1.0 = top to bottom) (-1 centers)" : "-1" : "Vertical position on the player's screens to draw the text. The value should be between 0 and 1, where 0 is the top of the screen and 1 is the bottom. -1 centers the text."
	effect(Choices) : "Text Effect" : 0 =
	[
		0 : "Fade In/Out"
		2 : "Scan Out"
	]
	color(color255) : "Color1" : "100 100 100"
	color2(color255) : "Color2" : "240 110 0"
	fadein(string) : "Fade in Time (or character scan time)" : "1.5" : "The time it should take for the text to fully fade in."
	fadeout(string) : "Fade Out Time" : "0.5" : "The time it should take for the text to fade out, after the hold time has expired."
	holdtime(string) : "Hold Time" : "1.2" : "The time the text should stay onscreen, after fading in, before it begins to fade out."
	fxtime(string) : "Scan time (scan effect only)" : "0.25" : "If the 'Text Effect' is set to Scan Out, this is the time it should take to scan out all the letters in the text."
	channel(choices) : "Text Channel" : 1 : "You can have up to four individual game_text messages onscreen at once, stored in channels. Select which channel this text should be placed in, which will overwrite any active message already in that channel." =
	[
		1 : "Channel 1"
		2 : "Channel 2"
		3 : "Channel 3" 
		4 : "Channel 4"
	]
//	master(string) : "Master" : : "Legacy support: The name of a master entity. If the master hasn't been activated, this entity will not activate."

	// Inputs
	input Display(void) : "Display the message text."
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = game_ui : "An entity used to override player input when the player's looking at it."
[
	spawnflags(flags) =
	[
		32 : "Freeze Player" : 1
		64 : "Hide Weapon" : 1
		128 : "+Use Deactivates" : 1
		256 : "Jump Deactivates" : 1
	]
	
	FieldOfView(float) : "FieldOfView" : "-1.0" : "The amount of tolerance in the view checking when determining whether the player's input is still under control. 1.0 = straight ahead, 0.0 = +/- 90 degrees, -1.0 = all directions. If the player isn't within the tolerance, the player regains control."

	// Inputs
	input Deactivate(void) : "Return Player Control."
	input Activate(void) : "Take Player Control."

	// Outputs
	output PlayerOn(void) : "Fired whenever this entity starts controlling the player's input."
	output PlayerOff(void) : "Fired whenever this entity stops controlling the player's input."
	output PressedMoveLeft(void) : "Fired whenever the player presses the moveleft key."
	output PressedMoveRight(void) : "Fired whenever the player presses the moveright key."
	output PressedForward(void) : "Fired whenever the player presses the forward key."
	output PressedBack(void) : "Fired whenever the player presses the backward key."
	output PressedAttack(void) : "Fired whenever the player presses the attack key."
	output PressedAttack2(void) : "Fired whenever the player presses the secondary attack key."

	output XAxis(string) : "An output that fires whenever the X axis of the player's input changes. i.e. -1 when the player has moveleft key down, 1 when the player has moveright key down, and 0 if neither."
	output YAxis(string) : "An output that fires whenever the Y axis of the player's input changes. i.e. -1 when the player has backward key down, 1 when the player has forward key down, and 0 if neither."
	output AttackAxis(string) : "An output that fires whenever the state of the player's attack key changes. i.e. 1 when the player has the attack key down, 0 otherwise."
	output Attack2Axis(string) : "An output that fires whenever the state of the player's secondary attack key changes. i.e. 1 when the player has the secondary attack key down, 0 otherwise."
]

@PointClass base(Targetname) = game_weapon_manager : "An entity used to limit the number of a particular weapon type in the world. Useful in places where NPCs are spawning rapidly, dying, and dropping weapons.  Tends to crash multiplayer games." 
[
	weaponname(string) : "Weapon Classname" : "" : "Classname of the weapon type to limit."
	maxpieces(integer) : "Max Allowed in Level" : 0 : "The maximum amount of the specified weapon type allowed in the world."
]

@SolidClass base(Targetname, Parentname) = game_zone_player : "An entity used to count the number of players within a zone."
[
	// Inputs
	input CountPlayersInZone(void) : "Count the number of players in the zone, and fire the corresponding outputs."

	// Outputs
	output OnPlayerInZone(void) : "Fired whenever a count finds a player inside the zone, with the player as the activator."
	output OnPlayerOutZone(void) : "Fired whenever a count finds a player outside the zone, with the player as the activator."
	output PlayersInCount(integer) : "Fired after a count, and contains the number of players found inside the zone."
	output PlayersOutCount(integer) : "Fired after a count, and contains the number of players found outside the zone."
]

//
// Decals
//

@BaseClass base(Targetname) = BaseDecal
[
	texture(decal) : "Texture" : ""

	input Activate(void) : "Force the decal to apply itself to the world."
]


@PointClass base(BaseDecal) decal() studioprop("models/editor/axis_helper.mdl") = infodecal : "An entity that places a decal on the world. If the decal has no target name, it will immediately apply itself when the level is loaded. If it has a name specified, it won't apply until it receives the 'Activate' input."
[
	LowPriority(choices) : "Low Priority (can be replaced)" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]
]

// A decal to be applied to a prop or the world using specified origin and orientation and radius, uses an orientation angle and a radius to determine
//  ray to cast for projection
@PointClass base(BaseDecal,Angles) decal() studioprop("models/editor/axis_helper.mdl") = info_projecteddecal : "An entity that projects a decal onto the world (or props). If the decal has no target name, it will immediately apply itself when the level is loaded. If it has a name specified, it won't apply until it receives the 'Activate' input."
[
	Distance(float) : "Distance" : 64 : "Distance from the origin to project the decal."
]

//
// Info
//

@PointClass base(NameBase) size(-8 -8 -8, 8 8 8) = info_null : "An entity that's immediately removed on spawning. Useful as a spotlight target."
[
]

@PointClass size(-4 -4 -4, 4 4 4) color(0 180 0) = info_intermission : "An entity that defines an intermission spot where dead players will float until they respawn."
[
	target(target_destination) : "Entity to look at" : : "Name of entity that dead players will face while in intermission at this spot."
]

@PointClass base(Targetname) iconsprite("editor/info_landmark") = info_landmark : "An entity that acts as a landmark for transitions to another level. There should be a corresponding info_landmark entity in the next map. Entities will be transitioned to the next level relative to the info_landmark entities."
[
]

@PointClass base(NameBase) iconsprite("editor/info_lighting.vmt") = info_lighting : 
	"An entity that can be used to change the lighting origin of a prop_static. Set the prop_static's Lighting Origin to point at this entity to "+
	"make the prop_static light as if it was at the info_lighting's origin. Good for prop_static entities that are embedded in world geometry (like rocks/windows/etc)."
[
]

@PointClass = info_no_dynamic_shadow : "Use this entity to mark surfaces that shouldn't receive dynamic shadows."
[
	sides(sidelist) : "Brush faces"
]

@PointClass size(-8 -8 -8, 8 8 8) overlay() = info_overlay : "An entity that places an overlay on the world." 
[
	material(material) : "Material"
	sides(sidelist) : "Brush faces"
	RenderOrder(integer) : "Render Order" : 0 : "Higher values render after lower values. This value can be 0-3."
	StartU(float) : "U Start" : "0.0"
	EndU(float) : "U End" : "1.0"
	StartV(float) : "V Start" : "0.0"
	EndV(float) : "V End" : "1.0"
	BasisOrigin(Vector) readonly : "Overlay Basis Origin(Read-Only)"
	BasisU(Vector) readonly : "Overlay Basis U(Read-Only)"
	BasisV(Vector) readonly : "Overlay Basis V(Read-Only)"
	BasisNormal(Vector) readonly : "Overlay Basis Normal(Read-Only)"
	uv0(vector) readonly : "Overlay Point 1(Read-Only)"
	uv1(vector) readonly : "Overlay Point 2(Read-Only)"
	uv2(vector) readonly : "Overlay Point 3(Read-Only)"
	uv3(vector) readonly : "Overlay Point 4(Read-Only)"
]

@PointClass base(Targetname, Parentname, Angles) iconsprite("editor/info_target.vmt") = info_target : "An entity that does nothing. Very useful as a target for other entities, such as env_laser and trigger_teleport."
[
	input DispatchEffect(string) : "Dispatch an effect from this point. Not yet implemented."
]

@PointClass base(Targetname, Parentname, Angles, EnableDisable) iconsprite("editor/info_target.vmt") sphere(radius) = phys_ragdollmagnet : 
	"An entity that acts like a magnet for ragdolls. Useful for crafting exaggerated ragdoll behavior (i.e. guys falling over rails on death). If the "+
	"Bar Magnet spawnflag is set, the magnet works like it was a cylindrical magnet i.e. it attracts ragdolls to the nearest point on a line."
[
	axis(vecline) : "Bar Magnet Axis"
	radius(float) : "Effective Radius" : "512" : "Radius in which ragdolls are affected around this entity's origin."
	force(float) : "Force" : "5000" : "Magnetic force to apply to ragdolls within the radius. Expressed as kilograms per unit per second. So a force of 1000 will add 10 units/second to a 100kg man. It will add 100 units per second to a 10kg headcrab."

	target(string) : "Entity to affect" : "" : "If specified, the phys_ragdollmagnet will only affect the target entity."

	spawnflags( Flags ) =
	[
		2 : "Bar Magnet (use axis helper)" : 0
	]
]

//-------------------------------------------------------------------------
//
// Nodes and Hints
//
//-------------------------------------------------------------------------

@BaseClass = Node 
[
	nodeid(integer) readonly : "Node ID"
]

@BaseClass base(Node) = HintNode 
[
	hinttype(choices) : "Hint" : 0 = 
	[
		  0 : "None"

		  2: "World: Window"
		 12: "World: Act Busy Hint"
		 13: "World: Visually Interesting"
		 14:"World: Visually Interesting (Don't aim at)"
		 15:"World: Inhibit Combine Mines within 15 feet"

		100: "Crouch Cover Medium"
		101: "Crouch Cover Low"
		102: "Waste Scanner Spawn"
		103: "Entrance / Exit Pinch"
		105: "Enemy Disadvantage Point"
		106: "Health Kit"

		400: "Antlion: Burrow Point"
		401: "Antlion: Thumper Flee Point"

		450: "Headcrab: Burrow Point"

		500: "Roller: Patrol Point"
		501: "Roller: Cleanup Spot"

		700: "Crow: Fly to point"
		701: "Crow: Perch point"

		900: "Follower: Wait point"
		901: "Override jump permission"
		902: "Player squad transition point"
		903: "NPC exit point"
		904: "Strider node"

		1000: "HL1 World: Machinery"
		1001: "HL1 World: Blinking Light"
		1002: "HL1 World: Human Blood"
		1003: "HL1 World: Alien Blood"
	]

	hintactivity(string) : "Hint Activity" : "" : "Activity associated with this hint node. Various parts of the NPC AI play this activity at times. i.e. Actbusy nodes will play this activity when an NPC acts busy on the node."

	nodeFOV(choices) : "Node FOV" : 180 : "Imagine this node requires that an NPC be in the node's field of view in order to use this hint." =
	[
		180 : "180 Degrees"
		360 : "360 Degrees"
	]

	// Does not inherit from EnableDisable, as node itself will
	// use that.  This is enabling/disabling of the hint only
	StartHintDisabled(choices) : "Start Hint Disabled" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]

	Group(string) : "Hint Group" : "" : "If specified, gives the hint a specific group name.  Useful for hint nodes that need to be logically grouped together. NPCs may also refuse to use hint nodes that don't match their hint group."

    TargetNode(node_dest) : "Target node" : -1 : "The node ID of an associated target node, if any."

	IgnoreFacing(choices) : "Ignore Facing" : 2 : "Don't pay attention to the facing of the node. May not apply to a given hint type." =
	[
		0 : "No"
		1 : "Yes"
		2 : "Default"
	]

	MinimumState(choices) : "Minimum State" : 1 : "Require an NPC have a minimum state to use the hint." =
	[
		1 : "Idle"
		2 : "Alert"
		3 : "Combat"
	]

	MaximumState(choices) : "Maximum State" : 3 : "Require an NPC have a maximum state to use the hint." =
	[
		1 : "Idle"
		2 : "Alert"
		3 : "Combat"
	]

	// Inputs
	input EnableHint(void) : "Enable hint."
	input DisableHint(void) : "Disable hint."
]

@PointClass base(Targetname, Angles, HintNode) studioprop("models/editor/node_hint.mdl") color(255 255 255) = info_hint :
	"A hint that is not used for navigation. They don't go into the nodegraph, nor do they fall to the ground. Use these to provide " +
	"some spatial context for NPCs, such as 'look here if you can't find the player' or 'throw rocks at this spot'."
[
]

@PointClass base(Targetname, Node) studioprop("models/editor/ground_node.mdl") color(232 219 8) = info_node :
	"A navigation node for ground moving NPCs. Navigation nodes are baked into the nodegraph so that NPCs can move " +
	"to them. Ground nodes fall to the ground when they spawn."
[
	spawnflags(Flags) = 
	[
		512 : "Keep editor position (don't fall to ground)" : 0
	]
]

@PointClass base(Targetname, Node) studioprop("models/editor/air_node.mdl") color(232 171 8)  = info_node_air :
	"A navigation node for flying NPCs. Air navigation nodes are baked into the nodegraph so that NPCs can move " +
	"to them. Air nodes do not fall to the ground when they spawn."
[
	nodeheight(integer)	: "NodeHeight"  : 0
]

@PointClass base(Targetname, Angles, HintNode) studioprop("models/editor/air_node_hint.mdl") color(232 171 8) line(255 255 255, nodeid, TargetNode) = info_node_air_hint :
	"A navigation node for flying NPCs that includes some context information for NPCs that are interested in it. The hint might " +
	"indicate a window that could be looked into, or an item of interest that could be commented on. Many hint nodes are NPC-specific, " +
	"so it's helpful to use naming conventions like 'Crow: Fly to point' in the hint choices list. The angles of a hint node indicate what direction " +
	"the NPC should face to perform the hint behavior."

[
	nodeheight(integer)	: "NodeHeight"  : 0
]

@PointClass base(Targetname, Angles, HintNode) studioprop("models/editor/climb_node.mdl") color(153 215 103) = info_node_climb : "A climb-node for AI navigation. Only usable by NPCs that can climb."
[
]

@PointClass base(Targetname, Angles, HintNode) studioprop("models/editor/ground_node_hint.mdl") color(232 219 8) = info_node_hint :
	"A navigation node for ground moving NPCs that includes some context information for NPCs that are interested in it. The hint might " +
	"indicate a window that could be looked out of, or an item of interest that could be commented on. Many hint nodes are NPC-specific, " +
	"so it's helpful to use naming conventions like 'Crow: Fly to point' in the hint choices list. The angles of a hint node indicate what direction " +
	"the NPC should face to perform the hint behavior.\n\n" +
	"It's important to understand the distinction between scripts, such as scripted_sequence and scripted_schedule, and info_hint entities. Scripts summon " +
	"NPCs to specific cue points to play their parts, while hints provide context information to the AI that they use to perform their " +
	"behaviors. Hints require code support in the NPC, while scripts are generic and may require only animations to play. Use a hint if the behavior is driven " +
	"by the AI, use a script if the behavior is driven by the map."

[
	output OnNPCStartedUsing(string) : "Fired when an NPC has reached this node and started using it. Passes along the NPC."
	output OnNPCStoppedUsing(string) : "Fired when an NPC has stopped using this node. Passes along the NPC."
]

@PointClass base(Targetname) color(220 180 0) size(-8 -8 -8, 8 8 8) line(255 255 255, nodeid, StartNode, nodeid, EndNode) = info_node_link :
	"A dynamic connection between two navigation nodes. You specify the node IDs of the start and end nodes, and then you can use entity I/O " +
	"to turn on and off the connection. This could be used to create or destroy a connection in the nodegraph because of some event in your map " +
	"(a bridge being created/destroyed, etc)."
[
    StartNode(node_dest) : "Start node ID" : : "The node ID of one end of the node connection."
    EndNode(node_dest) : "End node ID" : : "The node ID of one end of the node connection."
	initialstate(choices) : "Initial State" : 1 =
	[
		0 : "Off"
		1 : "On"
	]
	AllowUse(string) : "Allow Pass When Off" : : "Entity or class to allow passage even when node is off"

	spawnflags( Flags ) =
	[
		1 : "Force human connect" : 0
		2 : "Force small_centered connect" : 0
		4 : "Force wide_human connect" : 0
		8 : "Force tiny connect" : 0
		16 : "Force wide_short connect" : 0
		32 : "Force medium connect" : 0
		64 : "Force tiny_centered connect" : 0
		128 : "Force large connect" : 0
		256 : "Force large_centered connect" : 0
	]


	input TurnOn(void) : "Turn the link on."
	input TurnOff(void) : "Turn the link off."
]

@PointClass wirebox(mins, maxs) base(Targetname) = info_node_link_controller :
	"An entity that controls all connections between nodes that intersect the controller's volume. "+
	"This allows for mass enabling/disabling of all node connections through a volume."
[
	mins(vector) : "Mins" : "-8 -32 -36"
	maxs(vector) : "Maxs" : "8 32 36"

	initialstate(choices) : "Initial State" : 1 =
	[
		0 : "Off"
		1 : "On"
	]
	AllowUse(string) : "Allow Pass When Off" : : "Entity or class to allow passage even when node is off"

	input TurnOn(void) : "Turn the link on."
	input TurnOff(void) : "Turn the link off."
]

//-------------------------------------------------------------------------
//
// Lights
//
//-------------------------------------------------------------------------

@BaseClass base(Targetname) color(180 10 180) = Light
[
	_light(color255) : "Brightness" : "255 255 255 200" : "Brightness for players who aren't using HDR.  Expressed as four numbers:  'Red Green Blue Intensity'."
	_lightHDR(color255) : "HDR Brightness" : "-1 -1 -1 1" : "If HDR is implemented into the mod, brightness for players who have HDR enabled.  Expressed as four numbers:  'Red Green Blue Intensity'."
    style(Choices) : "Appearance" : 0 =
	[
		0 : "Normal"
		10: "Fluorescent flicker"
		2 : "Slow, strong pulse"
		11: "Slow pulse, noblack"
		5 : "Gentle pulse"
		1 : "Flicker A"
		6 : "Flicker B"
		3 : "Candle A"
		7 : "Candle B"
		8 : "Candle C"
		4 : "Fast strobe"
		9 : "Slow strobe"
	]
	pattern(string) : "Custom Appearance" : "" : "Set a custom pattern of light brightness for this light. Pattern format is a string of characters, where 'a' is total darkness, 'z' fully bright. i.e. 'aaggnnttzz' would be a steppy fade in from dark to light."
	_constant_attn(string)	: "Constant" : "0" : "Determines brightness of the light at a certain distance.  Higher Constants dim the light near the entity."
	_linear_attn(string)	: "Linear" : "0" : "Determines brightness of the light at a certain distance.  Higher Linears dim the light at all distances."
	_quadratic_attn(string)	: "Quadratic" : "1" : "Determines brightness of the light at a certain distance.  Higher Quadratics dim the light far from the entity."
	_fifty_percent_distance(float) : "Half (50%) Falloff" : : "Distance from this light at which it is reduced to 50% brightness.  Ignores Quadratic, Linear, and Constant if used."
	_zero_percent_distance(float) : "Complete (0%) Falloff" : : "Distance from this light at which it cannot light objects anymore ((1/256)% brightness).  Requires Half Falloff."

	// Inputs
	input TurnOn(void) : "Turn the light on."
	input TurnOff(void) : "The the light off."
	input Toggle(void) : "Toggle the light's current state."
	input SetPattern(string) : "Set a custom pattern of light brightness for this light. Pattern format is a string of characters, where 'a' is total darkness, 'z' fully bright. i.e. 'aaggnnttzz' would be a steppy fade in from dark to light."
	input FadeToPattern(string) : "Fades from first value in old pattern, to first value in the new given pattern. Pattern format is a string of characters, where 'a' is total darkness, 'z' fully bright. i.e. 'aaggnnttzz' would be a steppy fade in from dark to light."
]

@PointClass light() sphere(_distance) sphere(_fifty_percent_distance) sphere(_zero_percent_distance) iconsprite("editor/light.vmt") base(Light) = light : "An invisible light source."
[
	spawnflags(Flags) =
	[
		1 : "Initially dark" : 0
	]
	_distance(integer) : "Maximum cast distance for models" : 0 : "Models will not be lit by this light if they are further than this distance from it."
]

@PointClass base(NameBase, Parentname, Angles, Light) iconsprite("editor/light.vmt") sphere(_distance) sphere(_fifty_percent_distance) sphere(_zero_percent_distance) lightcone() size(-4 -4 -4, 4 4 4) = light_dynamic : "An invisible lightsource that can change in some way over time." 
[
	target(target_destination) : "Entity to point at" : : "The name of an entity in the map that the dynamic light will point at."
	_light(color255) : "Light color" : "255 255 255 200" : "Light color, expressed as four numbers:  'Red Green Blue Intensity'."
	brightness(integer) : "Light brightness override" : 1 : "Used to override the light's brightness.  1-20 make the light brighter.  21-30 or so cut a black circle out of the middle of the light.  Less than 0 make the light dimmer.  Too high or too low may stop the light from lighting up brushes."
	_inner_cone(integer) : "Inner (bright) angle" : 30
	_cone(integer) : "Outer (fading) angle" : 45
	distance(float) : "Maximum distance" : 512 : "This is the distance that light is allowed to cast, in units.  Unlike other lights, you can't set this property to 0 to get an infinite light."
	spotlight_radius(float) : "Spotlight end radius" : 80 : "This is the radius of the light, in units, at the object that it is hitting."
	spawnflags(Flags) = 
	[ 
		1 : "No world light" : 0 
		2 : "No model light" : 0
		4 : "Add Displacement Alpha" : 0
		8 : "Subtract Displacement Alpha" : 0
	]

	// Inputs
	input Color(color255) : "Set the light's render color (R G B)."
	input brightness(integer) : "Set the light brightness."
	input distance(float) : "Set the maximum light distance."
	input _inner_cone(integer) : "Set the inner (bright) angle."
	input _cone(integer) : "Set the outer (fading) angle."
	input spotlight_radius(float) : "Set the radius of the spotlight at the end point."
	input style(integer) : "Change the lightstyle (see Appearance field for possible values)."
]

@PointClass base(Targetname, Angles) iconsprite("editor/light_env.vmt") = light_environment : "Sets the color and angle of the light from the sun and sky."+
	"Brightness is emitted from the general direction of the light_environment entity; Ambient is emitted in all directions and is primarily used to color shadowed areas."
[
	pitch(integer) : "Pitch" : 0 : "Used by Hammer to fix up light angles so VRAD doesn't get angry.  Expressed in degrees; -90 is straight down."
	_light(color255) : "Brightness (light from light_env)" : "255 255 255 200" : "Brightness for players who aren't using HDR.  Expressed as four numbers:  'Red Green Blue Intensity'."
	_ambient(color255) : "Ambient (light from sky)" : "255 255 255 20" : "Ambient light level (shadow colour) for players who aren't using HDR.  Expressed as four numbers:  'Red Green Blue Intensity'."
	_lightHDR(color255) : "HDR Brightness" : "-1 -1 -1 1" : "If HDR is implemented into the mod, brightness for players who have HDR enabled.  Expressed as four numbers:  'Red Green Blue Intensity'.  -1 -1 -1 1 means use the normal Brightness."
	_ambientHDR(color255) : "HDR Ambient" : "-1 -1 -1 1" : "If HDR is implemented into the mod, ambient light level for players who have HDR enabled.  Expressed as four numbers:  'Red Green Blue Intensity'.  -1 -1 -1 1 means use the normal Ambient."
	style(Choices) : "Appearance" : 0 =
	[
		0 : "Normal"
		10: "Fluorescent flicker"
		2 : "Slow, strong pulse"
		11: "Slow pulse, noblack"
		5 : "Gentle pulse"
		1 : "Flicker A"
		6 : "Flicker B"
		3 : "Candle A"
		7 : "Candle B"
		8 : "Candle C"
		4 : "Fast strobe"
		9 : "Slow strobe"
	]
	pattern(string) : "Custom Appearance" : "" : "Set a custom pattern of light brightness for this light. Pattern format is a string of characters, where 'a' is total darkness, 'z' fully bright. i.e. 'aaggnnttzz' would be a steppy fade in from dark to light."

	input TurnOn(void) : "Turn the light on."
	input TurnOff(void) : "The the light off."
	input Toggle(void) : "Toggle the light's current state."
	input SetPattern(string) : "Set a custom pattern of light brightness for this light. Pattern format is a string of characters, where 'a' is total darkness, 'z' fully bright. i.e. 'aaggnnttzz' would be a steppy fade in from dark to light."
	input FadeToPattern(string) : "Fades from first value in old pattern, to first value in the new given pattern. Pattern format is a string of characters, where 'a' is total darkness, 'z' fully bright. i.e. 'aaggnnttzz' would be a steppy fade in from dark to light."
]

@PointClass base(Light, Angles) sphere(_distance) sphere(_fifty_percent_distance) sphere(_zero_percent_distance) lightprop("models/editor/spot.mdl") lightcone() = light_spot : "Invisible light source that emits a directional cone of light.  For a visible spotlight effect, try point_spotlight."
[
	pitch(integer) : "Pitch" : : "Used by Hammer to fix up light angles so VRAD doesn't get angry.  Expressed in degrees; -90 is straight down."
	target(target_destination) : "Entity to point at" : : "The name of an entity in the map that the spotlight will point at. This will override the spotlight's angles."
	_inner_cone(integer) : "Inner (bright) angle" : 30
	_cone(integer) : "Outer (fading) angle" : 45
	_distance(integer) : "Maximum cast distance for models" : 0 : "Models will not be lit by this light if they are further than this distance from it."
	_exponent(float) : "Exponent" : "0.0" : "An exponent used to modify the light falloff for points between the inner and outer angles.  0 and 1 are ignored."
	spawnflags(Flags) =
	[
		1 : "Initially dark" : 0
	]
]

//
// Point effects
//

@PointClass base(Parentname, Angles) size(-2 -2 -2, 2 2 2) = point_enable_motion_fixup : "An entity used to move a motion-disabled prop when it enables motion. Parent this entity to the prop, and when the prop has its motion enabled, it will immediately teleport to the origin of this entity."
[
]

@PointClass base(Targetname, Parentname) size(-8 -8 -8, 8 8 8) sphere(radius) = point_message : "An entity that displays a text message in the world, at its origin.  Only works in single-player HL2."
[
	spawnflags(flags) =
	[
		1: "Start Disabled" : 0
	]

	message(string) : "Entity Message"
	radius(integer) : "Show message radius" : 128 : "Distance the player must be within to see this message."
	developeronly(choices) : "Developer Only?" : 0 : "If set, this message will only be visible when developer mode is on." =
	[
		0 : "No"
		1 : "Yes"
	]

	// Inputs
	input Enable(void) : "Start displaying the message text, if the player is within the message radius."
	input Disable(void) : "Stop displaying the message text."
]

@PointClass base(Targetname, Parentname, Angles) studioprop("models/editor/axis_helper.mdl") = point_spotlight : "An entity to draw a spotlight. Will draw a beam when the player views it side on, and a halo when it's facing towards the player. Unless the 'No Dynamic Light' spawnflag is checked, it will also create a dynamic light wherever the end of the spotlight rests."
[
	spawnflags(Flags) = 
	[
		1 :  "Start On"		: 1
		2 :  "No Dynamic Light"	: 0
	]

	spotlightlength(integer)	: "Spotlight Length"	: 500 : "Length of the spotlight beam."
	spotlightwidth(integer)		: "Spotlight Width"	: 50 : "Width of the spotlight beam."
	rendercolor(color255)		: "Color (R G B)"	: "255 255 255"
	
	// Inputs
	input LightOn(void)			: "Turn the spotlight on."
	input LightOff(void)		: "Turn the spotlight off"
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) sphere(m_flRadius) = point_tesla : "An entity that creates tesla lightning arcs around its origin."
[
	m_SourceEntityName(string)	: "Source Entity" : "" : "If specified, tesla lightning will originate from the specified entity. Otherwise, they originate from this entity."
	m_SoundName(sound)			: "Sound Name" : "DoSpark" : "Sound to be played whenever lightning is created."

	texture(sprite) : "Sprite Name" : "sprites/physbeam.vmt" : "Material to use for the tesla lightning beams."

	m_Color(color255)			: "Color"				: "255 255 255"

	m_flRadius(integer)			: "Radius"				: 200 : "Radius around the origin to find a point to strike with a tesla lightning beam."

	beamcount_min(integer)		: "Min # of Beams"	: 6 : "Minimum number of tesla lightning beams to create when creating an arc."
	beamcount_max(integer)		: "Max # of Beams"	: 8 : "Maximum number of tesla lightning beams to create when creating an arc."
	
	thick_min(string)	: "Min Beam Width"	: "4" : "Minimum width of the tesla lightning beams."
	thick_max(string)	: "Max Beam Width"	: "5" : "Maximum width of the tesla lightning beams."
	
	lifetime_min(string)	: "Min Time Visible"	: "0.3" : "Minimum lifetime of the tesla lightning beams."
	lifetime_max(string)	: "Max Time Visible"	: "0.3" : "Maximum lifetime of the tesla lightning beams."
	
	interval_min(string)	: "Min Time Between Arcs":"0.5" : "Minimum time delay between random arcing."
	interval_max(string)	: "Max Time Between Arcs":"2" : "Maximum time delay between random arcing."

	// Inputs
	input TurnOn(void)		: "Turn emitter on." 
	input TurnOff(void)		: "Turn emitter off."
	input DoSpark(void)		: "Force a single arc."
]

@BaseClass base(Targetname) = ExecCmd
[
	input Command(string) : "Command to execute."
]

@PointClass base(ExecCmd) size(-8 -8 -8, 8 8 8) = point_clientcommand : "An entity that issues commands to the client console, as if it was typed in by the player (if activator is a player, or the local player in single player).  Send it the Command input with the commands to execute as override parameters."
[
]

@PointClass base(ExecCmd) size(-8 -8 -8, 8 8 8) = point_servercommand : "An entity that issues commands to the server console.  See also point_clientcommand."
[
]

//-------------------------------------------------------------------------
// Shadow control
//-------------------------------------------------------------------------

@PointClass base(Targetname) iconsprite("editor/shadow_control.vmt") = shadow_control : "An entity to control the shadows in the map."
[
	angles(string) : "Pitch Yaw Roll (Y Z X)" : "80 30 0" : "This is the shadow direction. Pitch is rotation around the Y axis, yaw is the rotation around the Z axis, and roll is the rotation around the X axis."

	color(color255) : "Shadow Color" : "128 128 128" : "This is the color of the shadows."
	distance(float) : "Maximum Distance" : 75 : "This is the maximum distance the shadow is allowed to cast, in units."

	// Inputs
	input color(color255) : "Set the shadow color."
	input direction(vector) : "Set the shadow direction."
	input SetDistance(float) : "Set the maximum shadow cast distance."
	input SetAngles(string) : "Set the shadow direction."
]

//-------------------------------------------------------------------------
//
// Ropes and Cables
//
//-------------------------------------------------------------------------
@BaseClass base(DXLevelChoice) = RopeKeyFrame
[
	NextKey(target_destination) : "Next KeyFrame" : : "Name of the next keyframe along this keyframe path."

	Slack(integer) : "Slack" : 25 : "How much extra length the rope has (by default it has the length between its two endpoints in the editor)."

	Type(choices) : "Type" : 0 =
	[
		0  : "Rope"
		1  : "Semi-rigid"
		2  : "Rigid"
	]

	Subdiv(integer) : "Subdivision" : 2 : "Number of subdivisions between each rope segment. Maximum value is 8. Higher values make smoother ropes, but are slower to render."

	Barbed(choices) : "Barbed" : 0 : "Test effect that makes the rope look sharper and more barbed." =
	[
		0 : "No"
		1 : "Yes"
	] 
	
	Width(string) : "Width (1-64)" : "2" : "Width of the rope."

	TextureScale(string) : "Texture Scale" : "1" : "This changes the texture resolution. The default resolution is 4 pixels per unit. Larger values stretch the texture and smaller values scrunch it up."
	
	Collide(choices) : "Collide with world" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]

	Dangling(choices) : "Start Dangling" : 0 : "When set to Yes, the rope starts out detached from its target endpoint." =
	[
		0 : "No"
		1 : "Yes"
	] 

	Breakable(choices) : "Breakable" : 0 : "When set to yes, the rope can be detached from either endpoint when shot." =
	[
		0 : "No"
		1 : "Yes"
	] 

	RopeMaterial(material) : "Rope Material" : "cable/cable.vmt" : "The material to use when rendering the rope."

	// Inputs
	input SetScrollSpeed(float) : "Set the speed at which the texture scrolls."
	input SetForce(string)		: "Apply a force instantaneously to the rope. The parameter should be a vector containing the force to be applied (X Y Z)."
	input Break(void)			: "Break the rope, if it's marked to do so."
]

@BaseClass = KeyFrame
[
	MoveSpeed(integer) readonly : "Rope Hack" : 64 // Hack to get Hammer to render ropes
]

@KeyFrameClass base(Targetname, Parentname, KeyFrame, RopeKeyFrame) studioprop("models/editor/axis_helper.mdl") keyframe() = keyframe_rope : 
	"A node entity that marks a point in a rope. The first node in the rope should be a move_rope, followed by 1 or more keyframe_ropes."
[
]

@MoveClass base(Targetname, Parentname, KeyFrame, RopeKeyFrame) studioprop("models/editor/axis_helper.mdl") animator() = move_rope : 
	"The first node in set of nodes that are used to place ropes in the world. It should connect to 1 or more keyframe_rope entities."
[
	PositionInterpolator(choices) : "Position Interpolator" : 2 : "Controls the way Hammer determines the points between two keyframes.  Numbers higher than 2 will crash the editor!" =
	[
		0 : "Linear"
		1 : "Catmull-Rom Spline"
		2 : "Rope (based on slack setting)"
	]
]


//-------------------------------------------------------------------------
//
// Buttons
//
//-------------------------------------------------------------------------
@BaseClass = Button
[
	// Inputs
	input Lock(void) : "Lock the button, preventing it from functioning."
	input Unlock(void) : "Unlock the button, allowing it to function."
	input Press(void) : "Activate the button, as if it was pressed."

	// Outputs
	output OnDamaged(void) : "Fired when the button is damaged."
	output OnPressed(void) : "Fired when the button is pressed."
	output OnUseLocked(void) : "Fired when the button is used while locked."
	output OnIn(void) : "Fired when the button reaches the in/pressed position."
	output OnOut(void) : "Fired when the button reaches the out/released position."
]


@SolidClass base(Targetname, Parentname, Origin, RenderFields, Button) = func_button : "A brush entity that's designed to be used for a player-useable button. When used by the player, it moves to a pressed position."
[
	movedir(angle) : "Move Direction (Pitch Yaw Roll)" : "0 0 0" : "Specifies the direction of motion to move when the button is used."
	speed(integer) : "Speed" : 5 : "The speed that the button moves, in units per second."
	health(integer) : "Health (Obsolete)" : 0 : "Legacy method of specifying whether or not the button can be shot to activate it. Use the 'Damage Activates' spawnflag instead."
	lip(integer) : "Lip" : 0 : "The amount, in units, of the button to leave sticking out of the wall it recedes into when pressed. Negative values make the button recede even further into the wall."
//	master(string) : "Master (Obsolete)" : : "Legacy support: The name of a master entity. If the master hasn't been activated, this button cannot be pressed."
	sounds(choices) : "Sounds" : 0 = 
	[
		0: "None (Silent)"
		1: "Big zap & Warmup"
		2: "Access Denied"
		3: "Access Granted"
		4: "Quick Combolock"
		5: "Power Deadbolt 1"
		6: "Power Deadbolt 2"
		7: "Plunger"
		8: "Small zap"
		9: "Keycard Sound"
		10: "Buzz"
		11: "Buzz Off"
		12: "latch locked"
		13: "Latch Unlocked"
		14: "Lightswitch"
		15: "small bleek"
		16: "small deny"
		17: "small doop"
		18: "small tech deny"
		19: "click and combine screen fuzz"
		20: "roomy beep"
		21: "lever or wheel: turn + move sqeek"
		22: "lever or wheel: latch + release gas"
		23: "lever or wheel: ratchet + sqeek"
		24: "lever or wheel: large ratchet"
		25: "lever or wheel: clanky + gas release"
		26: "lever or wheel: latch + large metal thud"
		27: "lever or wheel: smaller ratchet"
		28: "lever or wheel: smaller lever move"
		31: "shock buzz"
		32: "clickbeep"
		33: "tech blip"
		34: "clickbeepbeep open"
		35: "small high blip"
		36: "small tech fuzz blip"
		37: "small click bleep (change to lightswitch)"
		40: "combine door lock - locked"
		41: "combine blip growl"
		42: "combine squick growl"
		43: "combine whine purr"
		44: "combine click talk"
		45: "combine click growl fizz"
		46: "combine click fizz (deny)"
		47: "combine click talker"
	]	
	wait(integer) : "Delay Before Reset (-1 stay)" : 3 : "Amount of time, in seconds, after the button has been pressed before it returns to the starting position. Once it has returned, it can be used again. If the value is set to -1, the button never returns."
	spawnflags(flags) =
	[
		1: "Don't move" : 0
		32: "Toggle" : 0
		256: "Touch Activates": 0
		512: "Damage Activates": 0
		1024: "Use Activates" : 1
		2048: "Starts locked" : 0
		4096: "Sparks" : 0
	]
	locked_sound(choices) : "Locked Sound" : 0 : "Sound played when the player tries to use the button, and fails because it's locked." = 
	[
		0: "None"
		2: "Access Denied"
		8: "Small zap"
		10: "Buzz"
		11: "Buzz Off"
		12: "Latch Locked"
	]
	unlocked_sound(choices) : "Unlocked Sound" : 0 : "Sound played when the button is unlocked." = 
	[
		0: "None"
		1: "Big zap & Warmup"
		3: "Access Granted"
		4: "Quick Combolock"
		5: "Power Deadbolt 1"
		6: "Power Deadbolt 2"
		7: "Plunger"
		8: "Small zap"
		9: "Keycard Sound"
		10: "Buzz"
		13: "Latch Unlocked"
		14: "Lightswitch"
	]
	locked_sentence(choices) : "Locked Sentence" : 0 : "A sentence played when the player tries to use the button, and fails because it's locked." = 
	[
		0: "None"
		1: "Gen. Access Denied"
		2: "Security Lockout"
		3: "Blast Door"
		4: "Fire Door"
		5: "Chemical Door"
		6: "Radiation Door"
		7: "Gen. Containment"
		8: "Maintenance Door"
		9: "Broken Shut Door"
	]
	unlocked_sentence(choices) : "Unlocked Sentence" : 0 : "A sentence played when the button is unlocked." = 
	[
		0: "None"
		1: "Gen. Access Granted"
		2: "Security Disengaged"
		3: "Blast Door"
		4: "Fire Door"
		5: "Chemical Door"
		6: "Radiation Door"
		7: "Gen. Containment"
		8: "Maintenance area"
	]

]

@SolidClass base(Targetname, Parentname, Origin, Angles, Global, Button) = func_rot_button : "A brush entity that's designed to be used for a rotating player-useable button. When used by the player, it rotates to a pressed position."
[
//	master(string) : "Master (Obsolete)" : : "Legacy support: The name of a master entity. If the master hasn't been activated, this button cannot be used."
	speed(integer) : "Speed" : 50 : "The speed that the button rotates, in degrees per second."
	health(integer) : "Health (Obsolete)" : 0 : "Legacy method of specifying whether or not the button can be shot to activate it. Use the 'Damage Activates' spawnflag instead."
	sounds(choices) : "Sounds" : 21 = 
	[
		0: "None (Silent)"
		21: "Squeaky"
		22: "Squeaky Pneumatic"
		23: "Ratchet Groan"
		24: "Clean Ratchet"
		25: "Gas Clunk"
	]
	wait(integer) : "Delay Before Reset (-1 stay)" : 3 : "Amount of time, in seconds, after the button has been pressed before it returns to the starting position. Once it has returned, it can be used again. If the value is set to -1, the button never returns."
	distance(integer) : "Distance (deg)" : 90 : "The amount, in degrees, that the button should rotate when it's pressed."
	// TODO: move spawnflags into Button base class?
	spawnflags(flags) =
	[
		1 : "Not solid" : 0
		2 : "Reverse Dir" : 0
		32: "Toggle" : 0
		64: "X Axis" : 0
		128: "Y Axis" : 0
		256: "Touch Activates": 0
		512: "Damage Activates": 0
		1024: "Use Activates": 0
		2048: "Starts locked" : 0
	]

]


@SolidClass base(Targetname, Parentname, Origin, Angles, RenderFields) = momentary_rot_button : "A brush entity that's designed to be used for rotating wheels, where the player can rotate them to arbitrary positions before stopping."
[
	speed(integer) : "Speed (deg/sec)" : 50 : "The amount, in degrees, that the wheel turns per second."
//	master(string) : "Master (Obsolete)" : : "Legacy support: The name of a master entity. If the master hasn't been activated, this button cannot be used."
	sounds(choices) : "Sounds" : 0 = 
	[
		0: "None"
		1: "Big zap & Warmup"
		2: "Access Denied"
		3: "Access Granted"
		4: "Quick Combolock"
		5: "Power Deadbolt 1"
		6: "Power Deadbolt 2"
		7: "Plunger"
		8: "Small zap"
		9: "Keycard Sound"
		21: "Squeaky"
		22: "Squeaky Pneumatic"
		23: "Ratchet Groan"
		24: "Clean Ratchet"
		25: "Gas Clunk"
	]
	distance(integer) : "Distance" : 90 : "The maximum amount, in degrees, that the wheel is allowed to rotate."
	returnspeed(integer) : "Auto-return speed" : 0 : "If the 'Toggle' spawnflag is not set, the speed at which the wheel auto-returns when left alone, in degrees per second."
	spawnflags(flags) =
	[
		1: "Not Solid" : 1
		32: "Toggle (Disable Auto Return)" : 1
		64: "X Axis" : 0
		128: "Y Axis" : 0
		1024: "Use Activates" : 1
		2048: "Starts locked" : 0
		8192: "Jiggle when used while locked" : 0
	]

	startposition(float) : "Start Position" : 0 : "Postion when spawned. The value is a range between 0.0 and 1.0, where 0 is the unrotated position and 1 is the rotated position + 'Distance'."
	startdirection(choices) : "Start Direction" : "Forward" =
	[
		-1	: "Forward"		 // Reverses upon USE, so are
		1	: "Backward"	 // reversed here.
	]
	solidbsp(choices) : "Solid BSP" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]	

	// Inputs
	input Lock(void) : "Lock the button, preventing it from functioning."
	input Unlock(void) : "Unlock the button, allowing it to function."
	input SetPosition(string) : "Move to a position. The parameter must be a value between 0 and 1, where 0 is the unrotated position and 1 is the rotated position + 'Distance'."
	input SetPositionImmediately(string) : "Immediately teleport to a position. The parameter must be a value between 0 and 1, where 0 is the unrotated position and 1 is the rotated position + 'Distance'."

	// Outputs
	output Position(integer)   : "Fired whenever the button moves. The output is the position of button from 0 to 1, where 0 is the unrotated position and 1 is the rotated position + 'Distance'."
	output OnPressed(integer)  : "Fired when the button is first pressed."
	output OnUnpressed(integer): "Fired when the button is first released from being pressed."
	output OnFullyClosed(void) : "Fired when the button has reached position 1, the rotated position + 'Distance'."
	output OnFullyOpen(void)   : "Fired when the button has reached position 0, the unrotated starting position."
	output OnReachedPosition(void)   : "Fired whenever the button reaches a goal position: i.e. when it becomes open, becomes closed, or reaches the point specified by a 'SetPosition' input."
]


//-------------------------------------------------------------------------
//
// Doors
//
//-------------------------------------------------------------------------
@BaseClass base(Targetname, Parentname, RenderFields, Global) = Door
[
	speed(integer) : "Speed" : 100 : "The speed at which the door moves."
//	master(string) : "Master (Obsolete)" : : "Legacy support: The name of a master entity. If the master hasn't been activated, this button cannot be used."
	noise1(sound) : "Start Sound" : : "Sound to play when the door starts moving."
	noise2(sound) : "Stop Sound" : : "Sound to play when the door stops moving."
	wait(integer) : "Delay Before Reset (-1 stay)" : 4 : "Amount of time, in seconds, after the door has opened before it closes. Once it has closed, it can be used again. If the value is set to -1, the door never closes itself."
	lip(integer) : "Lip" : 0 : "The amount, in units, of the button to leave sticking out of the wall it recedes into when pressed. Negative values make the button recede even further into the wall."
	dmg(integer) : "Blocking Damage" : 0 : "Amount of damage done to entities that block the movement of this door, per frame."
	forceclosed(choices) : "Force Closed" : 0 : "If set, this door will close no matter what. Useful for doors that have to close even if the player tries to block them with objects." =
	[
		0 : "No"
		1 : "Yes"
	]

	message(string) : "Message If Triggered"		// NEEDHELP: Looks like this was removed
	health(integer) : "Health (shoot open)" : 0		// NEEDHELP: Looks like this was removed

	locked_sound(sound) : "Locked Sound" : : "Sound played when the player tries to use the door, and fails because it's locked."
	unlocked_sound(sound) : "Unlocked Sound" : : "Sound played when the button is door."

	spawnflags(flags) =
	[
		1 : "Starts Open" : 0
		4 : "Non-solid to Player" : 0
		8: "Passable" : 0
	    	32: "Toggle" : 0
		256:"Use Opens" : 0
		512: "NPCs Can't" : 0
		1024: "Touch Opens" : 1
		2048: "Starts locked" : 0
		4096:	"Door Silent"	: 0
	]
	locked_sentence(choices) : "Locked Sentence" : 0 : "A sentence played when the player tries to use the door, and fails because it's locked." =  
	[
		0: "None"
		1: "Gen. Access Denied"
		2: "Security Lockout"
		3: "Blast Door"
		4: "Fire Door"
		5: "Chemical Door"
		6: "Radiation Door"
		7: "Gen. Containment"
		8: "Maintenance Door"
		9: "Broken Shut Door"
	]
	unlocked_sentence(choices) : "Unlocked Sentence" : 0 : "A sentence played when the door is unlocked." = 
	[
		0: "None"
		1: "Gen. Access Granted"
		2: "Security Disengaged"
		3: "Blast Door"
		4: "Fire Door"
		5: "Chemical Door"
		6: "Radiation Door"
		7: "Gen. Containment"
		8: "Maintenance area"
	]	

	loopmovesound(choices) : "Loop Moving Sound?" : 0 : "If set to true, the door's 'Start Sound' will be continually looped until the door finishes moving." =
	[
		0: "No"
		1: "Yes"
	]

	// Outputs
	output OnClose(void) : "Fired when the door starts closing."
	output OnOpen(void) : "Fired when the door starts opening."
	output OnFullyOpen(void) : "Fired when the door reaches the fully open position."
	output OnFullyClosed(void) : "Fired when the door reaches the fully closed position."
	output OnBlockedClosing(void) : "Fired when the door is blocked while closing."
	output OnBlockedOpening(void) : "Fired when the door is blocked while opening."
	output OnUnblockedClosing(void) : "Fired when the door is unblocked while closing."
	output OnUnblockedOpening(void) : "Fired when the door is unblocked while opening."

	// Inputs
	input Open(void) : "Open the door, if it is not fully open."
	input Close(void) : "Close the door, if it is not fully closed."
	input Toggle(void) : "Toggle the door between open and closed."
	input Lock(void) : "Lock the door."
	input Unlock(void) : "Unlock the door."
	input SetSpeed(float) : "Set the door speed."
]


@SolidClass base(Door, Origin) = func_door : "A brush entity for use as a player-useable door."
[
	movedir(angle) : "Move Direction (Pitch Yaw Roll)" : "0 0 0" : "The direction the door will move, when it opens."

	filtername(filterclass) : "Block Filter Name" : : "Filter to use to determine entities that block the door. ( HL1port only )"
]


@SolidClass base(Door, Origin, Angles) = func_door_rotating : "A brush entity for use as a rotating player-useable door." 
[
	spawnflags(flags) =
	[
		2 : "Reverse Dir" : 0
		16: "One-way" : 0
		64: "X Axis" : 0
		128: "Y Axis" : 0
	]
	distance(integer) : "Distance" : 90 : "The amount, in degrees, that the button should rotate when it's pressed."

	solidbsp(choices) : "Solid Type" : 0 =
	[
		0 : "VPhysics"	
		1 : "BSP"
	]
]

@PointClass base(Targetname, Parentname, Angles, Global, Studiomodel) studioprop() = prop_door_rotating : "An entity used to place a model door in the world.\n\n"+
	"If you want to use a model not configured for use with this entity, you can use a brush-based 'func_door_rotating' instead, with a 'prop_dynamic' parented to it."
[
	model(studio) : "World Model" : "models/props_c17/door01_left.mdl" : "Model.  Must be properly configured for use as a rotating door; if you use a bad model, the entity will be quite buggy."
	hardware(choices) : "Hardware Type" : 1 : "The type of door hardware (handle or push bar) that will be put on the model in-game." =
	[
		0 : "<None>"
		1 : "Lever"
		2 : "Push bar"
	]
	
	ajarangles(angle) : "Ajar Angles (Pitch Yaw Roll)" : "0 0 0" : "If the door 'Spawn Position' is set to Ajar, these are the angles to spawn at, instead of being open or closed."
	spawnpos(choices) : "Spawn Position" : 0 =
	[
		0 : "Closed"
		1 : "Open forward"
		2 : "Open back"
		3 : "Ajar (use Ajar Angles)"
	]
	
	axis(axis) : "Hinge Axis" : : "Axis around which to rotate when the door is opened.  This will be nonfunctional if an invalid model is used."
	distance(float) : "Rotation Distance (deg)" : 90 : "The amount, in degrees, that the door should rotate when opened."
	speed(integer) : "Speed" : 100 : "The speed at which the door moves."
	soundopenoverride(sound) : "Fully Open Sound" : : "Sound played when the door has finished opening."
	soundcloseoverride(sound) : "Fully Closed Sound" : : "Sound played when the door has finished closing."
	soundmoveoverride(sound) : "Moving Sound" : : "Sound played when the door starts to move."
	returndelay(integer) : "Delay Before close (-1 stay open)" : -1 : "Amount of time, in seconds, after the door has opened before it closes. If the value is set to -1, the door never closes itself."
	dmg(integer) : "Damage Inflicted When Blocked" : 0 : "Amount of damage done to entities that block the movement of this door, per frame."
	soundlockedoverride(sound) : "Locked Sound" : : "Sound played when the player tries to open the door, and fails because it's locked."
	soundunlockedoverride(sound) : "Unlocked Sound" : : "Sound played when the door is unlocked."

	forceclosed(choices) : "Force Closed" : 0 : "If set, this door will close no matter what. Useful for doors that have to close even if the player tries to block them with objects." =
	[
		0 : "No"
		1 : "Yes"
	]

	spawnflags(flags) =
	[
		1 : "Starts Open" : 0
		//4 : "Don't link" : 0
		//8: "Passable" : 0
    	//32: "Toggle" : 0
		//256:"Use Opens" : 0
		//512: "NPCs Can't" : 0
		//1024: "Touch Opens" : 1
		2048: "Starts locked" : 0
		4096: "Door silent (No sound, and does not alert NPCs)"	: 0
		8192: "Use closes" : 1
		16384 : "Door silent to NPCS (Does not alert NPCs)" : 0
		32768 : "Ignore player +USE" : 0
	]

	// Outputs
	output OnClose(void) : "Fired when the door is told to close."
	output OnOpen(void) : "Fired when the door is told to open."
	output OnFullyOpen(void) : "Fired when the door reaches the fully open position."
	output OnFullyClosed(void) : "Fired when the door reaches the fully closed position."
	output OnBlockedClosing(void) : "Fired when the door is blocked while closing."
	output OnBlockedOpening(void) : "Fired when the door is blocked while opening."
	output OnUnblockedClosing(void) : "Fired when the door is unblocked while closing."
	output OnUnblockedOpening(void) : "Fired when the door is unblocked while opening."

	// Inputs
	input Open(void) : "Open the door, if it is not fully open."
	input OpenAwayFrom(string) : "Open the door away from the specified entity."
	input Close(void) : "Close the door, if it is not fully closed."
	input Toggle(void) : "Toggle the door between open and closed."
	input Lock(void) : "Lock the door."
	input Unlock(void) : "Unlock the door."
]

//
// Moving things
//

@BaseClass base(Targetname, Parentname, Origin, RenderFields) = MoveLinear
[
	movedir(angle) : "Move Direction (Pitch Yaw Roll)" : "0 0 0" : "The direction the water will move, when told to 'Open'."
	startposition(float)	: "Start Position" : 0 : "Position of the water brush when spawned. The range is a value between 0.0 and 1.0, where 0 is the starting position and 1 is the starting position + (move direction * move distance)."	
	speed(integer)			: "Speed" : 100 : "The speed that the water brush moves, in units per second."
	movedistance(float)		: "Move Distance" : 100 : "The distance from the starting point that the water brush should move, in units."
	startsound(sound)		: "Sound played when the water brush starts moving."
	stopsound(sound)		: "Sound played when the water brush stops moving."

	// Inputs
	input Open(void) : "Move the brush to the end position (starting position + (move direction * move distance))."
	input Close(void) : "Move the brush to the starting position."
	input SetPosition(string) : "Move the brush to a specific position.  0.0 is the starting position; 1.0 is the ending position; 1.5 is the ending position plus half the travel distance; etc."

	// Outputs
	output OnFullyOpen(void) : "Fired when the brush reaches the end position (starting position + (move direction * move distance))."
	output OnFullyClosed(void) : "Fired when the brush reaches the starting position."
]

@SolidClass base(MoveLinear) = func_movelinear :
	"A brush entity that moves linearly along a given distance, in a given direction."
[
	spawnflags(flags) =
	[
		8	: "Not Solid" : 0
	]
]

@SolidClass base(Targetname, Parentname, Origin, Angles, RenderFields, BasePlat) = func_platrot : "A brush entity that moves vertically, and can rotate while doing so." 
[
	spawnflags(Flags) =
	[
		1: "Toggle" : 1
		64: "X Axis" : 0
		128: "Y Axis" : 0
	]
	noise1(sound) : "Movement Sound" : : "The sound to play when the brush moves."
	noise2(sound) : "Stop Sound" : : "The sound to play when the brush stops moving."
	speed(integer) : "Speed of Rotation" : 50 : "Speed at which the brush rotates, in degrees per second."
	height(integer) : "Travel Altitude" : 0 : "The vertical distance from the starting position that this platform moves. If negative, the platform will lower."
	rotation(integer) : "Spin amount" : 0 : "The amount this platform should rotate as it moves, in degrees."

]

@SolidClass base(Targetname, Parentname, Origin, Angles, RenderFields) = func_rotating : "A rotating brush entity."
[
	maxspeed(integer) : "Max Rotation Speed" : 100 : "The maximum rotation speed of the brushes, in degrees per second."
	fanfriction(integer) : "Friction (0 - 100%)" : 20 : "The amount of rotational friction. Value must be between 0 and 100 %."
	message(sound) : "Rotating sound WAV" : : "Sound to play while rotating."
	volume(integer) : "Volume (10 = loudest)" : 10 : "The volume of the rotation sound."
	spawnflags(flags) =
	[
		1 : "Start ON" 		: 0
		2 : "Reverse Direction" : 0
		4 : "X Axis" 		: 0
		8 : "Y Axis" 		: 0
		16: "Acc/Dcc"		: 0
		32: "Fan Pain"		: 0
		64: "Not Solid"		: 0
		128: "Small Sound Radius" : 0
		256: "Medium Sound Radius" : 0
		512: "Large Sound Radius" : 1
	]

	dmg(integer) : "Blocking Damage" : 0 : "Damage done to any entity that blocks the rotation, per frame."

	solidbsp(choices) : "Solid Type" : 0 =
	[
		0 : "VPhysics"	
		1 : "BSP"
	]

	// Inputs
	input SetSpeed(integer) : "Set the speed as a ratio of the specified Max Rotation Speed, where 0 is stopped and 1 is the Max Rotation Speed.."
	input Start(void) : "Start the rotator rotating."
	input Stop(void) : "Stop the rotator from rotating."
	input StopAtStartPos(void) : "Stop the rotator from rotating when it gets around to the start position again (on its rotation axis)."
	input StartForward(void) : "Start the rotator rotating forward."
	input StartBackward(void) : "Start the rotator rotating backward."
	input Toggle(void) : "Toggle the rotator between rotating and not rotating."
	input Reverse(void) : "Reverse the direction of rotation of the rotator."
]

@SolidClass base(MoveLinear) = func_water_analog :
	"A water brush entity that moves linearly along a given distance, in a given direction"
[
	WaveHeight(string)		: "Wave Height" : "3.0"
]

//
// BModel particle spawners
//

@BaseClass = BModelParticleSpawner
[ 
	StartDisabled(choices) : "Start Disabled" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]

	Color(color255)		: "Particle Color (R G B)"		: "255 255 255"
	SpawnRate(integer)	: "Particle Per Second"			: 40 : "Number of particles to spawn, per second."
	SpeedMax(string)	: "Maximum Particle Speed"		: 13 : "Maximum speed that the particles can move after spawning."
	LifetimeMin(string)	: "Minimum Particle Lifetime"	: 3 : "Minimum number of seconds until each particle dies. Particles live for a random duration between this and 'Maximum Particle Lifetime'."
	LifetimeMax(string)	: "Maximum Particle Lifetime"	: 5 : "Maximum number of seconds until each particle dies. Particles live for a random duration between 'Minimum Particle Lifetime' and this."
	DistMax(integer)	: "Maximum Visible Distance"	: 1024 : "Maximum distance at which particles are visible. They fade to translucent at this distance."

	Frozen(choices)		: "Frozen" : 0 : "When set, this entity spawns the number of particles in SpawnRate immediately, and then goes inactive." =
	[
		0 : "No"
		1 : "Yes"
	]

	input TurnOn(void)	: "Turn on."
	input TurnOff(void) : "Turn off."
]


@SolidClass base(Targetname, BModelParticleSpawner) = func_dustmotes : "A brush entity that spawns sparkling dust motes within its volume."
[
	SizeMin(string)		: "Minimum Particle Size"		: 10
	SizeMax(string)		: "Maximum Particle Size"		: 20

	Alpha(integer)		: "Alpha"						: 255
]


@SolidClass base( Targetname ) = func_smokevolume : "A brush entity that spawns smoke particles within its volume."
[
	spawnflags(flags) =
	[
		1 : "Emissive" : 0
	]

	Color1(color255) : "Particle Color1 (R G B)" : "255 255 255"
	Color2(color255) : "Particle Color2 (R G B)" : "255 255 255"
	material(material) : "Material" : "particle/smoke_grenade1" : "The material to use for the particle.s"
	ParticleDrawWidth(float) : "Particle Draw Width (inches)" : 120 : "The size of the particles, in units."
	ParticleSpacingDistance(float) : "Particle Spacing Distance (inches)" : 80 : "The distance between the particles inside the volume. The lower the number, the denser the particles, and the more overdraw there will be. It is best to keep it as high as you can without it looking bad."
	DensityRampSpeed(float) : "Density Ramp Speed (seconds)" : 1 : "Time to go from density 0 to density 1, in seconds."

	RotationSpeed(float) : "Rotation Speed (degrees/sec)" : 10 : "The speed that the particles should rotate, in degrees per second."
	MovementSpeed(float) : "Movement Speed (inches/sec)" : 10 : "The speed that the particles should move around, in units per second."
	Density(float) : "Density [0..1]" : 1

	// Inputs
	input SetRotationSpeed(float) : "Set the particle rotation speed (in degrees per second)."
	input SetMovementSpeed(float) : "Set the particle movement speed (in units per second)."
	input SetDensity(float) : "Set the particle density. It should be a range from 0 to 1."
]

@SolidClass base( Targetname, BModelParticleSpawner ) = func_dustcloud : "A brush entity that spawns a translucent dust cloud within its volume."
[
	Alpha(integer)		: "Alpha"						: 30

	SizeMin(string)		: "Minimum Particle Size"		: 100
	SizeMax(string)		: "Maximum Particle Size"		: 200
]

//-------------------------------------------------------------------------
//
// Logic Entities
//
//-------------------------------------------------------------------------
@PointClass iconsprite("editor/logic_auto.vmt") = logic_auto : "Fires outputs when a map spawns." +
	"If 'Remove on fire' flag is set the logic_auto is deleted after firing. " +
	"It can be set to check a global state before firing. This allows you to only fire events based on "+
	"what took place in a previous map."
[
	spawnflags(Flags) =
	[
		1 : "Remove on fire" : 1
	]
	
	globalstate(choices) : "Global State to Read" : : "If set, this specifies a global state to check before firing. The OnMapSpawn output will only fire if the global state is set." =
	[
		"" : "--- None ---"
		"gordon_precriminal" : "Gordon pre-criminal" 
		"antlion_allied" : "Antlions are player allies" 
		"suit_no_sprint" : "Suit sprint function not yet enabled" 
		"super_phys_gun" : "Super phys gun is enabled" 
		"friendly_encounter" : "Friendly encounter sequence (lower weapons, etc.)"
		"gordon_invulnerable" : "Gordon is invulnerable"
		"no_seagulls_on_jeep" : "Don't spawn seagulls on the jeep"
	]
	
	// Outputs
	output OnMapSpawn(void) : "Fired when the map is loaded for any reason."
	output OnNewGame(void) : "Fired when the map is loaded to start a new game."
	output OnLoadGame(void) : "Fired when the map is loaded from a saved game."
	output OnMapTransition(void) : "Fired when the map is loaded due to a level transition."
	output OnBackgroundMap(void) : "Fired when the map is loaded as a background to the main menu."
]


@PointClass base(Targetname,Angles,Parentname) size(-8 -8 -8, 8 8 8) = point_viewcontrol : "A camera entity that controls the player's view. While it's active, the player will see out of the camera." 
[
	target(target_destination) : "Entity to Look At" : : "Name of the entity that the camera should point at and track while active."
	targetattachment(string) : "Target Attachment Name" : : "If set, the camera will focus on the specified attachment on the 'Entity to Look At'."
	wait(integer) : "Hold Time" : 10 : "The amount of time the camera should control the player's view for, after which it deactivates itself. If the camera should stay active until told to deactive, set the 'Infinite Hold Time' spawnflag."
	moveto(target_destination) : "Path Corner" : : "The first path corner in a track that the camera should move along once it's activated. If not specified, the camera won't move."
	spawnflags(flags) =
	[
		1: "Start At Player" : 1
		2: "Follow Player" : 1
		4: "Freeze Player" : 0
		8: "Infinite Hold Time" : 0
		16:"Snap to goal angles" : 0
		32:"Make Player non-solid" : 0
		64:"Interruptable by Player" : 0
	]
	speed(string) : "Initial Speed" : "0" : "The starting speed that the camera moves at, if it's on a path track."
	acceleration(string) : "Acceleration (units/sec^2)" : "500" : "Rate of acceleration for the camera as it speeds up."
	deceleration(string) : "Deceleration (units/sec^2)" : "500" : "Rate of deceleration for the camera as it slows."

	// Inputs
	input Enable(void) : "Enable the point_viewcontrol, and start controlling the player's view."
	input Disable(void) : "Disable the point_viewcontrol, and stop controlling the player's view."

	// Outputs
	output OnEndFollow(void) : "Fired when the point_viewcontrol deactivates, due to the Disable input being received, the Entity to Look At being destroyed, or the Hold Time expiring."
]


@PointClass base(Targetname) iconsprite("editor/logic_compare.vmt") = logic_compare :
	"Compares an input value to another value. " +
	"If the input value is less than the compare value, the OnLessThan output is fired with the input value. " +
	"If the input value is equal to the compare value, the OnEqualTo output is fired with the input value. " +	
	"If the input value is greater than the compare value, the OnGreaterThan output is fired with the input value."
[
	// Keys
	InitialValue(integer) : "Initial value" : : "Initial value for the input value."
	CompareValue(integer) : "Compare value" : : "The value to compare against."
	
	// Inputs
	input SetValue(float) : "Set the value that will be compared against the compare value."
	input SetValueCompare(float) : "Set the value that will be compared against the compare value and performs the comparison."
	input SetCompareValue(float) : "Set the compare value."
	input Compare(void) : "Force a compare of the input value with the compare value."
	
	// Outputs
	output OnLessThan(float) : "Fired when the input value is less than the compare value. Sends the input value as data." 
	output OnEqualTo(float) : "Fired when the input value is equal to the compare value. Sends the input value as data." 
	output OnNotEqualTo(float) : "Fired when the input value is different from the compare value. Sends the input value as data." 
	output OnGreaterThan(float) : "Fired when the input value is greater than the compare value. Sends the input value as data."
]


@PointClass base(Targetname) iconsprite("editor/logic_branch.vmt") = logic_branch :
	"Tests a boolean value and fires an output based on whether the value is true or false. " +
	"Use this entity to branch between two potential sets of events."
[
	// Keys
	InitialValue(integer) : "Initial value" : : "Initial value for the boolean value (0 or 1)."
	
	// Inputs
	input SetValue(bool) : "Set the boolean value without performing the comparison. Use this to hold a value for a future test."
	input SetValueTest(bool) : "Set the boolean value and test it, firing OnTrue or OnFalse based on the new value."
	input Toggle(void) : "Toggle the boolean value between true and false."
	input ToggleTest(void) : "Toggle the boolean value and tests it, firing OnTrue or OnFalse based on the new value."
	input Test(void) : "Test the input value and fire OnTrue or OnFalse based on the value."
	
	// Outputs
	output OnTrue(bool) : "Fired when the input value is true (nonzero)." 
	output OnFalse(bool) : "Fired when the input value is false (zero)." 
]


@PointClass base(Targetname) iconsprite("editor/logic_case.vmt") = logic_case :
	"Compares an input to up to 16 preset values. If the input value is the same as " +
	"any of the preset values, an output corresponding to that value is fired.\n\n" +
	"For example: if Case01 is set to 2 and Case02 is set to 5, and the input value is 5, " +
	"the OnCase02 output will be fired.\n\n" +
	"This entity can also be used to select from a number of random targets via the " +
	"PickRandom input. One of the OnCase outputs that is connected to another entity will " +
	"be picked at random and fired."
[
	Case01(string) : "Case 01"
	Case02(string) : "Case 02"
	Case03(string) : "Case 03"
	Case04(string) : "Case 04"
	Case05(string) : "Case 05"
	Case06(string) : "Case 06"
	Case07(string) : "Case 07"
	Case08(string) : "Case 08"
	Case09(string) : "Case 09"
	Case10(string) : "Case 10"
	Case11(string) : "Case 11"
	Case12(string) : "Case 12"
	Case13(string) : "Case 13"
	Case14(string) : "Case 14"
	Case15(string) : "Case 15"
	Case16(string) : "Case 16"

	// Inputs
	input InValue(string) : "Compare the Input value to the case values, and fire the appropriate output, if any."
	input PickRandom(void) : "Fire a random OnCase output with at least one connection."
	
	// Outputs
	output OnCase01(void) : "Fired when the input value equals the Case01 value."
	output OnCase02(void) : "Fired when the input value equals the Case02 value."
	output OnCase03(void) : "Fired when the input value equals the Case03 value."
	output OnCase04(void) : "Fired when the input value equals the Case04 value."
	output OnCase05(void) : "Fired when the input value equals the Case05 value."
	output OnCase06(void) : "Fired when the input value equals the Case06 value."
	output OnCase07(void) : "Fired when the input value equals the Case07 value."
	output OnCase08(void) : "Fired when the input value equals the Case08 value."
	output OnCase09(void) : "Fired when the input value equals the Case09 value."
	output OnCase10(void) : "Fired when the input value equals the Case10 value."
	output OnCase11(void) : "Fired when the input value equals the Case11 value."
	output OnCase12(void) : "Fired when the input value equals the Case12 value."
	output OnCase13(void) : "Fired when the input value equals the Case13 value."
	output OnCase14(void) : "Fired when the input value equals the Case14 value."
	output OnCase15(void) : "Fired when the input value equals the Case15 value."
	output OnCase16(void) : "Fired when the input value equals the Case16 value."
	output OnDefault(void) : "Fired when the input value does not equal any of the Case values."
]

@PointClass color(0 0 255) base(Targetname) iconsprite("editor/choreo_scene.vmt") = logic_choreographed_scene :
	"Manages a choreographed scene of one or more actors."

[
	// Keys
	SceneFile(scene) : "Scene file"

	// Links
	target1(target_destination)	: "Target 1"
	target2(target_destination)	: "Target 2"
	target3(target_destination)	: "Target 3"
	target4(target_destination)	: "Target 4"
	target5(target_destination)	: "Target 5"
	target6(target_destination)	: "Target 6"
	target7(target_destination)	: "Target 7"
	target8(target_destination)	: "Target 8"

	busyactor(choices) : "If an Actor is talking..." : 0 : "What to do if an actor this scene needs is already talking when this scene is told to start." =
	[
		0: "Default"
		1: "Wait for actor to finish"
	]

	// Inputs
	input Start(void) : "Starts playback of the scene file"
	input Pause(void) : "Pauses playback of the scene file"
	input Resume(void) : "Resumes playback of the scene if it has been paused"
	input Cancel(void) : "Cancels playback of the scene"

	input InterjectResponse(string) : "Finds an actor who can respond to the specified concept string while the scene continues playing"

	input StopWaitingForActor(void) : "Stop waiting on an actor to stop talking."

	output OnStart(void) : "The scene has started"
	output OnCompletion(void) : "The scene has completed"
	output OnCanceled(void) : "The scene has been canceled"
	output OnTrigger1(void) : "Scene trigger 1"
	output OnTrigger2(void) : "Scene trigger 2"
	output OnTrigger3(void) : "Scene trigger 3"
	output OnTrigger4(void) : "Scene trigger 4"
	output OnTrigger5(void) : "Scene trigger 5"
	output OnTrigger6(void) : "Scene trigger 6"
	output OnTrigger7(void) : "Scene trigger 7"
	output OnTrigger8(void) : "Scene trigger 8"
]

@PointClass base(Targetname) iconsprite("editor/logic_multicompare.vmt") = logic_multicompare :
	"Compares a set of integral inputs to each other.  Keeps a list of the parameters of the InputValue inputs it receives; compares all of these parameters when it receives a CompareValues input.  Fires the appropriate output."
[
	// keys
	IntegerValue(integer) : "Integer Value (optional)" : : "This value will be added to the list of values that should be compared.  All values must match this for OnEqual to be fired."
	ShouldComparetoValue(choices) : "Should use Integer Value" : 0 : "Whether to use the integer value, above." =
	[
		0 : "No"
		1 : "Yes"
	]

	// Inputs
	input InputValue(integer) : "Add a value to the internal list of values to be compared."
	input CompareValues(void) : "Compare the values and fire the appropriate output."

	// Outputs
	output OnEqual(void) : "Fired if all of the input values are equal."
	output OnNotEqual(void) : "Fired if any input value is different from the others."
]

@PointClass base(Targetname, EnableDisable) iconsprite("editor/logic_relay.vmt") = logic_relay :
	"A message forwarder. Fires an OnTrigger output when triggered, and " +
	"can be disabled to prevent forwarding outputs.\n\n" +
	"Useful as an intermediary between one entity and another for turning " +
	"on or off an I/O connection, or as a container for holding a set of " +
	"outputs that can be triggered from multiple places."
[
	spawnflags(flags) =
	[
		1: "Only trigger once" : 0
		2: "Allow fast retrigger" : 0
	]

	// Inputs
	input Trigger(void) : "Trigger the relay, causing its OnTrigger output to fire if it is enabled."
	input Toggle(void) : "Toggle the relay between enabled and disabled."
	input CancelPending(void) : "Cancel any events fired by this relay that are currently pending in the I/O event queue."
	
	// Outputs
	output OnTrigger(void) : "Fired when the relay is triggered."
]


@PointClass base(Targetname, EnableDisable) iconsprite("editor/logic_timer.vmt") = logic_timer :
	"An entity that fires a timer event at regular, or random, intervals. It can also be set to oscillate between" + 
	"a high and low end, in which case it will fire one of two outputs each time it fires."
[
	// Keys
	spawnflags(flags) =
	[
		1 : "Oscillator (alternates between OnTimerHigh and OnTimerLow outputs)" : 0
	]

	UseRandomTime(choices) : "Use Random Time" : "" =
	[
		"" : "No"
		1 : "Yes"
	]
	
	LowerRandomBound(string) : "Minimum Random Interval" : : "If 'Use Random Time' is set, this is the minimum time between timer fires. The time will be a random number between this and the 'Maximum Random Interval'."
	UpperRandomBound(string) : "Maximum Random Interval" : : "If 'Use Random Time' is set, this is the maximum time between timer fires. The time will be a random number between the 'Minimum Random Interval' and this."
	RefireTime(string) : "Refire Interval" : : "If 'Use Random Time' isn't set, this is the time between timer fires, in seconds."

	// Inputs
	input Toggle(void) : "Toggle the timer on/off."
	input RefireTime(integer) : "Set a new Refire Interval."
	input FireTimer(void) : "Force the timer to fire immediately."
	input LowerRandomBound(float) : "Set a new Minimum Random Interval."
	input UpperRandomBound(float) : "Set a new Maximum Random Interval."
	input UseRandomTime(integer) : "Changes the timer's 'Use Random Time' property.  Use a parameter of 1 for Yes and no parameter for No."

	// Outputs
	output OnTimer(void) : "Fired when the timer expires."
	output OnTimerHigh(void) : "Fired every other time for an oscillating timer."
	output OnTimerLow(void) : "Fired every other time for an oscillating timer."
]

@PointClass base(Targetname) size(-4 -4 -4, 4 4 4) color(0 255 0) = logic_collision_pair : "An entity that can be used to enables/disable vphysics collisions between two target entities."
[
	attach1(target_destination) : "Attachment 1" : "" : "The first entity."
	attach2(target_destination) : "Attachment 2" : "" : "The second entity."

	startdisabled(choices) : "Start with collisions disabled" : 1 =
	[
		0 : "No"
		1 : "Yes"
	]

	// Inputs
	input EnableCollisions(void) : "Enable collisions between the first and second entity."
	input DisableCollisions(void) : "Disable collisions between the first and second entity."
]


@PointClass base(Targetname, Parentname, EnableDisable) iconsprite("editor/env_microphone.vmt") color(0 0 255) sphere(MaxRange) = env_microphone :
	"An entity that acts as a microphone. It works in one of two modes. If it has a 'Speaker' set, it picks up all sounds within the specified sound range, " +
	"and rebroadcasts them through the Speaker entity. In this Speaker mode, it ignores the Hears X spawnflags and does not fire the SoundLevel output. " +
	"If it has no Speaker set, it measures the sound level at a point, and outputs the sound level as a value between 0 and 1. In Measuring mode, it only hears sounds that match the Hear X spawnflags."
[
	target(target_destination) : "Measure target" : : "If the speaker is in Measuring mode, this is the name of the entity where the sound level is to be measured."
	SpeakerName(target_destination) : "Speaker" : "" : "The name of a speaker entity through which to play any sounds heard by this microphone. If specified, the microphone will consider itself in Speaker mode."
	ListenFilter(filterclass) : "Listen Filter" : "" : "The name of an filter entity which specifies the only entities the microphone can hear. Sounds emitted by other entities will not be heard."
	speaker_dsp_preset(choices) : "Speaker DSP Preset" : 0 : "Only useful in Speaker mode. If specified, when the microphone is enabled, it'll set the global dsp_speaker preset to this value. Sounds played back through speakers will then be affected by the selected DSP." =
	[
 		0 : "Use Default"
		50 : "1 NO EFFECT"
		51 : "2 (DUPLICATE OF 1)"
		52 : "3 (DUPLICATE OF 1)"
		53 : "4 (DUPLICATE OF 1)"
		54 : "5 (DUPLICATE OF 1)"
		55 : "6 SPEAKER, LOUDER"
		56 : "7 SPEAKER VERY SMALL"
		57 : "8 LOUDSPEAKER, ECHO"
		58 : "9 SPEAKER SMALL"
		59 : "10 SPEAKER TINY"
	]

	spawnflags(flags) =
	[
		1 : "Hears combat sounds" : 1
		2 : "Hears world sounds" : 1
		4 : "Hears player sounds" : 1
		8 : "Hears bullet impacts" : 1
		16: "Mute the sounds heard, so that only the speaker can play them" : 0
		32: "Hears explosions" : 0
	]

	Sensitivity(float) : "Sensitivity (0 - 10)" : "1.0" : "Microphone sensitivity, 0=deaf, 1=default, 10=extremely sensitive). Only applicable in Measuring mode."
	SmoothFactor(float) : "Smoothing (0 - 1)" : 0 : "Smoothing factor, 0=no smoothing, 1=maximum smoothing). Only applicable in Measuring mode."
	MaxRange(float) : "Maximum hearing range (0=infinite)" : 240 : "Sounds beyond this range won't be heard, irrelevant of attenuation. "+
		"WARNING: setting this to zero (or a value > 1024) when the microphone is in Speaker mode can be very bad for performance!!"

	// Inputs
	input SetSpeakerName(string) : "Set the microphone to output through a different speaker entity."

	// Outputs
	output SoundLevel(float) : "Fired in Measuring mode whenever the sound level changes, passing along the new level as a parameter."
	output OnRoutedSound(void) : "Fired whenever a sound is routed through the specified speaker (if any)."
	output OnHeardSound(void) : "Fired whenever this microphone hears any sound it cares about."
]

@BaseClass base(Targetname) = Remap
[
	spawnflags(flags) = 
	[
		1 : "Ignore out of range invalues (don't clamp them to legal range)" : 1
	]
	input InValue(float) : "Input value and fire the output with the remapped value."
]

@PointClass base(Remap) = math_remap :
	"An entity that maps a range of input values to a given range of output values."
[
	in1(integer) : "Minimum Valid Input Value" : 0 : "Input values below this value will be ignored."
	in2(integer) : "Maximum Valid Input Value" : 1 : "Input values above this value will be ignored."
	out1(integer) : "Output Value When Input Is Min." : : "When the input value is equal to 'Minimum Valid Input Value', this is the output value."
	out2(integer) : "Output Value When Input Is Max." : : "When the input value is equal to 'Maximum Valid Input Value', this is the output value."

	output OutValue(float) : "Fired when the InValue input is received, with the remapped input value as the parameter."
]


@PointClass base(Remap) = math_colorblend :
	"Used to create a blend between two colors for controlling the color of another entity.  Maps an input value to a color."
[
	inmin(integer) : "Minimum Valid Input Value" : 0 : "Input values below this value will be ignored."
	inmax(integer) : "Maximum Valid Input Value" : 1 : "Input values above this value will be ignored."
	colormin(color255) : "Output color when input is min." : "0 0 0" : "When the input value is equal to 'Minimum Valid Input Value', this is the output RGB color."
	colormax(color255) : "Output color when input is max." : "When the input value is equal to 'Maximum Valid Input Value', this is the output RGB color."

	output OutColor(color255) : "Fired when the InValue input is received, with the remapped RGB color as the parameter."
]


@PointClass base(Targetname) iconsprite("editor/math_counter.vmt") = math_counter :
	"Holds a numeric value and performs arithmetic operations upon it. If either the minimum or maximum " +
	"legal value is nonzero, OutValue will be clamped to the legal range, and the OnHitMin/OnHitMax " +
	"outputs will be fired at the appropriate times. If both min and max are set to zero, no clamping is " +
	"performed and only the OutValue output will be fired."
[
	// Keys
	startvalue(integer) : "Initial Value" : 0 : "Starting value for the counter."
	min(integer) : "Minimum Legal Value" : 0 : "Minimum legal value for the counter. If min=0 and max=0, no clamping is performed."
	max(integer) : "Maximum Legal Value" : 0 : "Maximum legal value for the counter. If min=0 and max=0, no clamping is performed."

	// Inputs
	input Add(integer) : "Add an amount to the counter and fire the OutValue output with the result."
	input Divide(integer): "Divide the counter by an amount and fire the OutValue output with the result."
	input Multiply(integer): "Multiply the counter by an amount and fire the OutValue output with the result."
	input SetValue(integer): "Set the counter to a new value and fire the OutValue output with the result."
	input SetValueNoFire(integer): "Set the counter to a new value without firing any outputs."
	input Subtract(integer): "Subtract an amount from the counter and fire the OutValue output with the result."
	input SetHitMax(integer): "Set the upper bound of the counter and fire the OutValue output with the current value."
	input SetHitMin(integer): "Set the lower bound of the counter and fire the OutValue output with the current value."

	// Outputs
	output OutValue(integer) : "Fired when the counter value changes."
	output OnHitMin(void) : "Fired when the counter value meets or goes below the min value. The counter must go back above the min value before the output will fire again."
	output OnHitMax(void) : "Fired when the counter value meets or exceeds the max value. The counter must go below the max value before the output will fire again."
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = logic_lineto : 
	"An entity that calculates and outputs a vector from one entity to another." 
[
	source(target_destination) : "Start entity" : : "Name of the entity the line should start from."
	target(target_destination) : "End entity" : : "Name of the entity that line should end at."
	
	// Outputs
	output Line(vector) : "Fired when the vector, from the start entity to the end entity, changes. Passes along the vector as a parameter."
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = logic_navigation : 
	"An entity that is used to set navigation properties on other entities." 
[
	target(target_destination) : "Navigation Entity" : : "Name of the entity to set navigation properties on."
	spawnflags(flags) =
	[
		1 : "Start On" : 1
	]
	navprop(choices) : "Nav Property" : "Ignore" =
	[
		"Ignore" : "Ignored by NPCs (they bump into it)"
	]
	
	// Inputs
	input TurnOn(void)	: "Turn on. The Navigation Entity will have its navigation properties set."
	input TurnOff(void) : "Turn off. The Navigation Entity will have its navigation properties returned to the default settings."
	input Toggle(void)	: "Toggle on/off."
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = logic_autosave :
	"An entity that is used to force an autosave."
[
	NewLevelUnit(choices) : "Force New Level Unit" : 0 : "If set, the save will discard any savedata from previous levels, for the purpose of keeping savegame filesizes down. Can only be safely used if there is no way for the player to return to previous levels." =
	[
		0 : "No"
		1 : "Yes"
	]
	
	// Inputs
	input Save(void) : "Force an autosave."
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = point_template : 
	"An entity that 'remembers' other entities and can create perfect copies of them; for instance, you can create a single prop_physics "+
	"and set it as one of this entity's templates; at a later time you will be able to spawn another prop_physics exactly like the first.\n\n"+
	"Entities spawned in this way will, by default, be renamed to '<oldname>&0000' through '<oldname>&9999'.  If this renaming is performed, "+
	"and the entities rely on each other for I/O, parenting, etc., then the said interdependencies will be automatically modified to point "+
	"to the renamed versions.\n\nAn env_entity_maker can be used to spawn template entities at locations other than their original position."
[
	spawnflags(flags) =
	[
		1 : "Don't remove template entities upon map start" : 0
		2 : "Preserve entity names (don't do name fixup)" : 1
	]

	Template01(target_destination) : "Template 1" : : "The targetname of an entity, or multiple entities, to 'remember'.  Note that 'foo*' will match all entities whose name begins with foo."
	Template02(target_destination) : "Template 2"
	Template03(target_destination) : "Template 3"
	Template04(target_destination) : "Template 4"
	Template05(target_destination) : "Template 5"
	Template06(target_destination) : "Template 6"
	Template07(target_destination) : "Template 7"
	Template08(target_destination) : "Template 8"
	Template09(target_destination) : "Template 9"
	Template10(target_destination) : "Template 10"
	Template11(target_destination) : "Template 11"
	Template12(target_destination) : "Template 12"
	Template13(target_destination) : "Template 13"
	Template14(target_destination) : "Template 14"
	Template15(target_destination) : "Template 15"
	Template16(target_destination) : "Template 16"

	// inputs
	input ForceSpawn(void) : "Spawn an instance of the template at the original position."

	// outputs
	output OnEntitySpawned(void) : "Fired after spawning an instance of this template."
]

@PointClass base(Targetname,Parentname,Angles) = env_entity_maker : 
	"An extension of point_template that allows for spawning template entities at different positions and orientations.  When the "+
	"specified point_template's template entities are spawned here, they will be placed relative to the env_entity_maker in the same "+
	"positions as they were before, relative to the point_template."
[
	spawnflags(Flags) =
	[
		1 : "Enable AutoSpawn (will spawn whenever there's room)" : 0
		2 : "AutoSpawn: Wait for entity destruction" : 0
		4 : "AutoSpawn: Even if the player is looking" : 0
		8 : "ForceSpawn: Only if there's room" : 0
	   16 : "ForceSpawn: Only if the player isn't looking" : 0
	]

	EntityTemplate(target_destination) : "Point_template to spawn" : "" : "Name of the point_template to spawn here."

	// inputs
	input ForceSpawn(void) : "Spawn an instance of the template at this origin and angle."

	// outputs
	output OnEntitySpawned(void) : "Fired when an instance of the entity template has been spawned."
]

//-------------------------------------------------------------------------
//
// Activator Filters
//
//-------------------------------------------------------------------------
@BaseClass base(Targetname) = BaseFilter
[
	Negated(choices) : "Filter mode" : 0 : "If set to Allow, only entities who match the criteria will pass the filter. "+
		"If set to Disallow, only entities who do NOT match the criteria will pass the filter." =
	[
		0 : "Allow entities that match criteria"
		1 : "Disallow entities that match criteria"
	]

	// Inputs
	input TestActivator(void) : "Test the activator against the filter and fires OnPass or OnFail output."

	// Outputs
	output OnPass(void) : "Fired in response to TestActivator input if the activator passes the filter."
	output OnFail(void) : "Fired in response to TestActivator input if the activator fails to pass the filter."
]

@FilterClass base(BaseFilter) iconsprite("editor/filter_multiple.vmt") = filter_multi :
	"A filter that tests the activator against multiple filters. This allows you to build more complex filters, such as"+
	"'Allow anyone on Team 1 who is also class engineer', or 'Allow everyone except classes npc_zombie and npc_headcrab'."
[
	filtertype(choices) : "Logic Type" : 0 =
	[
		0 : "AND (all filters must pass)"
		1 : "OR (any filter must pass)"
	]

	Negated(choices) : "Negate Outcome" : 0 : "Whether to negate the result of the subfilters, after combining them using the Logic Type chosen.\n"+
		"Negating the outcome using the AND logic type means that any subfilter must fail for this filter to pass.\n"+
		"Negating the outcome using the OR logic type means that all subfilters must fail for this filter to pass." =
	[
		0 : "No"
		1 : "Yes"
	]

	Filter01(filterclass) : "Filter 1" : : "Activator filter to test."
	Filter02(filterclass) : "Filter 2" : : "Activator filter to test."
	Filter03(filterclass) : "Filter 3" : : "Activator filter to test."
	Filter04(filterclass) : "Filter 4" : : "Activator filter to test."
	Filter05(filterclass) : "Filter 5" : : "Activator filter to test."
]

@FilterClass base(BaseFilter) iconsprite("editor/filter_name.vmt") = filter_activator_name :
	"A filter that filters by the name of the activator."
[
	filtername(target_destination) : "Filter Name" : : "The name to filter by. If the filter mode is Allow, only entities whose "+
		"name matches the given string will pass the filter. If the filter mode is Disallow, "+
		"all entities EXCEPT those whose name matches the string will pass the filter."
]

@FilterClass base(BaseFilter) iconsprite("editor/filter_class.vmt") = filter_activator_class :
	"A filter that filters by the class name of the activator."
[
	filterclass(string) : "Filter Classname" : : "The class name to filter by. If the filter mode is Allow, only entities whose "+
		"class name matches the given string will pass the filter. If the filter mode is Disallow, "+
		"all entities EXCEPT those whose class name matches the given string will pass the filter."
]

@FilterClass base(BaseFilter) = filter_damage_type :
	"A damage filter that filters by the type of damage inflicted. This can only be used as a damage filter, not as an activator filter."
[
	damagetype(choices) : "Damage type" : 64 : "The damage type to filter by. If the filter mode is Allow, only damage types that "+
		"match will pass the filter. If the filter mode is Disallow, all damage types EXCEPT those who match will pass the filter." =
	[
		0 : "GENERIC"
		1 : "CRUSH"
		2 : "BULLET"
		4 : "SLASH"
		8 : "BURN"
		16 : "FREEZE"
		32 : "FALL"
		64 : "BLAST"
		128 : "CLUB"
		256 : "SHOCK"
		512 : "SONIC"
		1024 : "ENERGYBEAM"
		16384: "DROWN"
		32768 : "PARALYSE"
		65536 : "NERVEGAS"
		131072 : "POISON"
		262144 : "RADIATION"
		524288 : "DROWNRECOVER"
		1048576 : "CHEMICAL"
		2097152 : "SLOWBURN"
		4194304 : "SLOWFREEZE"
	]
]


//-------------------------------------------------------------------------
//
// Point Entities
//
//-------------------------------------------------------------------------
@PointClass base(Targetname, Parentname, EnableDisable) = point_anglesensor :
	"An entity that detects if another entity points in a given direction for a period of time."
[
	target(target_destination) : "Target Entity Name" : : "Name of the entity whose angles will be sensed."
	lookatname(target_destination) : "Look At Entity" : : "The entity we want to check to see if the Target Entity is looking at."
	duration(float) : "Duration" : : "The amount of time the Target Entity must look at the 'Look at Entity' to trigger this entity, in seconds."
	tolerance(integer) : "Tolerance" : : "The tolerance, in degrees, in the checking to determine when the Target Entity is looking at the Look At Entity."

	// Inputs
	input Toggle(void) : "Toggle the sensor between enabled and disabled."
	input Test(void) : "Check to see if the Target Entity is facing the Look At Entity within the specified tolerance, firing either the OnFacingLookat or OnNotFacingLookat output based on the result."
	
	// Outputs
	output TargetDir(vector) : "Fired when the forward direction of the Target Entity changes. Passes the new forward direction as a parameter."
	output OnFacingLookat(void) : "Fired when the Target Entity points at the Look At Entity for more than the specified Duration, or in response to a Test input."
	output OnNotFacingLookat(void) : "Fires in response to a Test input when the Target Entity is not pointing at the Look At Entity."
]


@PointClass base(Targetname) = point_angularvelocitysensor :
	"An entity that detects if another entity's angular velocity meets or exceeds a threshold value."
[
	target(target_destination) : "Target Entity Name" : : "Name of the entity whose angular velocity will be sensed."
	threshold(float) : "Threshold Velocity" : 0 : "The threshold angular velocity to compare against, in degrees per second."

	// Inputs
	input Test(void) : "Checks to see if the Target Entity's angular velocity meets or exceeds the Threshold Velocity, " +
		"firing either the OnGreaterThanOrEqualTo or OnLessThan output based on the result."
	
	// Outputs
	output AngularVelocity(float) : "Fired when the Target's Angular Velocity changes, passing the new magnitude of the angular velocity."
	output OnGreaterThan(void) : "Fired when the Target Entity goes from slower than the threshold angular velocity to faster than the threshold angular velocity."
	output OnGreaterThanOrEqualTo(void) : "Fired when the Target Entity goes from slower than the threshold angular velocity to faster than the threshold angular velocity."
	output OnLessThan(void) : "Fired when the Target Entity goes from faster than the threshold angular velocity to slower than the threshold angular velocity."
	output OnLessThanOrEqualTo(void) : "Fired when the Target Entity goes from faster than the threshold angular velocity to slower than the threshold angular velocity."
	output OnEqualTo(void) : "Fired when the Target Entity reaches the threshold angular velocity from a different velocity."
]


@PointClass base(Targetname, Angles) = point_teleport : 
	"An entity that teleports a target entity to this position and angles. "+
	"If 'Teleport Home' spawn flag is set, teleports the target entity to its spawn position instead." +
	"If object is physically simulated, simulation is turned off when teleported."
[
	target(target_destination) : "Entity To Teleport" : : "Name of the entity that will be teleported."
	spawnflags(flags) =
	[
		1 : "Teleport Home" : 0
	]

	// Inputs
	input Teleport(void) : "Teleport the target entity."
]


@PointClass base(Targetname) sphere(DamageRadius) = point_hurt :
	"An entity that does damage to all entities in a radius around itself, with a specified delay." +
	"If 'Target Entity' is specified, the damage is only done to that entity."
[
	DamageTarget(string) : "Target Entity" : "" : "If specified, only this entity will take damage. Otherwise, all entities within the Radius will take damage."
	
	DamageRadius(float) : "Radius" : 256 : "All entities within this radius of this entity will take damage. If a 'Target Entity' is specified, only that entity will take damage."
	Damage(integer) : "Damage" : 5 : "Damage done to all affected entities each time this entity fires."
	DamageDelay(float) : "Delay" : 1 : "Delay between refires, in seconds."
	
	DamageType(choices) : "Damage Type" : 0 : "Type of damage to inflict on entities damaged." =
	[
		0 : "GENERIC"
		1 : "CRUSH"
		2 : "BULLET"
		4 : "SLASH"
		8 : "BURN"
		16 : "FREEZE"
		32 : "FALL"
		64 : "BLAST"
		128 : "CLUB"
		256 : "SHOCK"
		512 : "SONIC"
		1024 : "ENERGYBEAM"
		16384: "DROWN"
		32768 : "PARALYSE"
		65536 : "NERVEGAS"
		131072 : "POISON"
		262144 : "RADIATION"
		524288 : "DROWNRECOVER"
		1048576 : "CHEMICAL"
		2097152 : "SLOWBURN"
		4194304 : "SLOWFREEZE"
	]

	// Inputs
	input Hurt(void) : "Force a single fire, damaging either the Target Entity or all entities within the radius."
	input TurnOn(void) : "Enable this entity. It will start damaging entities everytime it fires, and refire based upon the specified Delay."
	input TurnOff(void) : "Disable this entity. It will stop damaging entities."
	input Toggle(void) : "Toggle this entity between On/Off state."
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) sphere(radius) = point_playermoveconstraint : 
	"An entity that constrains players to a radius around itself, slowing them down the closer they get to the edge of the radius."
[
	radius(float) : "Radius" : 256 : "Radius to constrain players to."
	width(float) : "Constraint Width" : "75.0" : "Width of the constraint edge. This is the distance in which to start slowing players down as they approach the edge of the radius."
	speedfactor(float) : "Speed Factor" : "0.15" : "Factor applied to the player's max speed as they approach the radius edge."

	// Inputs
	input TurnOn(void) : "Start constraining any players within the radius."
	input TurnOff(void) : "Stop constraining any players previously constrained."

	// Outputs
	output OnConstraintBroken(void) : "Fired when a player breaks through the constraint."
]

//-------------------------------------------------------------------------
//
//	Physics entities
//
//-------------------------------------------------------------------------
@SolidClass base(NameBase, Origin, BreakableBrush) = func_physbox : 
	"A brush entity that's physically simulated."
[

	spawnflags(flags) =
	[
		4096  : "Start Asleep (don't fall to ground)" : 0
		8192  : "Ignore +USE for Pickup" : 0
		16384 : "Debris - Don't collide with the player or other debris" : 0
		32768 : "Motion Disabled" : 0
		65536 : "Use Preferred Carry Angles" : 0
		131072: "Enable motion on Physcannon grab" : 0
		262144: "Not affected by rotor wash" : 0
		524288: "Generate output on +USE " : 1
	]
	
	Damagetype(choices) : "Impact Damage Type" : 0 =
	[
		0: "Blunt"
		1: "Sharp"
	]
	
	massScale(float) : "Mass Scale (0 = disable)" : "0.0" : "A scale multiplier for the object's mass.  Lower numbers make a lighter object."
	physdamagescale(float) : "Physics Impact Damage Scale" : "0.1" : "Scales damage energy when this object is hit by a physics object. NOTE: 0 means this feature is disabled for backwards compatibility.\nSet to 1.0 for materials as strong as flesh, smaller numbers indicate stronger materials."
	overridescript(string) : "Override Parameters" : "" : "A list of physics key/value pairs that are usually in a physics prop .qc file. Format is 'key,value,key,value,etc'."
	damagetoenablemotion(integer) : "Health Level to Override Motion" : 0 : "If specified, this object will start motion disabled. Once its health has dropped below this specified amount, it will enable motion."
	forcetoenablemotion(float) : "Physics Impact Force to Override Motion" : 0 : "If specified, this object will start motion disabled. Any impact that imparts a force greater than this value on the physbox will enable motion."
	health(integer) : "Strength" : 0 : "Number of points of damage to take before breaking.  0 means don't break."
	preferredcarryangles(vector) : "Preferred Player-carry Angles" : "0 0 0" : "If the 'Use Preferred Carry Angles' spawnflag is set, this angle is the angle which the object should orient to when the player picks it up, with the physgun or +USE."
	notsolid(choices) : "Solidity" : 0 =
	[
		0: "Solid to World"
		1: "Passes through World"
	]
	
	// Inputs
	input Wake(void) : "Wake up this physics object, if it is sleeping."
	input Sleep(void) : "Put this physics object to sleep. It will wake if given the Wake input, or if force is applied to it. Note that physics objects go to sleep automatically after coming to rest for a while, so you don't really need to use this."
	input EnableMotion(void) : "Enable physics motion/collision response."
	input DisableMotion(void) : "Disable physics motion/collision response."
	input ForceDrop(void) : "If this object is being carried by a player, with the physgun or +USE, force it to be dropped."
	input physdamagescale(float) : "Sets the Physics Impact Damage Scale."
	
	// Outputs
	output OnDamaged(void) : "Fired when this entity is damaged."
	output OnAwakened(void) : "Fired when this entity becomes awake (collision/force is applied)."
	output OnMotionEnabled(void) : "Fired when motion is enabled due to damage/physcannon/force."
	output OnPhysGunPickup(void) : "Fired when a player picks this object up, either with the physgun or +USE."
	output OnPhysGunDrop(void) : "Fired when a player drops this object."
	output OnPlayerUse(void) : "Fired when the player tries to +USE the physbox. This output will fire only if the Generate output on +USE spawnflag is set."
]


@BaseClass base(Targetname) = TwoObjectPhysics
[
	spawnflags(flags) =
	[
		1: "No Collision until break" : 0
		// 2 is defined independently by subclasses, do not reuse
		4: "Start inactive" : 0
		8: "Change mass to keep stable attachment to world" : 0
	]
	attach1(target_destination) : "Entity 1" : ""
	attach2(target_destination) : "Entity 2" : ""
	constraintsystem(target_destination) : "Constraint System Manager" : "" : "The name of a phys_constraintsystem that this constraint should be a part of. All constraints on a set of entities should be placed in the same system, or they will fight each other during simulation."

	forcelimit(float) : "Force Limit to Break (lbs)" : "0" : "The amount of force an impact must apply to the constraint to break it. A way of calculating this is to set it to the mass of an object that would break this constraint if it were resting on the constrainted objects."
	torquelimit(float) : "Torque Limit to Break (lbs * distance)" : "0" : "The amount of torque required to break the constraint. A way of calculating this is to multiply any reference mass by the resting distance (from the center of mass of the object) needed to break the constraint."
	breaksound(sound) : "Play Sound on Break" : "" : "A sound played when the constraint is broken."
	
	// Inputs
	input Break(void) : "Force the constraint to break."
	input TurnOn(void) : "Enable the constraint.  Do this when the objects don't exist when the constraint spawns - or when you have deactivated the constraint.  Broken constraints can NOT be turned on.  They have been deleted."
	input TurnOff(void) : "Disable this constraint." 

	// Outputs
	output OnBreak(void) : "Fired when the constraint breaks."
]
	
@PointClass base(Targetname) = phys_constraintsystem : 
	"An entity used to manage a group of interacting constraints and keep them stable. " +
	"All constraints on a set of entities should be placed in the same system, or they will fight each other during simulation."
[
	additionaliterations(integer) : "Additional System Iterations" : 0 : "Adding iterations makes the interactions among constraints in a system tighter.  It will not compensate for errors due to collision, but will help in cases where objects of disparate mass are constrained to each other."
]

@PointClass base(Targetname,Angles) = phys_keepupright : "A controller that tries to keep an entity facing a particular direction."
[
	spawnflags(flags) =
	[
		1: "Start inactive" : 0
	]

	attach1(target_destination) : "Target Entity" : "" : "The entity to align to the desired angles."
	angularlimit(float) : "Angular Limit" : "15" : "The maximum angular velocity that this controller can compensate for, in degrees per second."

	// Inputs
	input TurnOn(void) : "Enable the controller."
	input TurnOff(void) : "Disable the controller." 
]


@PointClass base(Targetname, Angles) sphere(expradius) studioprop() = physics_cannister : 
	"A physically simulated gas canister that can have its cap shot off, at which point gas will start escaping and cause the cannister to fly around. If it takes enough damage, it will explode."
[
	model(studio) : "World model" : "models/props_c17/canister02a.mdl"
	spawnflags(flags) = 
	[
		1 : "Start Asleep (don't fall to ground)" : 0
		2 : "Explodes" : 1
	]

	expdamage(string) : "Explosion Damage" : "200.0" : "The amount of damage done by the explosion created when the cannister blows up."
	expradius(string) : "Explosion Radius" : "250.0" : "The radius of the explosion to create when the cannister blows up."
	health(integer) : "Health" : 25 : "The amount of damage the cannister takes before exploding."

	thrust(string) : "Thrust" : "3000.0" : "When the cap has been blown off, and the escaping gas is thrusting the cannister about, this is the amount of thrust generated."
	fuel(string) : "Fuel Seconds" : "12.0" : "The amount of time that gas leaks from the cannister before being considered empty."
	rendercolor(color255) : "Smoke Color (R G B)" : "255 255 255"
	renderamt(integer) : "Smoke Alpha (0 - 255)" : 128
	gassound(sound) : "Thruster Sound" : "PhysicsCannister.ThrusterLoop" : "The sound played when the gas is escaping from the cannister."

	// input
	input Activate(string) : "Start gas escaping from the cannister."
	input Deactivate(string) : "Stop gas escaping from the cannister."
	input Explode(string) : "Force the cannister to explode."
	input Wake(void) : "Wakes up the cannister, if it is sleeping."

	// outputs
	output OnActivate(void) : "Fired when gas starts to escape from the cannister."
]

@PointClass base(Targetname, Parentname) size(-4 -4 -4, 4 4 4) = info_constraint_anchor : 
	"An entity used to attach constraints to a local position on an entity. Usually constraints will attach to the center of mass of an object. "+
	"Attach the desired constraint to this entity, and then parent this entity to the entity you want the constraint to apply to."
[
	massScale(float) : "Amount to scale the mass of this body in the constraint solver" : "1"
]

@PointClass size(-4 -4 -4, 4 4 4) = info_mass_center :
	"An entity that overrides the mass center of the target physics prop, or func_physbox, by moving it to the info_mass_center's location."
[
	target(target_destination) : "Target object" : ""  : "The entity whose mass center will be overridden."
]


@PointClass halfgridsnap base(Targetname) = phys_spring : "A physically simulated spring."+
	"'Length' is what's known as the 'natural spring length'.  This is how long the spring would "+
	"be if it was at rest (nothing hanging on it or attached).  When you attach something to the "+
	"spring, it will stretch longer than its 'natural length'.  The amount of stretch is "+
	"determined by the 'Sprint Constant'.  The larger the spring constant the less stretch the spring."
[
	spawnflags(flags) =
	[
		1 : "Force only on stretch" : 0
	]

	attach1(target_destination) : "Entity 1" : ""
	attach2(target_destination) : "Entity 2" : ""

	springaxis(vecline) : "Spring Axis" : "" : "Use the helper. Drag it out to match the virtual spring."
	length(string) : "Spring Length" : "0" : "How long the spring would be if it was at rest (nothing hanging on it or attached). 0 means the length of the brush."
	constant(string) : "Spring Constant" : "50" : "Stiffness of the spring.  The larger the number the less the spring will stretch."
	damping(string) : "Damping Constant" : "2.0" : "How much energy the spring loses.  The larger the number, the less bouncy the spring."
	relativedamping(string) : "Relative Damping Constant" : "0.1" : "The amount of energy the spring loses proportional to the relative velocity of the two objects the spring is attached to."
	// UNDONE: add max tension and what event to fire when it breaks
	breaklength(string) : "Break on Length" : "0" : "If the spring's length ever exceeds this length, the spring breaks."

	// Inputs
	input SetSpringConstant(float) : "Set the Spring Constant."
	input SetSpringLength(float)	: "Set the Spring Length."
	input SetSpringDamping(float) : "Set the Spring Damping."
]

@PointClass halfgridsnap size(-8 -8 -8, 8 8 8) base(TwoObjectPhysics) = phys_hinge : 
	"A physically simulated hinge. Use the helper to define the axis of rotation."
[
	hingefriction(float) : "Friction" : "0" : "Resistance/friction in the hinge"
	hingeaxis(vecline) : "Hinge Axis"
	SystemLoadScale(float) : "Load Scale" : "1" : "Scale of the load connected to this hinge (1=just the objects directly connected)"
	input SetAngularVelocity(float) : "Set angular velocity around the hinge (motor)"
]

@PointClass base(TwoObjectPhysics) iconsprite("editor/phys_ballsocket.vmt") = phys_ballsocket : 
	"A constraint that keeps the position of two objects fixed, relative to the constraint's origin. It does not affect rotation."
[
]

@PointClass base(TwoObjectPhysics) studioprop("models/editor/axis_helper.mdl") = phys_constraint : 
	"A constraint that keeps the relative position and orientation of two objects fixed."
[
	spawnflags(flags) =
	[
		1: "No Collision until break" : 1
	]
]

@PointClass base(TwoObjectPhysics) studioprop("models/editor/axis_helper.mdl") = phys_pulleyconstraint : 
	"A constraint that is essentially two length constraints and two points. Imagine it as a virtual rope connected to two objects, each suspended from a pulley above them."+
	"The constraint keeps the sum of the distances between the pulley points and their suspended objects constant."
[
	addlength(float) : "Additional Length" : "0" : "Add (or subtract) this amount to the rest length of the pulley rope."
	gearratio(float) : "Pulley Gear Ratio" : "1" : "Add (or subtract) this amount to the rest length of the pulley rope."
	position2(vecline) : "Pulley Position 2" : : "The position of the pulley for Entity 2. The pulley for Entity 1 is the origin of this constraint entity. Entity 1 is always suspended from pulley point 1, and Entity 2 is always suspended from pulley point 2."
	spawnflags(flags) =
	[
		1: "No Collision until break" : 1
		2: "Keep Rigid" : 0
	]
]

@PointClass halfgridsnap base(TwoObjectPhysics) studioprop("models/editor/axis_helper.mdl") = phys_slideconstraint : 
	"A constraint that constrains an entity along a line segment."
[
	spawnflags(flags) =
	[
		1: "No Collision until break" : 1
		2: "Limit Endpoints" : 0
	]
	slideaxis(vecline) : "Sliding Axis"
	slidefriction(float) : "Friction" : "0" : "Resistance/friction in the constraint"
	SystemLoadScale(float) : "Load Scale" : "1" : "Scale of the mass load connected to this constraint (1=just the objects directly connected)"
	
	// Inputs
	input SetVelocity(float) : "Set linear velocity along the constraint"
]

@PointClass base(TwoObjectPhysics) studioprop("models/editor/axis_helper.mdl") = phys_lengthconstraint : 
	"A constraint that preserves the distance between two entities. If the 'Keep Rigid' flag is set, think of it as a rod. If not, think off it as a virtual rope."
[
	addlength(float) : "Additional Length" : "0" : "Add (or subtract) this amount to the rest length of the rope."
	minlength(float) : "Minimum Length" : "0" : "If the constraint is not rigid, this is the minimum length it can be."
	attachpoint(vecline) : "Attached object 2 point" : "The position the rope attaches to object 2"
	spawnflags(flags) =
	[
		1: "No Collision until break" : 1
		2: "Keep Rigid" : 0
	]
]

@PointClass base(TwoObjectPhysics) studioprop("models/editor/axis_helper.mdl") = phys_ragdollconstraint : 
	"A constraint that fixes the position of two entities, relative to this constraint's origin. Also allows for limits on the rotation around each axis, in the space of this constraint."
[
	spawnflags(flags) =
	[
		1: "No Collision until break" : 1
		2: "Only limit rotation (free movement)" : 0
	]

	xmin(float) : "X axis min limit" : "-90" : "-180 min and 180 max = no constraint on this axis."
	xmax(float) : "X axis max limit" : "90" : "-180 min and 180 max = no constraint on this axis."
	ymin(float) : "Y axis min limit" : "0" : "-180 min and 180 max = no constraint on this axis."
	ymax(float) : "Y axis max limit" : "0" : "-180 min and 180 max = no constraint on this axis."
	zmin(float) : "Z axis min limit" : "0" : "-180 min and 180 max = no constraint on this axis."
	zmax(float) : "Z axis max limit" : "0" : "-180 min and 180 max = no constraint on this axis."
	xfriction(float) : "X axis friction" : "0"
	yfriction(float) : "Y axis friction" : "0"
	zfriction(float) : "Z axis friction" : "0"
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) color(0 0 255) = phys_convert : 
	"Turns an arbitrary entity into a physically simulated entity; i.e., brush entities will become simple physboxes, and model entities will become simple physics props."
[
	spawnflags(flags) =
	[
		1: "Convert Asleep (converted object starts asleep)" : 0
	]
	target(target_destination) : "Entity to convert" : : "Name of the entity that will be converted to a physics object when the ConvertTarget input is fired."
	swapmodel(target_destination) : "Model Swap Entity" : : "Name of an entity whose model should be used instead of the target's.  For instance, if the target is a green block and the swap model is a blue block, then upon conversion the green block will be replaced with a blue block."

	// Outputs
	output OnConvert(void) : "Fires after the conversion has taken place."

	// Inputs
	input ConvertTarget(void) : "Converts this entity's target to a physically simulated object." 
]

@BaseClass base(Targetname) = ForceController
[
	spawnflags(flags) =
	[
		// Thrust is on by default (will turn off in forcetime)
		1: "Start On" : 0
		// Apply linear force (if off, torque only)
		2: "Apply Force" : 1
		// Apply rotational force (torque - if off, linear only)
		4: "Apply Torque" : 1
		// Maintain local relationship with the attached object
		8: "Orient Locally" : 1
		// Impulse is independent of object's mass (impulse is acceleration NOT force)
		16: "Ignore Mass" : 0
	]
	attach1(target_destination) : "Attached Object" : "" : "Object to apply the force to."

	forcetime(string) : "Time of Force (0=inf)" : "0" : "Automatic shut-off after this time has passed (0 = stay on forever or until deactivated)"

	input Activate(void) : "Turn the force on"
	input Deactivate(void) : "Turn the force off"
	input Scale(string) : "Set Force Scale"
]

@PointClass base(NameBase, Parentname, Angles, ForceController) = phys_thruster : "An entity used to apply constant acceleration to a physics object. "+
	"The force and torque is calculated using the position and direction of the thruster as an impulse. So moving those off the object's center "+
	"will cause torque as well. Torque can be removed by unchecking the 'apply torque' flag. The position of the thruster can be forced to be "+
	"at the object's center by checking to 'ignore pos' flag."
[
	spawnflags(flags) =
	[
		// Put the thrust at the object center
		32: "Ignore Pos" : 0
	]
	
	force(string) : "Force" : "0" : "Force: will be integrated, units are kg*in/s^2"
]

@PointClass halfgridsnap base(NameBase, Parentname, ForceController) = phys_torque : 
	"An angular thruster. Use it to apply angular force to an entity."
[
	// Angular acceleration (units are degress/s^2)
	force(string) : "Angular Acceleration" : "0"
	axis(vecline) : "Rotation Axis" : ""
]

@PointClass base(Targetname) halfgridsnap size(-8 -8 -8, 8 8 8) = phys_motor : 
	"An entity that tries to spin a target entity at a particular speed."
[
	speed(string) : "Rotation Speed" : "0" : "Angular speed (units are degress/second)"
	spinup(string) : "Spin up time" : "1" : "spin up time in seconds (also affects the rate at which speed changes happen)"
	inertiafactor(float) : "System Interia Scale" : "1.0" : "Make this larger if the object being driven is constrained to a set of heavier objects."
	axis(vecline) : "Rotation Axis" : ""

	spawnflags(flags) =
	[
		// starts on by default
		1: "Start On" : 1
		// Disable world collisions on hinges
		2: "No world collision" : 0
		// motor also acts as a hinge constraining the object to this axis
		4: "Hinge Object" : 1
		// Maintain local relationship with the attached object (NOT WORKING YET)
//		8: "Orient Locally" : 1
	]
	attach1(target_destination) : "Attached Object" : "" : "Object to apply the force to"

	// Inputs
	input SetSpeed(float) : "Sets target speed"
	input TurnOn(void) : "Turns motor on"
	input TurnOff(void) : "Turns motor off"
]

//-------------------------------------------------------------------------
//
// Props
//
//-------------------------------------------------------------------------

@BaseClass base(Angles, DXLevelChoice, Fade) = prop_static_base
[
	model(studio) : "World Model"
	skin(integer) : "Skin" : 0 : "Some models have multiple versions of their textures, called skins. Set this to a number other than 0 to use that skin instead of the default."
	solid(choices) : "Collisions" : 6 =
	[
		0: "Not Solid"
		2: "Use Bounding Box"
		6: "Use VPhysics (model vertex data)"
	]
	disableshadows(choices) : "Disable Shadows" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]
	screenspacefade(choices) : "Screen Space Fade" : 0 : "The method by which the fading distance should be determined. If 'No', the fade distances is the distance from the player's view to the object, in units. If 'Yes', the fade distance is the size of the object onscreen, in pixels." =
	[
		0 : "No"
		1 : "Yes"
	]
	lightingorigin(target_destination) : "Lighting Origin" : "" : "Select an info_lighting to specify a location to sample lighting from, instead of using this entity's origin."
]

@BaseClass base(NameBase, Parentname, Global, Angles, Studiomodel, BreakableProp, DXLevelChoice) = prop_dynamic_base
[
	solid(choices) : "Collisions" : 6 =
	[
		0: "Not Solid"
		2: "Use Bounding Box"
		6: "Use VPhysics"
	]

	spawnflags(flags) =
	[
		64 : "Use Hitboxes for Renderbox" : 0
	]

	DefaultAnim(string) : "Default Animation" : "" : "The name of the idle animation that this prop will revert to whenever it finishes a random or forced animation."

	RandomAnimation(choices) : "Randomly Animate" : 0 : "If set, this prop will randomly choose and play animations, based upon the times specified in 'Min/Max Random Anim Time'. Inbetween the random animations, it will revert to playing the 'Default Animation'." =
	[
		0: "No"
		1: "Yes"
	]
	MinAnimTime(float) : "Min Random Anim Time" : "5" : "Minimum time between random animations."
	MaxAnimTime(float) : "Max Random Anim Time" : "10" : "Maximum time between random animations."

	// input
	input SetAnimation(string) : "Force the prop to play an animation. The parameter should be the name of the animation."
	input SetDefaultAnimation(string) : "Set the Default Animation to the one specified in the parameter."
	input TurnOn(void)	: "Make the prop visible."
	input TurnOff(void)	: "Make the prop invisible."

	// outputs
	output OnAnimationBegun(void) : "Fired whenever a new animation has begun playing."
	output OnAnimationDone(void) : "Fired whenever an animation is complete."
]


@PointClass studioprop() = prop_detail : "Detail prop.  Cannot be destroyed and cannot move (and cannot be used with a destroyable or movable model).  May not appear on low-end machines.  Prop_static is a better choice in most cases."
[
	model(studio) : "World model"
]


@PointClass base(prop_static_base, Fade) color(255 255 0) sphere(fademindist) sphere(fademaxdist) studioprop() = prop_static :
	"A prop that doesn't move and doesn't animate."
[
]


@PointClass base(prop_dynamic_base) studioprop() sphere(fademindist) sphere(fademaxdist) = prop_dynamic :
	"A prop that can be placed in hierarchy and can play animations. It can also be configured to break when it takes enough damage. "+
	"Note that the health of the object will be overridden by the health inside the model, to ensure consistent health game-wide. "+
	"If the model used by the prop is configured to be used as a prop_physics (i.e. it should be physically simulated) then it CANNOT be "+
	"used as a prop_dynamic. Upon level load it will display a warning in the console and remove itself. Use a prop_physics instead."
[
]

@PointClass base(prop_dynamic_base) studioprop() sphere(fademindist) sphere(fademaxdist) = prop_dynamic_override :
	"A prop that can be placed in hierarchy and can play animations. It can also be configured to break when it takes enough damage.\n"+
	"prop_dynamic_override is a prototyping entity only. It will allow the use of models designed to be used as prop_physics."
[
	health(integer) : "Health" : 0 : "Number of points of damage to take before breaking.  0 means don't break."	
]

@BaseClass base(NameBase, Global, Angles, Studiomodel, BreakableProp, DXLevelChoice) = BasePropPhysics
[ 
	spawnflags(flags) = 
	[
		1 : "Start Asleep (don't fall to ground)" : 0
		2 : "Don't take physical damage" : 0
		4 : "Debris (don't collide with the player or other debris, don't fire triggers)" : 0
		8 : "Motion Disabled" : 0
		64 : "Enable motion on Physcannon grab" : 0
		128 : "Not affected by rotor wash" : 0
		256 : "Generate output on +USE " : 1
		512 : "Prevent pickup" : 0
		1024: "Don't enable motion when a player bumps me" : 0
		4096: "Debris with I/O, activates trigger volumes (requires Debris)" : 0
	]
	
	minhealthdmg(integer) : "Min Damage to Hurt" : 0 : "The prop will ignore any damage events if the damage is less than this amount."
	shadowcastdist(integer) : "Shadow Cast Distance" : 0 : "Use this to override how far this object casts shadows. 0 = default distance."
	physdamagescale(float) : "Physics Impact Damage Scale" : "0.1" : "Scalar for the amount of damage this object takes from physical forces (i.e., getting hit by a toilet).  Lower numbers will decrease damage."
	Damagetype(choices) : "Impact damage type" : 0 : "Sharp objects behave like blunt objects, but they deal angular slice damage if they're rotating." =
	[
		0: "Blunt (Normal)"
		1: "Sharp"
	]

	nodamageforces(choices) : "No Damage Forces" : 0 : "Used to determine whether or not damage should cause the prop to move." =
	[
		0: "No (Enable Damage Forces)"
		1: "Yes (Disable Damage Forces)"
	]

	inertiaScale(float) : "Scale Factor For Inertia" : "1.0" : "Direct scalar for the physical inertia of the object.  Final inertia (after scaling) is clamped to >=0.5."
	massScale(float) : "Mass Scale (0 = disable)" : "0.0" : "A scale multiplier for the object's mass.  Lower numbers make a lighter object."
	overridescript(string) : "Override Parameters" : ""	: "A list of physics key/value pairs that are usually in a physics prop QC file. Format is 'key,value,key,value,etc'.  $collisionmodel and $prop_data can probably be overridden."
	damagetoenablemotion(integer) : "Health Level to Override Motion" : 0 : "If specified, this object will start motion disabled. Once its health has dropped below this specified amount, it will enable motion."
	forcetoenablemotion(float) : "Physics Impact Force to Override Motion" : 0 : "If specified, this object will start motion disabled. Any impact that imparts a force greater than this value will enable motion."

	// Inputs
	input Wake(void) : "Wake up this physics object, if it is sleeping."
	input Sleep(void) : "Put this physics object to sleep. It will wake if given the Wake input, or if force is applied to it. Note that physics objects go to sleep automatically after coming to rest for a while, so you don't really need to use this."
	input EnableMotion(void) : "Enable physics motion/collision response."
	input DisableMotion(void) : "Disable physics motion/collision response."
	input DisableFloating(void) : "Disable fluid/floating simulation to reduce cost."
	input physdamagescale(float) : "Set the Physics Impact Damage Scale for this character. NOTE: 0 means this feature is disabled for backwards compatibility."
	input EnableDamageForces(void) : "Damaging the entity applies physics forces to it."
	input DisableDamageForces(void) : "Damaging the entity does *not* apply physics forces to it."

	// Outputs
	output OnMotionEnabled(void) : "Fired when motion is enabled on this prop, either via 'Health Level to Override Motion' or from the EnableMotion input."
	output OnAwakened(void) : "Fired when this entity becomes awake (collision/force is applied to it while it's asleep)."
	output OnPlayerUse(void) : "Fired when the player tries to +USE the physbox. This output will fire only if the Generate output on +USE spawnflag is set."
	output OnPhysGunPickup(void) : "Fired when the player picks up the prop with the physcannon or +USE."
	output OnPhysGunDrop(void) : "Fired when the player drops the prop with the physcannon or USE."
]

@PointClass base(BasePropPhysics) studioprop() sphere(fademindist) sphere(fademaxdist) = prop_physics_override :
	"A prop that physically simulates as a single rigid body. It can be constrained to other physics objects using hinges "+
	"or other constraints. It can also be configured to break when it takes enough damage. Health can be overridden on this version."
[
	health(integer) : "Health" : 0 : "Number of points of damage to take before breaking.  0 means don't break."
	
	// Inputs
	input Ignite(void) : "Ignite, burst into flames."
]

@PointClass base(BasePropPhysics) studioprop() sphere(fademindist) sphere(fademaxdist) = prop_physics :
	"A prop that physically simulates as a single rigid body. It can be constrained to other physics objects using hinges "+
	"or other constraints. It can also be configured to break when it takes enough damage. "+
	"Note that the health of the object will be overridden by the health inside the model, to ensure consistent health game-wide. "+
	"If the model used by the prop is configured to be used as a prop_dynamic (i.e. it should not be physically simulated) then it CANNOT be "+
	"used as a prop_physics. Upon level load it will display a warning in the console and remove itself. Use a prop_dynamic instead."
[
	// Inputs
	input Ignite(void) : "Ignite, burst into flames."
]

@PointClass base(Targetname, Angles, Studiomodel, DXLevelChoice) studioprop() sphere(fademindist) sphere(fademaxdist) = prop_ragdoll :
	"A prop that physically simulates and can be articulated with internal joints. The joint constraints are part of the physics model."
[
	spawnflags(flags) = 
	[
		4 : "Debris - Don't collide with the player or other debris" : 1
		8192 : "Allow Dissolve" : 0
	]
	sequence(integer) : "Sequence" : : "Animation sequence to spawn the ragdoll in."
	angleOverride(string) : "Override Animation" : : "Filled in by the engine via wc_update_entity, do not edit by hand except to clear."
]

@PointClass base(prop_dynamic_base) studioprop() = prop_dynamic_ornament :
	"A way to attach one studio model to another as an ornament. It will render in the way that player/NPC weapons render."
[
	solid(choices) : "Collisions" : 0 =
	[
		0: "Not Solid"
	]

	InitialOwner(string) : "Target Entity" : : "Name of the entity that this ornament should attach to, at startup."
	
	// input
	input SetAttached(string) : "Attach the ornament to a different entity. Parameter should be the name of entity to attach to."
	input Detach(string) : "Detach from the Target Entity and become invisible. The ornament can be re-attached with the SetAttached input."
]

//
// Sky camera for 3D skybox
//

@PointClass base(Targetname, Angles) size(-16 -16 -16, 16 16 16) color(0 0 255) = sky_camera :
	"An entity used as a reference point when building a map's 3D skybox. Place a hollow cube outside of your map with the 'tools/toolsskybox' texture, place a sky_camera inside it, and place stuff (models, buildings, sprites) around the sky_camera.\n\n"+
	"Everything around the sky_camera will be drawn relative to the point (0, 0, 0) in your map--in place of sky. Anything to the east of the sky_camera will be drawn to the east of the point (0, 0, 0) on the sky, for instance, and anything suspended above the sky_camera will be suspended above (0, 0, 0) on the sky.\n\n"+
	"Sky_camera can also superimpose fog onto the models, brushes, and sprites surrounding it. This works in the same way as env_fog_controller, but obviously the distances will need to be greater, because the distance from the player to the objects in the 3D skybox will be great.\n\n"+
	"It can be difficult to figure out how large to make things in the 3D skybox, or where to place them relative to the sky_camera. An easy way to scale your skybox is to: place a sky_camera entity at the point (0, 0, 0); select some core geometry of the map (to use as references) as well as that sky_camera; "+
	"press CTRL+M and opt to scale the selection down by the reciprocal of the skybox scale, 0.0625 by default; and place this scaled-down selection within the 3D skybox."
[
	scale(integer) : "3D Skybox scale" : 16 : "Amount by which to scale what the sky_camera sees in order to create a 3D skybox."
	fogenable(choices) : "Fog Enable" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]
	fogblend(choices) : "Fog Blend" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]
	use_angles(choices) : "Use Angles for Fog Dir" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]
	fogcolor(color255) : "Primary Fog Color" : "255 255 255"
	fogcolor2(color255) : "Secondary Fog Color" : "255 255 255"
	fogdir(string) : "Primary Fog Dir" : "1 0 0"
	fogstart(string) : "Fog Start" : "500.0"
	fogend(string) : "Fog End" : "2000.0"
]

//-------------------------------------------------------------------------
//
// Solid Entities
//
//-------------------------------------------------------------------------
@SolidClass base(Targetname) color(0 255 255) = func_areaportal :
	"A portal brush used to manage visibility in maps. Portals define areas, which are spaces " +
	"that are connected in the map. Both sides of a portal cannot touch the same area, for example, a " +
	"doughnut shaped map would require at least two portals to divide the map into two areas. A linear map " +
	"could be divided into two areas with a single area portal."
[
	target(target_destination) : "Name of Linked Door" : : "(Optional) The name of a door whose open/closed state controls the on/off state of this area portal."
	StartOpen(choices) : "Initial State" : 1 =
	[
		0 : "Closed"
		1 : "Open"
	]
	PortalVersion(choices) : "Portal Version" : 1 : "Defines whether this is an old areaportal, built with tools from before the Great SDK Update, or a new one, built with newer tools." =
	[
		"" : "Old"
		1 : "New"
	]

	// Inputs
	input Open(void) : "Open the portal. When the portal is open is can be seen through."
	input Close(void) : "Close the portal. When the portal is closed it cannot be seen through."
	input Toggle(void) : "Toggle the open/closed state of the portal."
]

@SolidClass base(Targetname) color(0 128 255) sphere(FadeStartDist) sphere(FadeDist) = func_areaportalwindow : "Optimization tool.  The entity must be bordered on all sides but two by world brushes; the other two sides must touch two completely separate areas that are not connected except by another areaportal elsewhere in the map.\n\n"+
	"Create a func_brush (or some other) entity that surrounds this one and set it as the Rendered Window.  It will fade from full opacity (at distances further than the Fade End Distance) to a level of translucency defined by the Translucency Limit (at distances closer than the Fade Start Distance).\n\n"+
	"The optimization comes from the fact that nothing in the area beyond this entity will be rendered if the camera is further than Fade End Distance from it.\n\nSee also:  http://www.student.kun.nl/rvanhoorn/Optimization.htm#chapter7"
[
	target(target_destination) 	: "Rendered Window" : : "The name of a brush entity to render as the window.  It should surround and encompass the areaportalwindow."
	FadeStartDist(integer)		: "Fade Start Distance" : 128 : "When the viewer is closer than this distance, the Rendered Window's alpha is set to Translucency Limit."
	FadeDist(integer)			: "Fade End Distance"   : 512 : "When the viewer is further than this distance, the areaportalwindow prevents rendering of the area behind it."
	TranslucencyLimit(string)	: "Translucency Limit"  : "0.2" : "Alpha (opacity level) of the Rendered Window at distances less than the Fade Start Distance.  Measured as a float from 0 (invisible) to 255 (opaque)."
	BackgroundBModel(target_destination)	: "Foreground Bmodel (optional)"   : "" : "Name of an entity to use as a 'Foreground' bmodel--it's teleported to the areaportal's location at map start (but it leaves behind its clipping hulls) and is drawn regardless of camera position and fade distances."
	PortalVersion(choices) : "Portal Version" : 1 : "Defines whether this is an old areaportal, built with tools from before the Great SDK Update, or a new one, built with newer tools." =
	[
		"" : "Old"
		1 : "New"
	]
]

@SolidClass base(Targetname) color(0 255 255) = func_occluder :
	"A occluder brush used to manage dynamic visibility in maps. Occluders are used to dynamically " +
	"determine what things are behind them, to prevent trying to draw them at all."
[
	StartActive(choices) : "Initial State" : 1 =
	[
		0 : "Inactive"
		1 : "Active"
	]

	// Inputs
	input Deactivate(void) : "Deactivate the occluder, When inactive, it can be seen through."
	input Activate(void) : "Activate the occluder. When active, it cannot be seen through."
	input Toggle(void) : "Toggle the active/inactive state of the occluder."
]

@SolidClass base(BreakableBrush, Origin) = func_breakable : 
	"A brush entity that can be broken from damage, or an input." 
[
	minhealthdmg(integer) : "Min Damage to Hurt" : 0 : "The prop will ignore any damage events if the damage is less than this amount."

	physdamagescale(float) : "Physics Impact Damage Scale" : "1.0" : "Scales damage energy when this object is hit by a physics object. NOTE: 0 means this feature is disabled for backwards compatibility.\nSet to 1.0 for materials as strong as flesh, smaller numbers indicate stronger materials."
]


@SolidClass quadbounds() base(BreakableBrush) = func_breakable_surf : 
	"A breakable surface, for partially breakable glass / tile / etc.  All faces but the desired visible one must be marked as NODRAW and that" +
	" visible face must be a rectangle.  The material applied to the visible face must be set up to be breakable.  Suggested material:  'glass/glasswindowbreak070a'." 
[
	health(integer) : "Health" : 5 : "The amount of damage the surface takes before breaking."
	fragility(integer) : "Fragility" : 100 : "If the 'Surface Type' is set to Glass, this value sets how fragile the glass pieces are after the surface has been broken."
	surfacetype(choices) : "Surface Type" : 0 = 
	[
		0 : "Glass"
		1 : "Tile"
	]
	upperleft(vector) readonly : "Upper-left corner"
	upperright(vector) readonly : "Upper-right corner"
	lowerleft(vector) readonly : "Lower-left corner"
	lowerright(vector) readonly : "Lower-right corner"
	error(integer) readonly : "Error level" : : "Defined automatically by Hammer; tells HL2 whether this is a valid func_breakable_surf."

	// Inputs
	input Shatter(vector) : "Shatter the window. Input a vector. First two coordinates are the X,Y center of the shattering (as values from from 0-1). The third coordinate is the radius of the shatter, in units."
]

@SolidClass base(Targetname, Global, Parentname, Origin, RenderFields, EnableDisable) = func_brush : "A brush entity with various features." 
[
	spawnflags(flags) =
	[
		2: "Ignore player +USE" : 0
	]

	Solidity(choices) : "Solidity" : 0 : "Used to control the solidity of these brushes." =
	[
		0 : "Toggle"
		1 : "Never Solid"
		2 : "Always Solid"
	]
	excludednpc(string) : "NPC class excluded from collisions" : "" : "If an NPC classname is specified here, NPCs of that type won't collide with these brushes."
	solidbsp(choices) : "Solid BSP" : 0 : "Set this if this brush is in heirarchy with a moving object of some kind, and the player can stand on this brush." =
	[
		0 : "No"
		1 : "Yes"
	]

	input Toggle(void) : "Toggle this entity:  if it's on, turn it off, and if it's off, turn it on."
]

@SolidClass base(Targetname) = func_clip_vphysics : "A brush entity that's considered solid to vphysics." 
[
	filtername(filterclass) : "Filter Name" : : "The name of a filter entity to control which objects will collide with the func_clip_vphysics.  See also filter_activator_name."
]

@SolidClass base(Targetname, Parentname, RenderFields) = func_conveyor : 
	"Conveyor belt."
[
	movedir(angle) : "Move Direction (Pitch Yaw Roll)" : "0 0 0" : "The direction conveyor moves."
	spawnflags(flags) =
	[
		1 : "No Push" : 0
		2 : "Not Solid" : 0
	]
	speed(string) : "Conveyor Speed" : "100"

	// Inputs
	input ToggleDirection(void) : "ToggleDirection"
	input SetSpeed(integer) : "SetSpeed"
]


@SolidClass base(DXLevelChoice) color(0 180 0) = func_detail : 
	"An entity that turns its brushes into detail brushes. Detail brushes do NOT contribute to visibility in the PVS. World geometry "+
	"is not clipped to detail brushes, so if you have a small detail clump attached to a wall, the wall won't be cut up by the detail brush."+
	"func_detail is great for high-frequency brush geometry that's visual detail only. It's also ideal for reducing map VIS time."
[
]

@SolidClass base(Targetname, Parentname, RenderFields, Global) = func_guntarget :
	"This is a moving target that moves along a path of path_tracks. It can be shot and killed."
[
	speed(integer) : "Speed (units per second)" : 100 : "The speed at which the target moves along its path."
	target(target_destination) : "First stop target" : : "The name of the first path_track entity in the path that this target should follow."
	health(integer) : "Damage to Take" : 0 : "The amount of damage taken before this target is killed."

	// Inputs
	input Start(void) : "Start the target moving."
	input Stop(void) : "Stop the target from moving."
	input Toggle(void) : "Toggle the target between moving and stopped."

	// Outputs
	output OnDeath(void) : "Fires when the target is killed."
]

@SolidClass base(Targetname, Parentname, Origin, RenderFields) sphere(DisappearDist) = func_lod : "Brush that fades out over a specified distance.  Useful for creating details that don't need to be rendered from far away, improving performance."
[
	DisappearDist(float)	: "Disappear Distance" : 2000 : "The entity is always visible at distances closer than this to it.  The entity is never visible at distances further from it than this plus the CVar lod_TransitionDist.  Between the two, the entity will disappear if it's not seen or much motion is occurring."
	Solid(choices) : "Solid" : 0 : "Set whether or not these brushes should collide with other entities." =
	[
		0: "Solid"
		1: "Nonsolid"
	]
]

@SolidClass base(Targetname, Parentname) = func_precipitation : 
	"A brush entity that creates rain and snow inside its volume."
[
	renderamt(integer) : "Density (0-100%)" : 5	
	rendercolor(color255) : "Color (R G B)" : "100 100 100"
	preciptype(choices) : "Precipitation Type" : 0 =	
	[
		0 : "Rain"
		1 : "Snow"
	]
]

//-------------------------------------------------------------------------
//
// Trains and Tracks
//
//-------------------------------------------------------------------------
@BaseClass = PlatSounds 
[
	movesnd(choices) : "Move Sound" : 0 : "The sound played whenever the platform starts moving." = 
	[
		0: "No Sound"
		1: "big elev 1"
		2: "big elev 2"
		3: "tech elev 1"
		4: "tech elev 2"
		5: "tech elev 3"
		6: "freight elev 1"
		7: "freight elev 2"
		8: "heavy elev"
		9: "rack elev"
		10: "rail elev"
		11: "squeek elev"
		12: "odd elev 1"
		13: "odd elev 2"
	]
	stopsnd(choices) : "Stop Sound" : 0 : "The sound played when the platform stops moving." = 
	[
		0: "No Sound"
		1: "big elev stop1"
		2: "big elev stop2"
		3: "freight elev stop"
		4: "heavy elev stop"
		5: "rack stop"
		6: "rail stop"
		7: "squeek stop"
		8: "quick stop"
	]
	volume(string) : "Sound Volume 0.0 - 1.0" : "0.85"
]


@BaseClass base(Targetname, Parentname, RenderFields, Global, PlatSounds) = Trackchange
[
	height(integer) : "Travel Altitude" : 0 : "The vertical height above the track that the train moves. Negative values moves the train below."
	spawnflags(flags) =
	[
		1: "Auto Activate train" : 0
		2: "Relink track" : 0
		8: "Start at Bottom" : 0
		16: "Rotate Only" : 0
		64: "X Axis" : 0
		128: "Y Axis" : 0
	]
	rotation(integer) : "Spin amount" : 0 : "The amount this platform should rotate as it moves, in degrees."
	train(target_destination) : "Train to Switch"			// NEEDHELP
	toptrack(target_destination) : "Top Track"				// NEEDHELP
	bottomtrack(target_destination) : "Bottom Track"		// NEEDHELP
	speed(integer) : "Move/Rotate Speed" : 0				// NEEDHELP
]


@BaseClass base(Targetname, Parentname, Origin, RenderFields, Global) = BaseTrain
[
	spawnflags(flags) =
	[
		1 : "No Pitch (X-rot)" : 0
		2 : "No User Control" : 0
		8 : "Passable" : 0
		16 : "Fixed Orientation" : 0
		128 : "HL1 Train (use SolidBSP instead of VPhysics)" : 0
		256 : "Use max peed for pitch shifting move sound" : 0
		512 : "Is unblockable by player" : 0
	]
	
	target(target_destination) : "First Stop Target" : "" : "The name of the first path_track in the train's path. The train " +
		"will spawn at this path_track. It will also turn to face direction indicated by the 'Orientation Type' setting."
	
	startspeed(integer) : "Max Speed (units / second)" : 100 : "The maximum speed that this train can move. "+
		"Any speeds applied to this train, such as by path_tracks or SetSpeed inputs, will be clipped to this maximum value."
	
	speed(integer) : "Initial Speed (units / second)" : 0 : "The speed that the train will move at after it spawns, 0 = stopped."
	
	velocitytype(choices) : "Change Velocity" : 0 : "The method through which this train changes its velocity as it moves along the path." =
	[
		0 : "Instantaneously"
		1 : "Linear blend"
		2 : "Ease in/ease out"
	]
	
	orientationtype(choices) : "Change angles" : 1 : "The method through which this train changes its orientation as it moves along the path." =
	[
		0 : "Never (fixed orientation)"
		1 : "Near path_tracks"
		2 : "Linear blend"
		3 : "Ease in/ease out"
	]
	
	wheels(integer) : "Distance Between the Wheels" : 50 : "Used for turning and stopping."
	height(integer) : "Height above track" : 4 : "The height above the track that this train moves."
	bank(string) : "Bank Angle on Turns" : "0"			// NEEDHELP
	
	dmg(integer) : "Damage on Crush" : 0 : "The amount of damage this train does to entities that block it."
	


	MoveSound(sound) : "Move Sound" : "" : "A sound that is played (and looped) while the train is moving."
	MovePingSound(sound) : "Move Ping Sound" : "" : "A sound that is played more frequently as the train speeds up."
	StartSound(sound) : "Start Sound" : "" : "A sound played when the train starts moving."
	StopSound(sound) : "Stop Sound" : "" : "A sound played when the train stops moving."
	volume(integer) : "Volume (10 = loudest)" : 10
	MoveSoundMinPitch(integer) : "Min pitch (1-255, > 100 = higher)" : 60 : "The sound pitch value that the train will approach as it comes to a stop."
	MoveSoundMaxPitch(integer) : "Max pitch (1-255, > 100 = higher)" : 200 : "The sound pitch value that the train will approach as it approaches its "+
		"max speed (or 1000 units/second if the 'Use max speed for pitch shifting move sound' flag is not set)."
	MoveSoundMinTime(float) : "Min move sound interval" : 0 : "Minimum interval at which to play the move ping sound."
	MoveSoundMaxTime(float) : "Max move sound interval" : 0 : "Maximum interval at which to play the move ping sound."

	// Inputs
	input SetSpeed(float) : "Set the speed of the train, as a ratio of max speed [0, 1]"
	input SetSpeedDir(float) : "Set the speed of the train, as a ratio of max speed. Negative values reverse the direction [-1, 1]"
	input SetSpeedReal(float) : "Set the speed of the train. Must be a positive value from 0 to max speed."
	input Stop(void) : "Stop the train."
	input StartForward(void) : "Start the train moving forward."
	input StartBackward(void) : "Start the train moving backward."
	input Resume(void) : "Resume the train moving in the current direction after it was stopped via the 'Stop' or 'Toggle' input."
	input Reverse(void) : "Reverse the direction of the train."
	input Toggle(void) : "Toggle the train between start and stop."
]


@SolidClass base(Trackchange) = func_trackautochange : 
	"An entity that works as a rotating/moving platform that will carry a train to a new track. "+
	"It must be larger in X-Y planar area than the train, since it must contain the train within "+
	"these dimensions in order to operate when the train is near it."
[

	// Inputs
	input Trigger(void) : "Trigger the track change."
]


@SolidClass base(Trackchange) = func_trackchange : 
	"An entity that works as a rotating/moving platform that will carry a train to a new track. "+
	"It must be larger in X-Y planar area than the train, since it must contain the train within "+
	"these dimensions in order to operate when the train is near it."
[

]


@SolidClass base(BaseTrain) = func_tracktrain :
	"A moving platform that the player can ride. It follows a path of path_track entities.\n" +
	"NOTE: Build your train so that the front of the train is facing down the X axis. " +
	"When it spawns it will automatically rotate to face the next path_track on the path."
[
]


@SolidClass base(BaseTrain) = func_tanktrain :
	"A moving train that follows a path of path_track entities, shoots at the player, and can be killed.\n" + 
	"NOTE: Build your train so that the front of the train is facing down the X axis. " +
	"When it spawns it will automatically rotate to face the next path_track on the path."
[
	health(integer) : "Health" : 100
	
	// Outputs
	output OnDeath(void) : "Fired when the tank is killed."
]


@SolidClass base(Parentname,Global) = func_traincontrols :
	"When used by the player, this entity overrides the player's controls to let them drive a train."
[
	target(target_destination) : "Train Name" : : "The target train to control when the player uses these controls."
]


@PointClass base(Targetname) iconsprite("editor/tanktrain_aitarget.vmt") = tanktrain_aitarget : 
	"An entity that changes the target of a tanktrain_ai entity."
[
	target(target_destination) : "Tank AI Entity" : : "The tanktrain_ai entity to change the target of."
	newtarget(target_destination) : "New Target Entity" : : "The entity to tell the tanktrain_ai to target."
]


@PointClass base(Targetname) iconsprite("editor/tanktrain_ai.vmt") = tanktrain_ai : 
	"Train chase AI"			// NEEDHELP
[
	target(target_destination) : "Train Name"
	startsound(sound) : "Start Moving Sound" : "vehicles/diesel_start1.wav"
	enginesound(sound) : "Engine Loop Sound" : "vehicles/diesel_turbo_loop1.wav"
	movementsound(sound) : "Vehicle Movement Sound" : "vehicles/tank_treads_loop1.wav"
]

@PointClass base(Targetname, Parentname, Angles) cylinder(255 255 255, targetname, target, radius, targetname, targetname, radius) line(64 64 128, targetname, altpath) color(255 192 0) size(16 16 16) = path_track : 
	"An entity used to build paths for other entities to follow. Each path_track is a node on the path, each holding the name of the next path_track in the path."
[
	spawnflags(Flags) =
	[
		1:  "Disabled" : 0
		//2:  "Fire once" : 0
		4:  "Branch Reverse" : 0
		8:  "Disable train" : 0
		16: "Teleport to THIS path track" : 0
	]
	
	target(target_destination) : "Next Stop Target" : : "The next path_track in the path."
	altpath(target_destination) : "Branch Path" : : "An alternative path_track to be the next node in the path. Useful for making branching paths. Use the ToggleAlternatePath / EnableAlternatePath inputs to make the alternative path active."
	speed(float) : "New Train Speed" : 0 : "When the train reaches this path_track, it will set its speed to this speed. "+
		"This speed must be a positive value that is less than the train's max speed. A value of 0 will cause no change in the train's speed."
	radius(float) : "Path radius" : 0 : "Used by NPCs who follow track paths (attack chopper/gunship). This tells them the maximum distance they're allowed to be from the path at this node."

	orientationtype(choices) : "Orientation Type" : 1 : "The way that the path follower faces as it moves through this path track." =
	[
	//	0 : "No change"
		1 : "Face direction of motion"
		2 : "Face this path_track's angles"
	]

	// Inputs
	input ToggleAlternatePath(void) : "Cause the track to toggle to/from its alternate path."
	input EnableAlternatePath(void) : "Enable the alternate path of the track."
	input DisableAlternatePath(void) : "Disable the alternate path of the track."

	input TogglePath(void) : "Cause the track to toggle on/off."
	input EnablePath(void) : "Enable the track."
	input DisablePath(void) : "Disable the track."

	// Outputs
	output OnPass(void) : "Fired when any entity following this path passes this path_track node."
]

//-------------------------------------------------------------------------
//
// Triggers
//
//-------------------------------------------------------------------------
@SolidClass base(Trigger) = trigger_autosave : 
	"A trigger volume that autosaves when the player touches it."
[
//	master(string) : "Master" : : "Legacy support: The name of a master entity. If the master hasn't been activated, this entity will not activate."
	NewLevelUnit(choices) : "Force New Level Unit" : 0 : "If set, the save will discard any savedata from previous levels, for the purpose of keeping savegame filesizes down. Can only be safely used if there is no way for the player to return to previous levels." =
	[
		0 : "No"
		1 : "Yes"
	]
]

@SolidClass base(Trigger) = trigger_changelevel : 
	"An entity that triggers a level change.\n" +
	"Place an info_landmark in both maps that marks the 'same' location in each map.\n"+
	"TIPS & TRICKS: To fire events in the next level, use the OnLevelChange output to turn on "+
	"an env_global in the current level.  Create an auto_trigger in the next level that checks "+
	"for the state set by the env_global.\n\n"+
	"To control which entities go through the level transition, create one or more trigger_transitions and "+
	"give them the same name as the landmark. Any entities within the trigger_transition(s) will go to the next map."
[
	map(string) : "New Map Name"
	landmark(target_destination) : "Landmark Name"
	spawnflags(flags) =
	[
		2: "Disable Touch" : 0
		4: "To Previous Chapter" : 0
	]
	
	// Inputs
	input ChangeLevel(void) : "Cause the level change. Use this when triggering the level change with a button, etc."
	
	// Outputs
	output OnChangeLevel(void) : "Fired when the level changes."
]


@SolidClass base(Trigger) = trigger_gravity : 
	"A trigger volume that changes the gravity on any entity that touches it."
[
	gravity(integer) : "Gravity (0-1)" : 1
]


@SolidClass base(Trigger) = trigger_playermovement : 
	"An entity that can be used to disable player's automatic ducking/unducking when jumping."
[
	spawnflags(flags) = 
	[
		128: "Disable auto player movement" : 1
	]
]

// NEEDHELP
@SolidClass base(Trigger) = trigger_soundscape : "Soundscape trigger." +
	"It is not necessary to create outputs for this trigger. It automatically will trigger the " +
	"soundscape referred to by its 'Soundscape' property."
[
	soundscape(target_source) : "Soundscape" 
]


@SolidClass base(Trigger) = trigger_hurt : 
	"A trigger volume that damages entities that touch it."
[
//	master(string) : "Master (Obsolete)" : : "Legacy support: The name of a master entity. If the master hasn't been activated, this entity will not activate."
	damage(integer) : "Damage" : 10 : "The amount of damage done to entities that touch this trigger. The damage is done every half-second. See also 'Damage Model' for extra details on how damage can be dealt."
	damagecap(integer) : "Damage Cap" : 20 : "Maximum damage dealt per second. This field is only used if you select the Doubling w/Forgiveness damage model, via the spawnflag."
	damagetype(choices) : "Damage Type" : 0 =
	[
		0 : "GENERIC"
		1 : "CRUSH"
		2 : "BULLET"
		4 : "SLASH"
		8 : "BURN"
		16 : "FREEZE"
		32 : "FALL"
		64 : "BLAST"
		128 : "CLUB"
		256 : "SHOCK"
		512 : "SONIC"
		1024 : "ENERGYBEAM"
		16384: "DROWN"
		32768 : "PARALYSE"
		65536 : "NERVEGAS"
		131072 : "POISON"
		262144 : "RADIATION"
		524288 : "DROWNRECOVER"
		1048576 : "CHEMICAL"
		2097152 : "SLOWBURN"
		4194304 : "SLOWFREEZE"
	]

	damagemodel(choices) : "Damage Model" : 0 : "How damage is dealt. Normal always does the specified amount of damage each half second. Doubling starts with the specified amount and doubles it each time it hurts the toucher. Forgiveness means that if the toucher gets out of the trigger the damage will reset to the specified value. Good for making triggers that are deadly over time without having to cause massive damage on each touch." =
	[
		0 : "Normal"
		1 : "Doubling w/forgiveness"
	]
	
	// Inputs
	input SetDamage(float) : "Set a new amount of damage for this trigger."
	
	// Outputs
	output OnHurt(void) : "Fired whenever this trigger hurts something other than a player."
	output OnHurtPlayer(void) : "Fired whenever this trigger hurts a player."
]

@SolidClass base(Trigger) = trigger_remove : 
	"A trigger volume that removes any entities that touch it. Be careful, removing some entities can cause instability. "+
	"This is not the same as killing entities. i.e. NPCs removed in this manner will not fire their OnKilled outputs."
[
	// Outputs
	output OnRemove(void) : "Fired whenever an entity is removed."
]

@SolidClass base(Trigger) = trigger_multiple :
	"A trigger volume that can be triggered multiple times."
[
	wait(integer) : "Delay Before Reset" : 1 : "Amount of time, in seconds, after the trigger_multiple has triggered before it can be triggered again. If set to -1, it will never trigger again."
	 
	// Outputs
	output OnTrigger(void) : "Fired whenever the trigger is activated."
]

@SolidClass base(Trigger) = trigger_look :
	"An entity used to trigger something when the player looks at something. It fires 'OnTrigger' when the player "+
	"looks at a target entity for the given amount of time, while within the trigger volume.  If the player leaves "+
	"the trigger or looks away from the target entity the clock resets. If the 'Use Velocity instead of facing' spawnflag " +
	"is checked, the trigger uses the player's velocity instead of the player's view, so it determines whenever the player "+
	"is moving toward the target entity. Useful for triggering when players are driving a vehicle at something."+
	"NOTE: Only designed for single-player game. "
[
	spawnflags(flags) = 
	[ 
		128: "Fire Once" : 1 
		256: "Use Velocity instead of facing" : 0
	]
	
	target(target_destination)			: "Look Target" : : "The name of the entity to be looked at."
	LookTime(string)					: "LookTime"	: "0.5" : "The time, in seconds, that the player must look the target before firing the output. Resets if player leaves trigger, or looks outside the Field of View threshold."
	FieldOfView(string)					: "FieldOfView"		: "0.9" : "How close the player has to be looking at the target. 1.0 = straight ahead\n 0.0 = +/- 90 degrees\n -1.0 = all directions)."
	Timeout(float)						: "Timeout" : "0" : "The time, in seconds, to wait after player enters the trigger before firing the OnTimeout output, 0 = never."

	// Output
	output OnTrigger(void) : "Fired when the trigger is activated."
	output OnTimeout(void) : "Fired after the timeout interval expires if the player never looked at the target."
]

@SolidClass base(Trigger) = trigger_push : 
	"A trigger volume that pushes entities that touch it."
[
	pushdir(angle) : "Push Direction (Pitch Yaw Roll)" : "0 0 0" : "Angles indicating the direction to push touched entities."

	spawnflags(flags) = 
	[ 
		128: "Once Only" : 0
		256: "Affects Ladders(hl2)" : 0 
	]
	
	speed(integer) : "Speed of Push" : 40 : "The speed at which to push entities away, in units / second."
]


@SolidClass base(Trigger,Angles) = trigger_wind : 
	"A trigger volume that pushes physics objects that touch it."
[
	Speed(integer)			: "Speed"			: 200   : "The base line for how hard the wind blows."
	SpeedNoise(integer)		: "Speed Noise"		: 0		: "Noise added to wind speed +/-"
	DirectionNoise(integer) : "Direction Noise" : 10	: "Noise added to wind direction."
	HoldTime(integer)		: "Hold Time"		: 0		: "Base line for how long to wait before changing wind."
	HoldNoise(integer)		: "Hold Noise"		: 0		: "Noise added to how long to wait before changing wind."

	// Inputs
	input SetSpeed(integer)	: "Set the base line for how hard the wind blows."
]


@SolidClass base(Targetname, Angles) = trigger_impact : 
	"A trigger volume that can be told to push all physics objects that are inside of it in the direction specified by this trigger's angles.\n"+
	"Also outputs the force at the time of impact for anyone else that wants to use it."
[
	Magnitude(float)		: "Magnitude"	: 200    : "The strength of the impact. Negative values reverse the direction."
	noise(float)			: "Noise"		: "0.1"	 : "The amount of directional noise (0-1). 0 = no noise, 1 = random direction."
	viewkick(float)			: "Viewkick"	: "0.05" : "The amount to kick player's view if the player is in the trigger.  Proportional to magnitude (0-1)."

	// Inputs
	input Impact(float) : "Fire the impact, pushing all entities within the volume."
	input SetMagnitude(float)	: "Set the magnitude of the impact."

	// Outputs
	output ImpactForce(string)		: "Fired after an impact. The parameter passed along is the force of the impact that was generated."
]


@SolidClass base(Trigger) = trigger_proximity :
	"Measures the distance of the player within the trigger volume from a given point (and within " +
	"a given radius). The NearestPlayerDistance output will be 0 when the player is at the center point, " +
	"and 1 when the player is at the radius."
[
	measuretarget(target_destination) : "Point to Measure From" : : "The name of a target entity who's origin is the point to measure the player's distance from."
	radius(string) : "Radius to measure within" : 256 : "The radius to which the distance should be mapped. If the player is outside the radius he will be ignored."
	
	// Outputs
	output NearestEntityDistance(integer) : "Fired continuously when entities are touching the trigger volume. The output parameter is the distance from the "+
		"Point to Measure From to the nearest entity that passed the trigger filters. The distance is mapped to the radius distance, so it will be 0 when the "+
		"entity is on the point, and 1 when the entity is at the edge of the radius."
]


@SolidClass base(Trigger) = trigger_teleport : 
	"A trigger volume that teleports entities that touch it. Entities are teleported to the Remote Destination, and have their angles "+
	"set to that of the Remote Destination's. If a Local Destination Landmark is specified, teleported entities are offset from the target by their initial offset "+
	"from the landmark, and their angles are left alone."
[
	target(target_destination) : "Remote Destination" : : "The entity (usually info_target) specifying the point to which entities should be teleported."
	landmark(target_destination) : "Local Destination Landmark" : : "If specified, then teleported entities are offset from the target by their initial offset from the landmark."
	spawnflags(flags) =
	[
		32: "Preserve angles even when a local landmark is not specified" : 0
	]
]


@SolidClass base(Targetname) = trigger_transition : 
	"A volume that's used to control which entities go through the level transition. Create one or more trigger_transitions and "+
	"give them the same name as the changelevel landmark. Any entities within the trigger_transition(s) will go to the next map."+
	"See trigger_changelevel for more info."
[
]

@SolidClass base(Trigger) = trigger_waterydeath: 
	"A trigger volume that spawns leeches around entities inside it, and does damage to them until they die. Used to prevent players entering deep water."
[
]

@PointClass base(Targetname, Parentname, Angles, Studiomodel) studioprop() = phys_magnet : 
	"An entity that acts like a magnet, attaching metallic physics objects to itself when they touch it.\n\n"+
	"DO NOT allow a magnet with the 'Coast jeep pickup hack' flag checked to touch the world, a player, or an important object."
[
	spawnflags(flags) =
	[
		1 : "Start Asleep (don't fall to ground)" : 0
		2 : "Motion Disabled" : 0
		4 : "Suck On Touch (attract metal when touched by anything)" : 0
		8 : "Allow Attached Rotation (let metal objects on the magnet rotate)" : 0
		16: "Coast jeep pickup hack (remove all touched objects except prop_vehicle_jeep)" : 0
	]

	forcelimit(float) : "Force Limit to Break (lbs)" : "0" : "The amount of force necessary to break a stuck object off the magnet. A way of calculating this is to set it to the mass of an object that would break this constraint if it were resting on the magnet."
	torquelimit(float) : "Torque Limit to Break (lbs * distance)" : "0" : "The amount of torque necessary to break a stuck object off the magnet. A way of calculating this is to multiply any reference mass by the resting distance (from the center of mass of the object) needed to break the constraint."

	massScale(float) : "Mass Scale (0 = disable)" : "0.0" : "A scale multiplier for the object's mass.  Lower numbers make a lighter ball."
	overridescript(string) : "Override parameters" : "" : "A list of physics key/value pairs that are usually in a physics prop .qc file. Format is 'key,value,key,value,etc'."
	maxobjects(integer) : "Maximum Attached Objects" : 0 : "The maximum number of physics objects that can be stuck to the magnet at once. 0 = no limit."

	// Inputs
	input TurnOn(void) : "Turn the magnet on."
	input TurnOff(void) : "The the magnet off. This will detach anything current stuck to the magnet."

	// Outputs
	output OnAttach(void)	: "Fired when an entity is grabbed by the magnet."
	output OnDetach(void)	: "Fired when an entity is released by the magnet."
]

@PointClass base(Targetname, Parentname) size(-8 -8 -8, 8 8 8 ) = material_modify_control : 
	"An entity that can be used to directly control material vars. To use it, you need to read the .vmt of the material you "+
	"intend to change. Parent this entity to a brush model entity who's material you want to control."
[
	materialName(string) : "Material to modify."
	materialVar(string) : "Material variable to modify."

	// Input
	input SetMaterialVar(string) : "Fire to modify a material variable. The argument is the value to set the variable to."
	input SetMaterialVarToCurrentTime(void) : "This sets the material variable to the current time on the server."
] 

//-------------------------------------------------------------------------
//
// AI
//
//-------------------------------------------------------------------------
@PointClass base(Targetname,ResponseContext) = ai_speechfilter : 
	"An entity that can be used to control the idle speech patterns of a set of NPCs."
[
	subject(target_destination) : "Subject(s)" : "" : "This is the NPC(s) whose speech we're filtering. May be a targetname or a classname."	

	IdleModifier(float) : "Idle modifier." : "1.0" : "Multiplier to the percentage chance that our NPC(s) will idle speak. Set to 0 to prevent all idle speech."
	NeverSayHello(choices) : "Greet Player?" : 0 : "If set to Yes, our NPC(s) won't greet the player when they first meet him." =
	[
		0 : "Yes"
		1 : "No"
	]
]

//-------------------------------------------------------------------------
// Water LOD control
//-------------------------------------------------------------------------

@PointClass base(Targetname) iconsprite("editor/waterlodcontrol.vmt") = water_lod_control : 
	"An entity used to control the LOD behavior of any water in the map. If your map has water, this entity is required."
[
	cheapwaterstartdistance(float) : "Start Transition to Cheap Water" : 1000 : "This is the distance from the camera that water will start transitioning to cheap water, in units."
	cheapwaterenddistance(float) : "End Transition to Cheap Water" : 2000 : "This is the distance from the camera that water will finish transitioning to cheap water, in units."

	// Inputs
	input SetCheapWaterStartDistance(float) : "Set the distance that water starts transitioning to cheap water."
	input SetCheapWaterEndDistance(float) : "Set the distance that water finishes transitioning to cheap water."
]

//-------------------------------------------------------------------------
// Used to allow entities to mimic the motions of other entities
//-------------------------------------------------------------------------

@PointClass base(Targetname) = logic_measure_movement :
	"An entity that can measure the movement of an entity relative to another entity " +
	"and apply that movement to a third entity."
[
	MeasureTarget(target_destination) : "Entity to Measure" : "" : "Entity whose movement you want to measure."
	MeasureReference(target_destination) : "Measure Reference" : "" : "The movement of Entity to Measure will be measured relative to this entity."
	Target(target_destination) : "Entity to Move" : "" : "This entity will be moved to mimic the motions of Entity to Measure."
	TargetReference(target_destination) : "Movement Reference" : "" : "The Entity to Move will move relative to this entity."
	TargetScale(float) : "Movement scale" : "1" : "A scale to divide the measured movements by, before applying those movements to the Entity to Move. 1 = target entity moves as much as the measured entity, 2 = target entity moves half as far as the measured entity, and 0.5 = target entity moves twice as far as the measured entity."
	MeasureType(choices) : "Measurement Type" : 0 =
	[
		0 : "Position"
		1 : "Eye position"
	]
	
	// Inputs
	input SetMeasureTarget(string)	: "Set the Entity to Measure, whose movement should be measured."
	input SetMeasureReference(string) : "Set the Measure Reference entity."
	input Target(string) : "Set the Entity to Move, which will be moved to mimic the measured entity."
	input SetTargetReference(string) : "Set the Movement Reference entity."
	input SetTargetScale(float)		: "Set the scale to divide the measured movements by."
	input Enable(void)				: "Enable the logic_measure_movement."
	input Disable(void)				: "Disable the logic_measure_movement."
]

@PointClass base(BaseNPC) studioprop() = npc_furniture : 
	"An entity used for non-NPCs that need to synchronise their animation with an NPC in a scripted_sequence. Usually a piece "+
	"of furniture or door that an NPC needs to manipulate within a scripted_sequence."
[
	model(studio) : "Model"
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = env_credits : "An entity to control the rolling credits."
[
	// Inputs
	input RollCredits(void)				: "Start the intro credits rolling."
	input RollOutroCredits(void)		: "Start the outro credits rolling."
	input ShowLogo(void)				: "Show the HL2 logo."
	
	// Outputs
	output OnCreditsDone(void) 			: "Fired when the credits having finished rolling."
]

//-------------------------------------------------------------------------
//
// Camera/monitor entities
//
//-------------------------------------------------------------------------
@PointClass base(Targetname, Parentname, Angles) studioprop("models/editor/camera.mdl") = point_camera : "Camera.  Everything it sees can be displayed on brush-based entities "+
	"in the map that use a monitor texture.  Place this camera and a func_monitor block with at least one monitor-textured face, and specify this camera within the func_monitor's "+
	"properties.  You can also use an info_camera_link entity to display this point_camera's view on entities besides func_monitor."
[
	spawnflags(Flags) =
	[
		1 : "Start Off" : 0 
	]

	FOV(float) : "FOV" : 90 : "Field of view in degrees.  Lower numbers zoom in; higher numbers zoom out."
//	resolution(float) : "Resolution" : 256 : "Quality with which to sample view for entities that reference the point_camera."
	UseScreenAspectRatio(choices) : "Screen Aspect Ratio" : 0 : "Is the monitor entity's width different from its height?" =
	[
		0 : "No"
		1 : "Yes"
	]	
	fogEnable(choices) : "Fog Enable" : 0 : "Superimposes fog onto the camera's view before passing it along to entities referencing the camera." =
	[
		0 : "No"
		1 : "Yes"
	]	
	fogColor(color255) : "Fog Color" : "0 0 0"
	fogStart(float) : "Fog Start" : 2048 : "The near fog plane."
	fogEnd(float) : "Fog End" : 4096 : "The far fog/clipping plane."

	input ChangeFOV(string) : "Changes camera's FOV over time"
	input SetOnAndTurnOthersOff(void) : "Turn the camera on, and turn all other cameras off."
	input SetOn(void) : "Turn the camera on."
	input SetOff(void) : "Turn the camera off."
]

@PointClass base(Targetname) = info_camera_link :
	"An entity that ties a point_camera to brush entities other than func_monitor.  The entity must have at least one face textured with a valid monitor texture, like dev/tvmonitor1a.  "+
	"Note that you aren't allowed to have one monitor visible to another; if you use multiple monitors, make sure they're in leaves that can't see each other!"
[
	target(target_destination) : "Entity with monitor face" : : "The name of the brush entity whose monitor faces should display what the point_camera sees."
	PointCamera(target_destination) : "Camera name" : : "The name of a point_camera entity in the map that should be tied to the entity above."
	
	// Inputs
	input SetCamera(string) : "Set the camera to use."
]

@SolidClass base(func_brush) = func_monitor :
	"A monitor that renders the view from a given point_camera entity.  Must use a monitor texture, like dev/tvmonitor1a.  Note that you aren't allowed to have one monitor visible to another; "+
	"if you use multiple monitors, make sure they're in leaves that can't see each other!"
[
	target(target_destination) : "Camera name" : : "Name of the point_camera whose view should be rendered on the monitor faces."
	
	// Inputs
	input SetCamera(string) : "Sets the camera to use for this monitor. Takes the name of a point_camera entity in the map."
]

@PointClass base(Angles) studioprop("models/editor/camera.mdl") = point_devshot_camera : 
	"An entity used by the -makedevshots system, which automatically takes screenshots at the position of every devshot camera in the level."
[
	cameraname(string) : "Camera Name" : "" : "Used as the name of the directory to store screenshots from this camera. Must be unique within the level."
	FOV(integer) : "Camera FOV" : 75 : "FOV of this camera."
]

//-------------------------------------------------------------------------
//
// NPCs
//
//-------------------------------------------------------------------------
@BaseClass base(BaseNPC) = TalkNPC
[
	UseSentence(string) : "Use Sentence"
	UnUseSentence(string) : "Un-Use Sentence"
]

@BaseClass base(BaseNPC ) = RappelNPC
[
	waitingtorappel(choices) : "Waiting to Rappel?" : "No" : "If yes, this NPC spawns suspended in air and awaits a BeginRappel input. It will then spawn a zipline and slide down. When it hits the ground, NPC will cut away the line and try to move forward a few feet to make room for the next NPC. The NPC will not attempt to clear its landing space if it cannot do so by taking a few steps forward" =
	[
		0 : "No"
		1 : "Yes"
	]

	// Inputs
	input BeginRappel(void) : "BeginRappel"

	// Outputs
	output OnRappelTouchdown(void) : "Fires when done rappeling"
]

@PointClass base(BasePropPhysics) studioprop() = prop_combine_ball :
	"A prop that physically simulates as a single rigid body. It can be constrained to other physics objects using hinges "+
	"or other constraints. It can also be configured to break when it takes enough damage."
[
	// Inputs
	input Explode(void) : "Explode"
]

@SolidClass base(Trigger, Angles) = trigger_physics_trap :
	"A volumetric trigger that disintegrates enemies"
[
	dissolvetype(choices) : "Dissolve Type" : "Energy" =
	[
		0 : "Energy"
		1 : "Heavy electrical"
		2 : "Light electrical"
	]
]

@SolidClass base(Trigger) = trigger_weapon_dissolve :
	"A volumetric trigger that dissolves all weapons within it"
[
	emittername(target_destination) : "Emitter Name" : "" : "Name of a single or multiple entities to use as the basis for the emitted effects."

	// Outputs
	output OnDissolveWeapon(void) : "Fires when one weapon is starting to dissolve in the trigger volume."
	output OnChargingPhyscannon(void) : "Fires when the trigger begins to charge the physcannon."

	// Inputs
	input StopSound(void) : "Stops all sounds."
]

@SolidClass base(Trigger) = trigger_weapon_strip :
	"A volumetric trigger that strips combat characters of all weapons"
[
	KillWeapons(choices) : "Kill Weapons" : "No" =
	[
		0 : "No"
		1 : "Yes"
	]
]

@SolidClass base(Targetname, Origin, Angles, Global) = func_combine_ball_spawner :
	"A volumetric trigger that bestows super armor to the player"
[
	spawnflags(Flags) = 
	[
		4096 : "Start inactive" : 1
		8192 : "Combine power supply" : 0
	]

	ballcount(integer) : "Ball count" : 3 : "This is how many balls will be bouncing around inside the spawner"
	minspeed(float) : "Min ball speed" : "300.0" : "The minimum speed of balls that fly in the spawner"
	maxspeed(float) : "Max ball speed" : "600.0" : "The maximum speed of balls that fly in the spawner"
	ballradius(float) : "Ball radius" : "20.0" : "The radius of the energy balls"
	balltype(choices) : "Ball Type" : "Combine Energy Ball 1" =
	[
		0 : "Combine Energy Ball 1"
		1 : "Combine Energy Ball 2"
		2 : "Combine Energy Ball 3"
	]
	ballrespawntime(float) : "Ball Respawn Time" : "4.0f" : "The energy balls respawn time"

	input Enable(void) : "Enable spawning of combine balls"
	input Disable(void) : "Disable spawning of combine balls"

	output OnBallGrabbed(void) : "Fired when a combine ball is grabbed from the field by a mega physcannon"
	output OnBallReinserted(void) : "Fired when a combine ball is reinserted into the field (only gets triggered when Combine Power supply is checked)"
	output OnBallHitTopSide(void) : "Fired when a combine ball in hits the top side of the field (only gets triggered when Combine Power supply is checked)"
	output OnBallHitBottomSide(void) : "Fired when a combine ball in hits the bottom side of the field (only gets triggered when Combine Power supply is checked)"
	output OnLastBallGrabbed(void) : "Fired when the last combine ball is grabbed from the field by a mega physcannon"
	output OnFirstBallReinserted(void) : "Fired when the first combine ball is reinserted into the field (only gets triggered when Combine Power supply is checked)"
]

@NPCClass base(BaseNPC) sphere(innerradius) sphere(outerradius) studioprop("models/combine_camera/combine_camera.mdl") = npc_combine_camera :
	"Combine security camera"
[
	spawnflags(Flags) = 
	[
		32 : "Always Become Angry On New Enemy" : 1
		64 : "Ignore Enemies (Scripted Targets Only)" : 0
		128 : "Start Inactive" : 0
	]
	
	innerradius(integer) : "Inner radius" : 300 : "The camera will only lock onto enemies that are within the inner radius."
	outerradius(integer) : "Outer radius" : 450 : "The camera will flash amber when enemies are within the outer radius, but outside the inner radius."

	minhealthdmg(integer) : "Min req'd damage for hurting camera" : 0
	defaulttarget(target_destination) : "Default target" : "" : "The default target is the entity that the camera follows when it has no other target to track."

	// Inputs
	input Disable(void) : "Disables the camera. If open, the camera closes."
	input Enable(void) : "Enables the camera. If closed, the camera opens."
	input Toggle(void) : "Toggle - If open, close. If closed, open."
	input SetDefaultTargetEntity(string) : "Sets the entity for the camera to track when it has nothing better to track, by name."
	input SetTargetEntity(string) : "Sets the entity for the camera to track now, by name."
	input SetAngry(void) : "Causes the camera to become angry as if it has seen something upsetting."
	input SetIdle(void) : "Causes the camera to calm down if it is angry."
	
	output OnFoundPlayer(string) : "Fired when the player is spotted within the inner radius"
	output OnFoundEnemy(void) : "Fired when a non-player enemy is spotted within the inner radius."
]


@PointClass base(BaseNPC, Parentname ) studioprop( "models/combine_turrets/ground_turret.mdl" ) = npc_turret_ground : "Combine ground turret"
[
	input Enable(void)		: "Turn turret on."
	input Disable(void)		: "Turn turret off."

	output OnAreaClear(void)	: "Fires when the turret can't find any more enemies (7 second delay)"
]

@PointClass base(Targetname, Angles, Studiomodel) studioprop( "models/combine_turrets/ceiling_turret.mdl" ) = npc_turret_ceiling : "Combine Ceiling Turret"
[
	spawnflags(Flags) = 
	[
		32 : "Autostart" : 1
		64 : "Start Inactive" : 0
		128 : "Never Retire" : 0
	]

	minhealthdmg(integer) : "Min req'd damage for hurting turret" : 0		

	// Inputs
	input Enable(void)		: "If closed, open."
	input Disable(void)		: "If open, close."
	input Toggle(void)		: "Toggle - If open, close. If closed, open."

	// Outputs
	output OnDeploy(void)	: "Turret is becoming active and dangerous."
	output OnRetire(void)	: "Turret is becoming inactive and harmless."
	output OnTipped(void)	: "Turret has been tipped over and is inactive."
]


@PointClass base(Targetname, Angles) studioprop( "models/combine_turrets/floor_turret.mdl" ) = npc_turret_floor : "Combine Floor Turret"
[
	spawnflags(Flags) = 
	[
		32 : "Autostart" : 0
		64 : "Start Inactive" : 0
		128 : "Fast Retire" : 0
	]

	// Inputs
	input Toggle(void)		: "Toggle - If open, close. If closed, open."
	input Enable(void)		: "Enable the turret."
	input Disable(void)		: "Disable the turret."

	// Outputs
	output OnDeploy(void)	: "Turret is becoming active and dangerous."
	output OnRetire(void)	: "Turret is becoming inactive and harmless."
	output OnTipped(void)	: "Turret has been tipped over and is inactive."
	output OnPhysGunPickup(void) : "Picked up with physgun"
	output OnPhysGunDrop(void) : "Released by physgun"
]

@BaseClass base(BaseNPC) = VehicleDriverNPC
[
	vehicle(target_destination) : "Vehicle to drive"

	spawnflags(Flags) = 
	[
		65536 :  "Start Inactive"			: 1
	]

	input StartFiring(void) : "Tell the driver to attack nearby enemies with the vehicle's weaponry (if any)"
	input StopFiring(void) : "Tell the driver to stop attacking nearby enemies with the vehicle's weaponry."
	input GotoPathCorner(string) : "Tell the driver to go to a specific path corner and continue from there."
]

@NPCClass base(VehicleDriverNPC) studioprop("models/roller.mdl") = npc_vehicledriver : 
	"NPC used to drive a target vehicle."
[
	drivermaxspeed(float) : "Maxspeed (percentage of vehicle's maxspeed)." : 1
	driverminspeed(float) : "MinSpeed (percentage of vehicle's maxspeed)." : 0

	input SetDriversMaxSpeed(float)	: "Set the Maxspeed (percentage of vehicle's maxspeed)."
	input SetDriversMinSpeed(float)	: "Set the Minspeed (percentage of vehicle's maxspeed)."
	input StartForward(void) : "Tell the driver to start driving."
	input Stop(void) : "Tell the driver to stop driving."
]

@NPCClass base(VehicleDriverNPC) studioprop("models/roller.mdl") = npc_cranedriver : 
	"NPC used to drive cranes."
[
	releasepause(float) : "Pause time before dropping a ForceDrop specified object." : 0

	// Inputs
	input ForcePickup(string)	: "Force the driver to pickup the specified entity (by targetname)"
	input ForceDrop(string)		: "Force the driver to drop the currently held object at the specified entity's location."

	// Outputs
	output OnPickedUpObject(void) 	: "Fired when the ForcePickup specified object has been picked up."
	output OnDroppedObject(void) 	: "Fired when the ForceDrop specified object has been dropped."
	output OnPausingBeforeDrop(void): "Fired at the start of the pause before dropping the ForceDrop specified object."
]

@NPCClass base(VehicleDriverNPC) studioprop("models/roller.mdl") = npc_apcdriver : 
	"NPC used to drive an APC vehicle."
[
	spawnflags(Flags) = 
	[
		65536 :  "No Rocket Attacks" : 0
		131072 : "No Gun Attacks"	: 0
	]

	drivermaxspeed(float) : "Maxspeed (percentage of vehicle's maxspeed)." : 1
	driverminspeed(float) : "MinSpeed (percentage of vehicle's maxspeed)." : 0

	input SetDriversMaxSpeed(float)	: "Set the Maxspeed (percentage of vehicle's maxspeed)."
	input SetDriversMinSpeed(float)	: "Set the Minspeed (percentage of vehicle's maxspeed)."
	input StartForward(void) : "Tell the driver to start driving."
	input Stop(void) : "Tell the driver to stop driving."

	input DisableFiring(float)	: "Disables firing from happening"
	input EnableFiring(float)	: "Enables firing to start. Firing is enabled by default"
]

@NPCClass base(BaseNPC) studioprop("models/roller.mdl") = npc_rollermine : "Roller Mine"
[
	spawnflags(Flags) = 
	[
		65536 :  "Friendly" : 0
	]

	startburied(choices) : "Start Buried" : "No" =
	[
		0 : "No"
		1 : "Yes"
	]

	output OnPhysGunPickup(void) : "Picked up with physgun"
	output OnPhysGunDrop(void) : "Released by physgun"
]

@NPCClass base(BaseNPC) studioprop("models/missile_defense.mdl") = npc_missiledefense : "Missile Defense"
[
]

@NPCClass base(BaseNPC) studioprop("models/combine_soldier.mdl") = npc_sniper : "Sniper"
[
	radius(integer) : "Patience Radius" : 0
	misses(integer) : "Initial Misses" : 0
	beambrightness(integer) : "Beam Brightness (0 to 255)" : 100

	shielddistance(float) : "Bullet shield distance" : 64
	shieldradius(float) : "Bullet shield radius" : 48

	// Inputs
	input EnableSniper(void) : "Enable Shooting"
	input DisableSniper(void) : "Disable Shooting"
	input SetDecoyRadius(integer) : "Set Decoy Radius"
	input SweepTarget(string) : "Sweep a Target"
	input SweepTargetHighestPriority(string) : "Drop everything and sweep this target!"
	input SweepGroupRandomly(string) : "Randomly Sweep a Group"

	spawnflags(Flags) = 
	[
		65536 :  "Hidden"			: 0
		131072 : "Laser Viewcone"	: 0
		262144 : "No Corpse"		: 0
		524288 : "Start Disabled"	: 0
	]
]

@PointClass base(Targetname, Parentname) iconsprite("editor/info_target.vmt")  = info_snipertarget : "Sniper Target"
[
	speed(integer) : "Sweep to speed" : 2
	groupname(string) : "Group Name"
	spawnflags(Flags) =
	[
		1 : "Shoot Me" : 0
		2 : "No Interruptions" : 0
		4 : "Snap Shot" : 0
		8 : "Resume if Interrupted" : 0
		16: "Snap to me" : 0
	]
]

@PointClass base(Targetname, Angles) studioprop() = prop_thumper : "Thumper"
[
	model(studio) : "World model" : "models/props_combine/CombineThumper002.mdl"

	dustscale(choices) : "Dust Scale" : "Small Thumper" =
	[
		128 : "Small Thumper"
		256 : "Large Thumper"
	]

	input Enable(void) : "Enable Thumper"
	input Disable(void) : "Disable Thumper"
]

@NPCClass base(BaseNPC) studioprop("models/antlion.mdl") sphere() = npc_antlion :
	"Antlions will run away from ai_sound, type: Thumper."
[
	startburrowed(choices) : "Start Burrowed" : "No" =
	[
		0 : "No"
		1 : "Yes"
	]

	spawnflags(Flags) =
	[
		65536 : "Burrow when eluded" : 0
		131072 : "Use Ground Checks" : 0
	]

	radius(integer) : "Alert Radius" : 256
	eludedist(integer) : "Distance until eluded" : 1024 : "Only available when Burrow When Eluded is flagged"
	
	ignorebugbait(choices) : "Ignore Bugbait" : "No" =
	[
		0 : "No"
		1 : "Yes"
	]

	input Unburrow(void) : "Unburrow from the ground"
	input Burrow(void) : "Burrow into the ground"
	input FightToPosition(string) : "Fight to position"
	input EnableJump(void) : "Allow non-navigational jumping"
	input DisableJump(void) : "Disallow non-navigational jumping"
	input IgnoreBugbait(void) : "Ignore bugbait"
	input HearBugbait(void) : "Hear bugbait"

	output	OnReachedFightGoal(void) : "Fires when the antlion reaches his specified fight-to location"
]

@NPCClass base(BaseNPC) studioprop("models/antlion_guard.mdl") = npc_antlionguard : "Antlion Guard"
[
	spawnflags(Flags) =
	[
		65536 : "Create server-side ragdoll on death" : 0
		131072 : "Use inside footsteps" : 0
	]

	startburrowed(choices) : "Start Burrowed" : "No" =
	[
		0 : "No"
		1 : "Yes"
	]

	allowbark(choices) : "Allow Bark" : "No" =
	[
		0 : "No"
		1 : "Yes"
	]

	// Inputs
	input Unburrow(void) : "Unburrow from the ground"
	input SetShoveTarget(string) : "Sets a shove target to attack"
	input SetChargeTarget(string) : "Sets a charge target to attack"
	input ClearChargeTarget(void) : "Clear the charge target"
	input SetCoverFromAttack(integer) : "Sets whether or not the creature will protect itself from attacks"
	input Ragdoll(void) : "Causes the antlion guard to die, regardless of health"
	input EnableBark(void) : "Allow the antlion guard to try and summon antlions"
	input DisableBark(void) : "Stop the antlion guard from trying to summon antlions"
	input InvestigateHint(string) : "Sniff around at a hint group until told otherwise"
	input StopInvestigating(void) : "Stop trying to sniff out the player"
		
	// Outputs
	output OnSeeHiddenPlayer(void) : "Fires when the current enemy is seen while trying to hide"
	output OnSmellHiddenPlayer(void) : "Fires when the current enemy is smelled while trying to hide"
	output OnSummon(void) : "Antlion guard is attempting to summon antlions"
]


@NPCClass base(BaseNPC) studioprop("models/crow.mdl") = npc_crow : "Crow"
[
	input FlyAway( string ) : "Forces the crow to fly to the nearest crow flyto hint node."
]

@NPCClass base(BaseNPC) studioprop("models/seagull.mdl") = npc_seagull : "Seagull"
[
	input FlyAway( string ) : "Forces the seagull to fly to the nearest crow flyto hint node."
]

@NPCClass base(BaseNPC) studioprop("models/pigeon.mdl") = npc_pigeon : "Pigeon"
[
	input FlyAway( string ) : "Forces the pigeon to fly to the nearest crow flyto hint node."
]

@NPCClass base(BaseNPC) studioprop("models/ichthyosaur.mdl") = npc_ichthyosaur : "Ichthyosaur"
[
]

@BaseClass base(BaseNPC) = BaseHeadcrab
[
	startburrowed(choices) : "Start burrowed" : "No" =
	[
		0 : "No"
		1 : "Yes"
	]
	
	spawnflags(flags) = 
	[
		65536 :  "Start hidden" : 0
	]
]

@NPCClass base(BaseHeadcrab, Parentname) studioprop("models/Headcrabclassic.mdl") = npc_headcrab : "Headcrab"
[
]
@NPCClass base(BaseHeadcrab) studioprop("models/Headcrab.mdl") = npc_headcrab_fast : "Fast Headcrab"
[
]
@NPCClass base(BaseHeadcrab) studioprop("models/Headcrabblack.mdl") = npc_headcrab_black : "Black Headcrab"
[
]

@NPCClass base(BaseNPC) studioprop("models/Stalker.mdl") = npc_stalker : "Stalker"
[
	BeamPower(choices) : "Beam Power" : "Low" =
	[
		0	: "Low"		 
		1	: "Medium"		 
		2	: "High"		 
	]
]


@NPCClass base(Parentname, BaseNPC) iconsprite("editor/bullseye.vmt") color(255 0 0) = npc_bullseye : "Bullseye"
[
	// Unlike other NPCs level designers are allowed to set the health on bullseyes
	health(Integer) : "Health" : 35

	spawnflags(Flags) = 
	[
		65536   : "Not Solid" : 0
		131072  : "Take No Damage" : 0
		262144  : "Enemy Damage Only" : 0
		524288  : "Bleed" : 0
		1048576 : "Perfect Accuracy" : 0
	]
	output OnTargeted(void) : "Fires when targeted"
	output OnReleased(void) : "Fires when no longer targeted"
]


@NPCClass base(Parentname, BaseNPC) size(-16 -16 -16, 16 16 16) color(255 150 0) = npc_enemyfinder : "EnemyFinder"
[
	spawnflags(flags) =
	[
		65536 : "Check Visibility" : 1
		131072 : "APC Visibility checks" : 0
		262144 : "Short memory" : 0
		524288  : "Can be an enemy" : 0
	]
	FieldOfView(string)				: "FieldOfView"		: "0.2" : "How far to look (1.0 = straight ahead, 0.0 = +/- 90 degrees, -1.0 = all directions)"
	MinSearchDist(integer)			: "Min Search Dist"	: 0
	MaxSearchDist(integer)			: "Max Search Dist"	: 2048

	freepass_timetotrigger(float)	: "Player pass issue time" : 0 : "Amount of time an enemy is hidden after which a 'free pass' on reaquire is granted"
	freepass_duration(float)		: "Player pass duration" : 0 : "After granted 'free pass', the amount of time a target is allowed before reaquire"
	freepass_movetolerance(float)	: "Player pass move tolerance" : 120 : "After granted 'free pass', the distance the target is allowed to move before reaquire"
	freepass_refillrate(float)		: "Player pass refill rate" : "0.5" : "After free pass begins expiring, how much the time the target gets back for every second they hide again"
	freepass_peektime(float)		: "Player pass peek time" : 0 : "How long targets in cover are allowed to peek without penalty"

	StartOn(choices) : "Start On" : 1 =
	[
		0 : "No"
		1 : "Yes"
	]

	// Inputs
	input TurnOn(void)				: "Turn on: Look for enemies"
	input TurnOff(void)				: "Turn off: Stop looking for enemies"
]


@NPCClass base(BaseNPC,Parentname) studioprop() = npc_citizen : "Citizen"
[

	spawnflags(Flags) =
	[
		65536 : "Follow player on spawn" : 0
		131072 : "Medic" : 0
		262144 : "Random Head" : 1
		524288 : "Ammo Resupplier" : 0
		1048576 : "Not Commandable" : 0
		2097152 : "Don't use Speech Semaphore" : 0
		4194304 : "Random male head" : 0
		8388608 : "Random female head" : 0
		16777216 : "Use RenderBox in ActBusies" : 0
	]

	additionalequipment(choices) : "Weapons" : "0" =
	[
		"weapon_smg1"			: "SMG1"
		"weapon_ar2"			: "AR2"
		"weapon_stunstick"		: "Stun Stick"
		"weapon_crowbar"		: "Crow Bar"
		"weapon_shotgun"		: "Shotgun"
		"weapon_beerbottle"		: "Beer Bottle"
		"weapon_beerbottle2"	: "Beer Bottle2"
		"weapon_rpg"			: "RPG"
		"0" 					: "Nothing"
	]

	ammosupply(choices) : "Ammo to Resupply (if spawnflag set)" : "SMG1" =
	[
		"Pistol"			: "Pistol"
		"SMG1"				: "SMG1"
		"SMG1_Grenade"			: "SMG1 Grenade"
		"AR2"				: "AR2"
		"Buckshot"			: "Shotgun"
		"RPG_Round"			: "RPG"
		"Grenade"			: "Grenade"
		"XBowBolt"			: "Crossbow Bolt"
	]
	ammoamount(integer)	: "Amount of ammo to give" : 1

	citizentype(choices) : "Type" : "Default" =
	[
		0	: "Default"	 
		1	: "Downtrodden"
		2	: "Refugee"
		3	: "Rebel"
		//4	: "Unique"
	]

	expressiontype(choices) : "Expression Type" : "Random" =
	[
		0	: "Random"
		1	: "Scared"
		2	: "Normal"
		3	: "Angry"
	]

	model(choices) : "Model" : "models/humans/group01/male_01.mdl" =
	[
		"models/humans/group01/male_01.mdl"			: "Male 1"
		"models/humans/group01/male_02.mdl"			: "Male 2"
		"models/humans/group01/male_03.mdl"			: "Male 3"
		"models/humans/group01/male_07.mdl"			: "Male 7"
		"models/humans/group01/male_08.mdl"			: "Male 8"
		"models/humans/group01/male_09.mdl"			: "Male 9"
		"models/humans/group01/female_01.mdl"		: "Female 1"
		"models/humans/group01/female_02.mdl"		: "Female 2"
		"models/humans/group01/female_03.mdl"		: "Female 3"
		"models/humans/group01/female_04.mdl"		: "Female 4"
		"models/humans/group01/female_06.mdl"		: "Female 6"
		"models/humans/group01/female_07.mdl"		: "Female 7"
	]

	ExpressionOverride(string) : "Facial expression override"

	notifynavfailblocked(choices) : "Fire output when Nav is blocked?" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]

	input SetExpressionOverride(string) : "Set facial expression override"

	input StartPatrolling(void)	: "Patrol whenever I'm idle or alert."
	input StopPatrolling(void)	: "Stop patrolling when I'm idle or alert."
	input SetCommandable(void) : "Make a previously uncommandable citizen commandable"
	input SetMedicOn(void) : "Set the medic flag on. Will not change the model or skin of the citizen."
	input SetMedicOff(void) : "Set the medic flag off. Will not change the model or skin of the citizen."
	input SetAmmoResupplierOn(void) : "Set the ammo-resupplier flag on. Will not change the model or skin of the citizen."
	input SetAmmoResupplierOff(void) : "Set the ammo-resupplier flag off. Will not change the model or skin of the citizen."

	input SetReadinessLow(void) : "Set readiness to calmest state (Bored)"
	input SetReadinessMedium(void) : "Set readiness to moderate (Alert)"
	input SetReadinessHigh(void) : "Set readiness to highest. (Combat imminent)"
	input LockReadiness(float) : "Lock readiness at current setting for x seconds -1 = forever, 0 = unlock now"

	output OnJoinedPlayerSquad(void) : "Fires when joins player squad"
	output OnLeftPlayerSquad(void) : "Fires when leaves player squad"
	output OnFollowOrder(void) : "Fires when ordered to follow player"
	output OnStationOrder(void) : "Fires when ordered to a location by player"
	output OnPlayerUse(void) : "Fires when a player +USEs the citizen"
	output OnNavFailBlocked(void) : "Fires when this Citizen's movement fails because he/she is blocked."
]

@NPCClass base(BaseNPC) studioprop("models/Barney.mdl") = npc_fisherman : "Fisherman"
[
	ExpressionOverride(string) : "Facial expression override"
	input SetExpressionOverride(string) : "Set facial expression override"
]

@NPCClass base(BaseNPC) studioprop("models/Barney.mdl") = npc_barney : "Barney"
[
	additionalequipment(choices) : "Weapons" : "weapon_pistol" =
	[
		"weapon_pistol"			: "Pistol"
		"weapon_smg1"			: "SMG1"
		"weapon_stunstick"		: "Stun Stick"
		"weapon_shotgun"		: "Shotgun"
		"weapon_ar2"			: "AR2"
		"0" : "Nothing"
	]

	input SetReadinessLow(void) : "Set readiness to calmest state (Bored)"
	input SetReadinessMedium(void) : "Set readiness to moderate (Alert)"
	input SetReadinessHigh(void) : "Set readiness to highest. (Combat imminent)"
	input LockReadiness(float) : "Lock readiness at current setting for x seconds -1 = forever, 0 = unlock now"

	ExpressionOverride(string) : "Facial expression override"
	input SetExpressionOverride(string) : "Set facial expression override"
]


@BaseClass base(BaseNPC, RappelNPC) = BaseCombine
[
	additionalequipment(choices) : "Weapons" : "weapon_smg1" =
	[
		"weapon_ar2"		: "AR2"
		"weapon_shotgun"	: "Shotgun"
		"weapon_smg1"		: "SMG1"
		"weapon_stunstick"	: "Stun Stick"
		"0"					: "Nothing"
	]

	spawnflags(Flags) = 
	[
		65536 :  "Start LookOff"	: 0
	]

	NumGrenades(choices) : "Number of Grenades" : "5" =
	[
		"0"			: "None"
		"1"			: "1"
		"2"			: "2"
		"3"			: "3"
		"4"			: "4"
		"5"			: "5"
		"999999"	: "Unlimited"
	]

	// Inputs
	input LookOn(void)			: "Look normally"	
	input LookOff(void)			: "Don't look for myself, use other squad member's eyes"
	input StartPatrolling(void)		: "Patrol whenever I'm idle or alert."
	input StopPatrolling(void)		: "Stop patrolling when I'm idle or alert."
	input ThrowGrenadeAtTarget(target_destination) : "Throw a grenade at the specified target."
]


@NPCClass base(BaseCombine) studioprop("models/Combine_Soldier.mdl") = npc_combine_s : "Combine Soldier"
[
	model(choices) : "Model" : "models/combine_soldier.mdl" : "Regular Soldier" = 
	[
		"models/combine_soldier.mdl"			: "Regular Soldier"
		"models/combine_soldier_prisonguard.mdl"	: "Nova Prospekt Soldier"
		"models/combine_super_soldier.mdl"		: "Elite Soldier"
	]
]


@PointClass base(Parentname, BaseNPC) studioprop("models/junk/w_traffcone.mdl") = npc_launcher : "Launcher"
[

	spawnflags(Flags) = 
	[
		65536  :  "Check LOS"		: 1
	]

	StartOn(choices) : "Start On" : 0 = 
	[
		0: "Off"
		1: "On"
	] 
	MissileModel(studio) : "Missile Model" : "models/Weapons/wscanner_grenade.mdl"
	LaunchSound(sound) : "Launch Sound" : "npc/waste_scanner/grenade_fire.wav"
	FlySound(sound) :	"Fly Sound": "ambient/objects/machine2.wav"

	SmokeTrail(choices) : "Smoke Trail" : 1 = 
	[
		0: "Off"
		1: "On"
		2: "On Homing"
	] 
	LaunchSmoke(choices) : "Launch Smoke" : 1 = 
	[
		0: "Off"
		1: "On"
	] 
	LaunchDelay(integer)			: "Launch Delay"			: 8	    : "When ON, how long to wait between each launch"
	LaunchSpeed(string)				: "Launch Speed"			: 200   : "Initial launch speed of missile (in up direction)"
	PathCornerName(target_destination) : "Path Corner Name"		: ""	: "Name of a path corner.  If set launches a pathfollowing missing, rather than a homing missile"
	HomingSpeed(string)				: "Homing Speed"			: 0	    : "Speed to reach when homing"
	HomingStrength(integer)			: "Homing Strength"			: 10    : "How strong in homing effect (0-100)"
	HomingDelay(string)				: "Homing Delay"			: 0		: "Number of seconds to delay before homing starts"
	HomingRampUp(string)			: "Homing Ramp Up"			: "0.5" : "Number of seconds it takes to reach full homing strength after homing delay"
	HomingDuration(string)			: "Homing Duration"			: 5     : "Number of seconds the homing effect lasts"
	HomingRampDown(string)			: "Homing Ramp Down"		: "1.0" : "Number of seconds it takes homing effect to decay after homing duration"
	Gravity(string)					: "Gravity"					: "1.0" : "Scale for effect of gravity. (1.0 = normal gravity)"
	MinRange(integer)				: "Min Range"				: 100   : "Minimun distance a target can be to be attacked"
	MaxRange(integer)				: "Max Range"				: 2048  : "Maximum distance a target can be to be attacked"
	SpinMagnitude(string)			: "Spin Magnitude"			: 0	    : "Strength of spin in missile trajectory"
	SpinSpeed(string)				: "Spin Speed"				: 0     : "How fast does the spin rotate through 360"
	Damage(string)					: "Damage"					: 50    : "How much damage does each missile do"
	DamageRadius(string)			: "DamageRadius"			: 200   : "How far away from impact does the missle do damage"

	// Outputs
	output OnLaunch(void) : "Fires when missile is launched"

	// Inputs
	input TurnOn(void) : "Turn on Launcher"
	input TurnOff(void) : "Turn off Launcher"
	input LOSCheckOn(void) : "Start checking line of sight before firing"
	input LOSCheckOff(void) : "Stop checking line of sight before firing"
	input SetEnemyEntity(string)		: "Set entity I should attack. Ignores visibility. (output from other entity only)"
	input ClearEnemyEntity(void)		: "Clear set enemy enemy"
	input FireOnce(void) : "Fire Once (if have enemy)"
]

@NPCClass base(BaseNPC) studioprop() = npc_vortigaunt : "Vortigaunt"
[
	model(studio) : "World model" : "models/vortigaunt.mdl"

	ArmorRechargeEnabled(choices) : "Allow Armor Recharging" : 1 =
	[
		0 : "No"
		1 : "Yes"
	]

	// Inputs
	input EnableArmorRecharge(void) : "Allow armor recharging on players"
	input DisableArmorRecharge(void) : "Do not allow armor recharging on players"
	input ExtractBugbait(string) : "Causes the vortigaunt to extract bugbait from the named target passed in."
	input ChargeTarget(string) : "Force the vortigaunt to charge the named target."

	// Outputs
	output OnFinishedExtractingBugbait(void) : "Fires when the vortigaunt's finished extracting bugbait from a target."
	output OnFinishedExtractingTauCannon(void) : "Fires when the vortigaunt's finished extracting the tau cannon from the jeep."
	output OnFinishedChargingTarget(void) : "Fires when the vortigaunt has finished charging a target."
	output OnPlayerUse(void) : "Fires when a player +USEs the vortigaunt."
]

@NPCClass base(BaseNPC) = npc_spotlight : "Spotlight"
[
	spawnflags(Flags) = 
	[
		65536  :  "Start Track On"		: 1
		131072 :  "Start Light On"		: 1
		262144 :  "No Dynamic Light"	: 0
		524288 :  "Never Move"			: 0
	]

	health(Integer)				: "Health"			: 100
	YawRange(integer)			: "YawRange"		: 90
	PitchMin(integer)			: "PitchMin"		: 35
	PitchMax(integer)			: "PitchMax"		: 50
	IdleSpeed(integer)			: "IdleSpeed"		: 2
	AlertSpeed(integer)			: "AlertSpeed"		: 5
	spotlightlength(integer)	: "SpotlightLength"	: 500
	spotlightwidth(integer)		: "SpotlightWidth"	: 50
	rendercolor(color255)		: "Color (R G B)"	: "255 255 255"
	
	// Inputs
	input LightOn(void)			: "LightOn"
	input LightOff(void)		: "LightOff"
	input TrackOn(void)			: "TrackOn"
	input TrackOff(void)		: "TrackOff"

	// Outputs
	output OnAlert(void)				: "Fires when the spotlight alerted by sound"
	output DetectedEnemy(string)		: "Outputs enemy entity when spotlight finds and starts tracking enemy"
	output LostEnemy(string)			: "Outputs enemy entity when spotlight loses enemy that it's tracking, if enemy still exists"
	output SquadDetectedEnemy(string)	: "Outputs enemy entity when squad finds and starts tracking enemy"
	output SquadLostEnemy(string)		: "Outputs enemy entity when squad loses enemy that it's tracking, if entity still exists"
	output LightPosition(string)		: "Position of the end of the spotlight beam"
]


@NPCClass base(BaseNPC) studioprop("models/combine_Strider.mdl") = npc_strider : "Strider"
[
	spawnflags(Flags) = 
	[
		65536 :  "Can Stomp Player"		: 0
	]

	input SetMinigunTime(float) : "Time to shoot at any set minigun target"
	input SetMinigunTarget(string) : "Strider will shoot minigun at this"
	input SetCannonTarget(string) : "Strider will shoot cannon at this"
	input FlickRagdoll(void) : "Strider will flick anyone he's skewered"

	input StartPatrol(void) : "Start patrolling back and forth along the current track."
	input StopPatrol(void) : "Stop patrolling back and forth along the track. This will cause the helicopter to come to rest at the track which he's currently flying toward."
	input ChooseFarthestPathPoint(void) : "When tracking an enemy, choose the point on the path furthest from the enemy, but still in firing range"
	input ChooseNearestPathPoint(void) : "When tracking an enemy, choose the point on the path nearest from the enemy"
	input Crouch(void) : "Crouch down"
	input Stand(void) : "Stand up from crouch"
	input DisableCrouchWalk(void)
	input EnableCrouchWalk(void)
	
	input SetTargetPath(string) : "Set a path for the strider to patrol. The strider will first move to the closest point on the path"
	input ClearTargetPath(void) : "Clear the strider patrol path"
	
	disablephysics(choices) : "Disable physics (reduce CPU)" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]
]


@NPCClass base(BaseNPC) studioprop("models/Barnacle.mdl") = npc_barnacle : "Barnacle"
[
	spawnflags(Flags) =
	[
		65536 : "Cheap death" : 0
	]

	RestDist(float) : "Rest Distance" : 16 : "Distance above the ground that the tongue should lie when the barnacle is at rest"
]

@NPCClass base(BaseHelicopter) studioprop("models/gunship.mdl" ) = npc_combinegunship : "Combine Gunship"
[
	// outputs
	output OnFireCannon(void) 		: "Fires when the gunship fires a cannon round"

	// inputs
	input OmniscientOn(void) : "Gunship knows target's location even when target is out of sight or behind cover"
	input OmniscientOff(void) : "Gunship relies on normal sight functions to locate target"
	input BlindfireOn(void ) : "Gunship will fire at an unseen target, attempting to punch through to them"
	input BlindfireOff(void ) : "Gunship only fires at viusible target"
	input SetPenetrationDepth( float ) : "Set penetration depth of bullets"

	input SetDockingBBox( void ) : "Shrink Bounding Box"
	input SetNormalBBox( void ) : "Set Bounding Box to normal size"

	input EnableGroundAttack( void ) : "Allow the gunship to use its ground attack"
	input DisableGroundAttack( void ) : "Don't allow the gunship to use its ground attack"
	input DoGroundAttack( string ) : "Causes the gunship to execute its ground attack"

	input BecomeInvulnerable( void ): "Stops the gunship from taking damage, but still makes sounds effects"
	input BecomeVulnerable( void ): "Makes the gunship act normally to damage"

	input EnableRotorSound(void) : "Turns on rotor sounds"
	input DisableRotorSound(void) : "Turns off rotor sounds"

	// outputs
	output	OnFirstDamage( void ) : "Fired when the first damage is done to the gunship."
	output	OnSecondDamage( void ) : "Fired when the second damage is done to the gunship."
	output	OnThirdDamage( void ) : "Fired when the third damage is done to the gunship."
	output	OnFourthDamage( void ) : "Fired when the fourth damage is done to the gunship."

	spawnflags(Flags) =
	[
		4096 : "No ground attack" : 0
	]
]

@PointClass base(Targetname, Parentname) iconsprite("editor/info_target.vmt")  = info_target_gunshipcrash : "Gunship Crash Target"
[
	input Enable(void) : "Enable the crash target."
	input Disable(void) : "Disable the crash target."
]

@NPCClass base(BaseHelicopter) studioprop("models/combine_dropship.mdl" ) = npc_combinedropship : "Combine Dropship"
[
	spawnflags(Flags) =
	[
		32768 : "Wait for input before dropoff" : 0
	]

	LandTarget(target_destination) : "Land target name"
	GunRange(float) : "Crate Gun Range" : 2048 : "If the dropship's carrying a crate with a gun on it, it'll only shoot targets within this range."

	NPCTemplate(target_destination) : "Name of Template NPC 1"
	NPCTemplate2(target_destination) : "Name of Template NPC 2"
	NPCTemplate3(target_destination) : "Name of Template NPC 3"
	NPCTemplate4(target_destination) : "Name of Template NPC 4"
	NPCTemplate5(target_destination) : "Name of Template NPC 5"
	NPCTemplate6(target_destination) : "Name of Template NPC 6"

	Dustoff1(target_destination) : "Name of dustoff point for NPC 1"
	Dustoff2(target_destination) : "Name of dustoff point for NPC 2"
	Dustoff3(target_destination) : "Name of dustoff point for NPC 3"
	Dustoff4(target_destination) : "Name of dustoff point for NPC 4"
	Dustoff5(target_destination) : "Name of dustoff point for NPC 5"
	Dustoff6(target_destination) : "Name of dustoff point for NPC 6"

	APCVehicleName(target_destination) : "Name of the APC to drop"
	Invulnerable(Choices) : "Invulnerable" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]

	CrateType(Choices) : "Crate Type" : 2 =
	[
		-3 : "Jeep (No crate)"
		-2 : "APC (No crate)"
		-1 : "Strider (No crate)"
		0 : "Roller Hopper"
		1 : "Soldier Crate"
		2 : "None"
	]

	// inputs
	input LandLeaveCrate(integer) : "Land, drop soldiers, and leave the crate behind. Specify the number of troops to drop off in the parameter."
	input LandTakeCrate(integer) : "Land, drop soldiers, but don't leave the crate behind. Specify the number of troops to drop off in the parameter."
	input DropMines(integer) : "Drop Rollermines. Specify the number of mines to drop in the parameter."
	input DropStrider(void) : "Drop the Strider you're carrying. Now."
	input DropAPC(void) : "Drop the APC you're carrying. Now."
	input Pickup(string) : "Pickup an entity."
	input SetLandTarget(string) : "Set my land target name."
	input SetGunRange(float) : "Set my crate gun's range."

	input EnableRotorSound(void) : "Turns on rotor sounds"
	input DisableRotorSound(void) : "Turns off rotor sounds"

	input StopWaitingForDropoff(void) : "Stop waiting for the dropoff. Dropoff as soon as possible."

	// outputs
	output OnFinishedDropoff(void) 		: "Fires when the dropship has finished a dropoff."
	output OnFinishedPickup(void)		: "Fires when the dropship has finished a pickup."

	output OnCrateShotDownBeforeDropoff(float)	: "Fires when the container was shot down before it dropped off soldiers. The parameter contains the number of soldiers that weren't successfully dropped off."
	output OnCrateShotDownAfterDropoff(void)	: "Fires when the container was shot down after it dropped off soldiers."
]

@NPCClass base(BaseHelicopter) studioprop("models/combine_helicopter.mdl" ) = npc_helicopter : "Helicopter"
[
	spawnflags(Flags) = 
	[
		65536 :  "Loud rotor wash sound"	: 0
		131072 : "Electrical drone"			: 0
		262144 : "Helicopter lights"		: 0
		524288 : "Ignore avoid spheres+boxes" : 0
		1048576 : "More aggressive attacks" : 0
	]

	InitialSpeed(string) : "Initial Speed" : "0"
	GracePeriod(float) : "Grace Period" : "2.0" : "Time in seconds the helicopter has to see the player before he starts shooting"
	PatrolSpeed(float) : "Patrol Speed" : "0" : "Speed at which the helicopter moves if he has no enemy."

	// Input
	input GunOn(void)		: "GunOn"
	input GunOff(void)		: "GunOff"
	input MissileOn(void)	: "MissileOn"
	input MissileOff(void)	: "MissileOff"
	input EnableRotorWash(void)	: "Turns on rotor wash effects"
	input DisableRotorWash(void) : "Turns off rotor wash effects"
	input EnableRotorSound(void) : "Turns on rotor sounds"
	input DisableRotorSound(void) : "Turns off rotor sounds"
	input StartBombingVehicle(void) : "Starts the chopper leading enemy vehicles and dropping bombs on them."
	input StartTrailingVehicle(void) : "Starts the chopper trailing enemy vehicles and shooting at them."
	input StartDefaultBehavior(void) : "Starts the chopper in the mode where he always stops at nav points instead of stopping anywhere in between nav points."
	input StartAlwaysLeadingVehicle(void) : "Starts the chopper *always* leading enemy vehicles (regardless of how they are moving w/respect to the path) and dropping bombs on them. This mode is different from StartBombingVehicle in that it never uses the machine gun."
	input StartSprinkleBehavior(void) : "Starts the chopper dropping bombs randomly + shooting at the player."
	input StartBullrushBehavior(void) : "Starts the chopper bullrushing the player."
	input SetHealthFraction(float) : "Sets the chopper health as a percentage of max health"

	input EnableDeadlyShooting(void) : "Starts the chopper being deadly to on-foot players"
	input DisableDeadlyShooting(void) : "Stops the chopper being deadly to on-foot players"

	input StartNormalShooting(void) : "The chopper will fire in short bursts. Good for on-foot experiences"
	input StartLongCycleShooting(void) : "The chopper fires in long bursts"
	input StartContinuousShooting(void) : "The chopper fires continuously."

	input ResetIdleTime(void)	: "Allows the helicopter to fire immediately if he's not in the middle of charging or firing"
	input SetAngles(string) : "Instantly snaps the orientation of the helicopter (Pitch Yaw Roll)"
	input DropBomb(void) : "Immediately drops a bomb based on normal bomb dropping rules"
	input DropBombStraightDown(void) : "Immediately drops a bomb directly downwards"
	input DropBombAtTarget(target_destination) : "Immediately drops a bomb directly at the target destination, but only if the player isn't right there"
	input DropBombAtTargetAlways(target_destination) : "Immediately drops a bomb directly at the target destination, no matter whether it's fair or not."
	input DropBombDelay(float) : "Add a delay before the next bomb is dropped"
	input BecomeIndestructible(void) : "Makes the helicopter take no more damage"

	input DisablePathVisibilityTests(void) : "When the helicopter moves, he will not check for visibility from the path_track to the enemy to cull out path_tracks"
	input EnablePathVisibilityTests(void) : "When the helicopter moves, he will only move to path_tracks that have line-of-sight to the enemy"

	output OnHealthChanged(integer)	: "Fires when the helicopter health changes. The integer is the percentage of health the chopper has from 0-100."
]

@PointClass base(Targetname, Parentname) iconsprite("editor/env_firesource") color(255 255 0) sphere(radius) = npc_heli_avoidsphere : "Helicopter avoidance sphere"
[
	spawnflags(Flags) = 
	[
		65536 :  "Avoid the sphere above and below"	: 0
	]
	radius(float) : "Radius" : 128
]

@SolidClass base(Targetname, Parentname, Angles, Origin) color(255 255 0) = npc_heli_avoidbox : "Helicopter avoidance box"
[
	spawnflags(Flags) = 
	[
		65536 :  "Avoid the box above and below"	: 0
	]
]

@SolidClass base(Targetname, Parentname, Angles, Origin) color(255 255 0) = npc_heli_nobomb : "Helicopter bombing suppressor"
[
]

@NPCClass base(BaseNPC) studioprop("models/Zombie/fast.mdl") = npc_fastzombie : "Fast Zombie"
[
]


@NPCClass base(BaseNPC) studioprop("models/Zombie/Classic.mdl") = npc_zombie : "Zombie"
[
]


@NPCClass base(BaseNPC) studioprop("models/Zombie/Classic_torso.mdl") = npc_zombie_torso : "Zombie Torso"
[
]


@NPCClass base(BaseNPC) studioprop("models/Zombie/Poison.mdl") = npc_poisonzombie :
	"A bloated, disgusting, fluid-spurting zombie created by a poison headcrab."
[
	crabcount(choices) : "Crabs in nest" : 3 =
	[
		1 : "1 Crab"
		2 : "2 Crabs"
		3 : "3 Crabs"
	]
]


@NPCClass base(BaseNPC) studioprop("models/combine_scanner.mdl") = npc_cscanner : "City Scanner"
[
	spawnflags(Flags) = 
	[
		65536 :  "No Dynamic Light"	: 0
		131072: "Strider Scout Scanner" : 0
	]

	spotlightlength(integer)	: "SpotlightLength"			: 500
	spotlightwidth(integer)		: "SpotlightWidth"			: 50	
	
	spotlightdisabled(choices)	: "SpotlightDisabled"		: 0 =
	[
		0 : "No"
		1 : "Yes"
	]

	ShouldInspect(choices) : "Should inspect" : 1 =
	[
		0 : "No"
		1 : "Yes"
	]

	OnlyInspectPlayers(choices) : "Only Inspect Players" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]

	NeverInspectPlayers(choices) : "Never Inspect Players" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]

	input DisableSpotlight(void) : "DisableSpotlight"
	input InspectTargetPhoto(string) : "Tells the scanner to photograph the given entity, named by classname or by target name. !activator or !player works here also."
	input InspectTargetSpotlight(string) : "Tells the scanner to spotlight the given entity, named by classname or by target name. !activator or !player works here also."
	input InputSetFlightSpeed(integer) : "Sets the flight speed of the scanner"
	input InputShouldInspect(integer) : "Set whether should inspect or not"
	input SetFollowTarget(string) : "Set target to follow until told otherwise"
	input ClearFollowTarget(void) : "Stop following our target"
	input SetDistanceOverride(float) : "Override the distance the scanner will attempt to keep between inspection targets and itself"

	input DeployMine(void) : "Drop landmine (if carrying one)"
	input EquipMine(void) : "Equip with landmine"
	
	output OnPhotographPlayer(void) : "Fired any time the scanner takes a picture of the player."
	output OnPhotographNPC(void) : "Fired any time the scanner takes a picture of an NPC."
]


@NPCClass base(BaseNPC) studioprop("models/manhack.mdl") = npc_manhack : "Manhack"
[
	spawnflags(Flags) = 
	[
		65536 : "Start packed up (folded and engine off)" : 0
		131072 : "Don't use any damage effects" : 0
		262144 : "Use Air Nodes" : 0
		1048576 : "No Danger Sounds" : 0
	]

	input DisableSwarm(void) : "Disable the manhack swarm behavior."
	input Unpack(void) : "Causes the manhack to stop being packed up."
]


@NPCClass base(BaseNPC) studioprop("models/mortarsynth.mdl") = npc_mortarsynth : "Mortar Synth"
[
]


@NPCClass base(BaseNPC,RappelNPC) studioprop("models/Police.mdl") = npc_metropolice : "MetroPolice"
[
	additionalequipment(choices) : "Weapons" : "weapon_pistol" =
	[
		"weapon_pistol"		: "Pistol"
		"weapon_smg1" 		: "SMG1"
		"weapon_stunstick" 	: "Stun Stick"
		"weapon_shotgun" 	: "Shotgun"
		"0" 				: "Nothing"
	]

	manhacks(Choices) : "Number of Manhacks" : 0 =
	[
		0 : "None"
		1 : "1"
		2 : "2"
	]

	weapondrawn(Choices) : "Pistol starts drawn" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]
	
	spawnflags(Flags) =
	[
		131072 : "Simple cops" : 0
		262144 : "Rappel (UNCHECK THIS IF IT IS CHECKED!)" : 0
		524288 : "Always stitch" : 0
		1048576 : "No chatter" : 0
		2097152 : "Arrest enemies" : 0
		4194304 : "No far stitching" : 0
		8388608 : "Prevent manhack toss" : 0
		16777216: "Allowed to respond to thrown objects" : 0
		33554432: "Mid-range attacks (halfway between normal + long-range)" : 0
	]
	  
	// Inputs
	input EnableManhackToss(void) : "Enables manhack toss (which had been disabled by the spawnflag)"
	input SetPoliceGoal(string) : "Causes the NPC to police the area defined by an ai_goal_police"
	input ActivateBaton(void) : "Set the baton to active"

	// Outputs
	output OnStunnedPlayer(void) : "Fires when the player is hit by a stunstick by this NPC."
]

@NPCClass base(BaseNPC) studioprop("models/Synth.mdl") = npc_crabsynth : "Crab Synth"
[
]

@NPCClass base(TalkNPC) studioprop("models/Monk.mdl") = npc_monk : "Monk"
[
	additionalequipment(choices) : "Weapons" : "weapon_annabelle" =
	[
		"weapon_annabelle"		: "Annabelle"
		"weapon_smg1"			: "SMG1"
		"weapon_ar2"			: "AR2"
		"weapon_stunstick"		: "Stun Stick"
		"weapon_crowbar"		: "Crow Bar"
		"weapon_shotgun"		: "Shotgun"
		"weapon_beerbottle"		: "Beer Bottle"
		"weapon_beerbottle2"	: "Beer Bottle2"
		"weapon_rpg"			: "RPG"
		"0" 					: "Nothing"
	]

	HasGun(choices) : "Has Gun" : 1 =
	[
		0 : "No"
		1 : "Yes"
	]

	input PerfectAccuracyOn(void) : "Make every shot at a zombie a headshot"
	input PerfectAccuracyOff(void) : "Return to normal accuracy"
]


@NPCClass base(TalkNPC,Parentname) studioprop() = npc_alyx : "Alyx"
[
	model(studio) : "World model" : "models/alyx.mdl"

	additionalequipment(choices) : "Weapons" : "weapon_alyxgun" =
	[
		"weapon_alyxgun"	: "Alyx Gun"
		"0" 				: "Nothing"
	]
]


@NPCClass base(TalkNPC) studioprop("models/Kleiner.mdl") = npc_kleiner : "Kleiner"
[
]

@NPCClass base(TalkNPC,Parentname) studioprop() = npc_eli : "Eli Vance"
[
	model(studio) : "World model" : "models/eli.mdl"
]

@NPCClass base(TalkNPC) studioprop() = npc_breen : "Dr Breen"
[
	model(studio) : "World model" : "models/breen.mdl"

	spawnflags(Flags) = 
	[
		65536 : "Ignore speech semaphore"	: 0
	]
]

@NPCClass base(TalkNPC) studioprop("models/mossman.mdl") = npc_mossman : "Dr Mossman"
[
]

@NPCClass base(TalkNPC) studioprop("models/gman.mdl") = npc_gman : "The G-Man"
[
]

@NPCClass base(BaseNPC) studioprop("models/dog.mdl") = npc_dog : "d0g"
[
	input SetPickupTarget(string) : "Sets the target entity for dog to pickup."
	input StartCatchThrowBehavior(string) : "Tells d0g to start playing with the player. You can pass in the name of the object you want him to play with otherwise he'll find the closes phys_object."
	input StopCatchThrowBehavior(string) : "Stop the catch and throw behavior."
	input PlayerPickupObject(void) : "Tells d0g the physgun just picked up an object."
	input StartWaitAndCatch(void) : "Tells d0g to wait for the player to throw an object at him."
	input StopWaitAndCatch(void) : "Tells d0g to stop waiting for the player."
	input SetThrowArcModifier(float) : "Used to pass in a modifier for d0g's object flight arc."
	input SetThrowTarget(string) : "Set d0g's throw target (pass in !player if you want the player)"

	output OnDogThrow(void) : "Fires when dog throws an object."
	output OnDogPickup(void) : "Fires when dog picks up an object."
	output OnDogCatch(void) : "Fires when dog catches an object."
]

@PointClass base(Targetname, Angles, RenderFields) studioprop("models/weapons/W_slam.mdl") color(255 255 0) = npc_satchel : "A SLAM that's been thrown.  It'll explode if it takes damage or receives an Explode input."
[
	physdamagescale(float) : "Physics Impact Damage Scale" : "1.0" : "Scales damage received when this object is hit by a physics object. NOTE: 0 means this feature is disabled for backwards compatibility."
	input physdamagescale(integer) : "Scales damage received when this object is hit by a physics object. NOTE: 0 means this feature is disabled for backwards compatibility."
	input Explode(void) : "Force the satchel to explode."
	input Ignite(void) : "Sets the entity afire."
]

@PointClass base(Targetname, Angles, RenderFields) studioprop("models/weapons/W_slam.mdl") color(255 255 0) = npc_grenade_frag : "A frag grenade that's been thrown.  It will explode when it's damaged."
[
	physdamagescale(float) : "Physics Impact Damage Scale" : "1.0" : "Scales damage received when this object is hit by a physics object. NOTE: 0 means this feature is disabled for backwards compatibility."
	input physdamagescale(integer) : "Scales damage received when this object is hit by a physics object. NOTE: 0 means this feature is disabled for backwards compatibility."
	input Ignite(void) : "Sets the entity afire."
]

@PointClass base(Targetname, Angles, RenderFields) studioprop("models/weapons/W_slam.mdl") color(255 255 0) = npc_tripmine : "A SLAM that's been placed on a wall, acting as a tripmine."
[
	physdamagescale(float) : "Physics Impact Damage Scale" : "1.0" : "Scales damage received when this object is hit by a physics object. NOTE: 0 means this feature is disabled for backwards compatibility."
	input physdamagescale(integer) : "Scales damage received when this object is hit by a physics object. NOTE: 0 means this feature is disabled for backwards compatibility."
	input Ignite(void) : "Sets the entity afire."
]

@PointClass base(NameBase, BaseNPC, Parentname, Studiomodel) studioprop() = monster_generic : "Generic Script NPC"
[
	spawnflags(Flags) = 
	[
		65536 : "Not solid"	: 0
	]
]


@PointClass base(NameBase, BaseNPC, Parentname, Studiomodel) studioprop() = generic_actor : "Generic Actor NPC"
[
	hull_name(choices) : "Hull type" : "Human" =
	[
		"HUMAN_HULL" : "Human"
		"WIDE_HUMAN_HULL" : "Wide"
		"TINY_HULL" : "Tiny"
		"MEDIUM_HULL" : "Medium"
		"LARGE_HULL" : "Large"
	]
]

@PointClass base(NameBase, BaseNPC, Parentname, Studiomodel) studioprop() = cycler_actor : "Actor Cycler"
[
	Sentence(string) : "Sentence Group" : ""
]

@PointClass base(NameBase, Angles, BaseNPCMaker) iconsprite("editor/npc_maker.vmt") = npc_maker : "NPC Maker"
[
	spawnflags(Flags) = 
	[
		16	: "Fade Corpse"		 : 0
	]

	NPCType(npcclass) : "Class name of spawned NPC"
	NPCTargetname(string) : "Childrens' Name"
	NPCSquadname(string) : "Childrens' Squad Name"
	NPCHintGroup(string) : "Childrens' Hint Group"
	
	additionalequipment(choices) : "Weapons" : "0" =
	[
		"weapon_pistol"		: "Pistol"
		"weapon_ar2"		: "AR2"
		"weapon_shotgun"	: "Shotgun"
		"weapon_smg1"		: "SMG1"
		"weapon_stunstick"	: "Stun Stick"
		"weapon_annabelle"	:"Grigori's Shotgun"
		"0"			: "Nothing"
	]
]

@PointClass base(NameBase, Angles, BaseNPCMaker) size(-8 -8 -8, 8 8 8) color(0 0 255) = npc_antlion_template_maker : "Antlion Template Maker"
[
	spawnflags(Flags) = 
	[
		1024	: "Random spawn node"		 : 0
		2048	: "Try to spawn close to the current target"	 : 0
	]

	TemplateName(target_destination) : "Name of template NPC"

	spawngroup(string) : "Spawn on Hint Group" : "" : "If specified, children will spawn on a hint node from this group, nearest the target."
	spawnradius(float) : "Spawn radius" : 512 : "Target must be within this distance of any node in the hint group specified above. If the target is outside the radius, no NPC will spawn."
	spawntarget(string): "Spawn target" : "" : "Targetname of the entity to try and spawn near."
	fighttarget(string): "Fight target" : "" : "Targetname of an entity used as a goal for the children to fight to."
	followtarget(string): "Follow target" : "" : "Targetname of an entity used as a goal for the children to follow."
	vehicledistance(float): "Vehicle Spawn Distance" : "1" : "This is a modifier of the current spawn distance. Spawn distance on a vehicle is based on speed, so this is just a modifier for it."
	
	ignorebugbait(choices): "Ignore Bugbait" : "0" =
	[
		0 : "No"
		1 : "Yes"
	]

	pool_start(integer) : "Initial antlions in the pool." : 0 : "Number of antlions in the pool at map start."
	pool_max(integer) : "Max antlions in the pool." : 0 : "Maximum number of antlions allowed in the pool. If 0, pool behavior is turned off."
	pool_regen_amount(integer) : "Pool regen amount." : 0 : "This is the number of antlions added to the pool every time it regenerates."
	pool_regen_time(float) : "Pool regen time." : 0 : "Time interval between pool regeneration ticks."

	input SetFightTarget(string) : "Sets the target entity for children to fight to."
	input ClearFightTarget(void) : "Clears the fight target goal for this spawner."
	input SetFollowTarget(string) : "Sets the target entity for children to follow."
	input ClearFollowTarget(void) : "Clears the follow target goal for this spawner."
	input SetSpawnRadius(float) : "Sets the Spawn Radius."
	input AddToPool(integer) : "Add the number of antlions specified in the parameter to the pool."
	input SetMaxPool(integer) : "Set the maximum number of antlions allowed in the pool at any time. Setting it to 0 turns off the pool behavior."
	input SetPoolRegenAmount(integer) : "Set the number of antlions added to the pool every time it regenerates."
	input SetPoolRegenTime(float) : "Set the time interval between pool regeneration ticks."
]

@PointClass base(Targetname) sphere(repelradius) color(0 0 255) = point_antlion_repellant : "Antlion Repellant"
[
	repelradius(float): "Repell radius" : 512 : "Antlions aren't allowed to be inside this radius"
	input Enable(void) : "Enable"
	input Disable(void) : "Disable"
]

//-------------------------------------------------------------------------
//
// Player effects
//
//-------------------------------------------------------------------------

@BaseClass base(Targetname, Parentname, Angles) color(0 255 0) = PlayerClass []

@PointClass base(PlayerClass) studioprop("models/editor/playerstart.mdl") = info_player_start :
	"This entity indicates the position and facing direction at which the player will spawn. Any number of "+
	"info_player_start entities may be placed in a map for when working in cordoned-off portions of the map. "+
	"When multiple info_player_start entities are present in a map, set the 'Master' spawnflag on one of them "+
	"to indicate which one should be used when running the entire map."
[
	spawnflags(flags) =
	[
		1: "Master (Has priority if multiple info_player_starts exist)" : 0
	]
]

@PointClass base(Targetname) size(-16 -16 -16, 16 16 16) = player_loadsaved : "Loads the last saved game after a delay.  Similar to env_fade in many respects." 
[
	duration(string) : "Fade Duration (seconds)" : "2"
	holdtime(string) : "Hold Fade (seconds)" : "0"
	renderamt(integer) : "Fade Alpha" : 255
	rendercolor(color255) : "Fade Color (R G B)" : "0 0 0"
	loadtime(string) : "Reload delay" : "0"

	input Reload(void) : "Ends this game and reloads after the reload delay."
]


@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) color(32 32 200) = player_weaponstrip : "Strips activating player's weapons."
[
	input Strip(void) : "Strip player's weapons."
	input StripWeaponsAndSuit(void) : "Strip player's weapons and his suit."
]

@PointClass base(Targetname) size(-16 -16 -16, 16 16 16) = player_speedmod: "Scales the activating player's movement speed for all motion (this includes running, falling, and jumping), creating a slowmo or sped-up effect.  Only works via an input."
[
	input ModifySpeed(float) : "Scale the player's speed by this amount."
]

@PointClass base(Targetname, Parentname) color(0 255 0) size(-16 -16 -32, 16 16 32) = player : "FOR ADVANCED USERS ONLY.\n\nAn entity that corresponds to the player.  Any input sent to this entity will actually be sent to every player.  "+
	"Obviously very dangerous; handle with care!  If you want to send an input to just one player, use '!player' or '!activator' instead of 'player' as the target.\n\nDelete this entity, or place it in a hidden VisGroup, before compiling your map.  "+
	"Source doesn't like having a player entity in the map that isn't really a player."
[
	targetname(target_source) readonly : "Name (permanently set to player)" : "player" : "The name that other entities refer to this entity by."

	input SetHealth(integer) : "Sets the player's health.  Clamped to 0-100."
	input physdamagescale(float) : "Scales damage energy when this object is hit by a physics object. NOTE: 0 means this feature is disabled for backwards compatibility."
	input Ignite(void) : "Sets the player on fire."
	input IgnoreFallDamage(float) : "Forces the player to ignore all fall damage for the number of seconds specified.  <=0 defaults to 10.  This input only prevents fall damage on the next fall the player takes."
	input SetTeam(integer) : "Sets the player's team.  See filter_activator_team for the list of teams."
	input SetDamageFilter(string) : "Sets the entity to use as damage filter. Pass in an empty string to clear the damage filter."

	output OnIgnite(void) : "Fired when the player is set ablaze."
]

//-------------------------------------------------------------------------
//
// Scripted Events
//
//-------------------------------------------------------------------------
@BaseClass base(Targetname, Parentname, Angles) color(255 0 255) sphere(m_flRadius) = BaseScripted
[
	m_iszEntity(target_destination) : "Target NPC" : : "The name or class name (such as 'npc_zombie') of an NPC to use for this script."
	m_iszIdle(string) : "Pre Action Idle Animation" : "" : "The name of the sequence (such as 'idle01') or activity (such as 'ACT_IDLE') to play before the action animation if the NPC must wait for the script to be triggered. Use 'Start on Spawn' flag or MoveToPosition input to play this idle animation."
	m_iszPlay(string) : "Action Animation" : "" : "The name of the main sequence (such as 'reload02') or activity (such as 'ACT_RELOAD') to play."
	m_iszPostIdle(string) : "Post Action Idle Animation" : "" : "The name of the sequence (such as 'idle01') or activity (such as 'ACT_IDLE') to play after the action animation."
	m_iszCustomMove(string) : "Custom Move Animation" : "" : "Used in conjunction with the 'Custom movement' setting for the 'Move to Position' property, specifies the sequence (such as 'crouch_run01') or activity (such as 'ACT_RUN') to use while moving to the scripted position."
	m_flRadius(integer) : "Search Radius (0=everywhere)" : 0 : "Radius to search within for an NPC to use. 0 searches everywhere."
	m_flRepeat(integer) : "Repeat Rate ms" : 0
	m_fMoveTo(Choices) : "Move to Position" : 1 =
	[
		0 : "No"
		1 : "Walk"
		2 : "Run"
		3 : "Custom movement"
		4 : "Instantaneous"
		5 : "No - Turn to Face"
	]
	m_iszNextScript(target_destination) : "Next Script" : : "The name of the script to run immediately after this script completes. The NPC will not return to AI between the two scripts."

	// Inputs
	input BeginSequence(void) : "Summons an NPC to act out the scripted sequence."
	input MoveToPosition(void) : "Summons an NPC to the script location. They will play their scripted idle (or ACT_IDLE if none is specified) until BeginSequence is triggered."
	input CancelSequence(void) : "Stops the scripted sequence. If fired after a sequence starts, this input will not take effect until the NPC finishes playing the scripted action animation."

	// Outputs
	output OnBeginSequence(void) : "Fires when the action animation begins playing."
	output OnEndSequence(void) : "Fires when the action animation completes."
	output OnScriptEvent01(void) : "Fires when a 'trigger' anim event occurs while playing the script. Use { event 1003 framenum 1 } in the QC."
	output OnScriptEvent02(void) : "Fires when a 'trigger' anim event occurs while playing the script. Use { event 1003 framenum 2 } in the QC."
	output OnScriptEvent03(void) : "Fires when a 'trigger' anim event occurs while playing the script. Use { event 1003 framenum 3 } in the QC."
	output OnScriptEvent04(void) : "Fires when a 'trigger' anim event occurs while playing the script. Use { event 1003 framenum 4 } in the QC."
	output OnScriptEvent05(void) : "Fires when a 'trigger' anim event occurs while playing the script. Use { event 1003 framenum 5 } in the QC."
	output OnScriptEvent06(void) : "Fires when a 'trigger' anim event occurs while playing the script. Use { event 1003 framenum 6 } in the QC."
	output OnScriptEvent07(void) : "Fires when a 'trigger' anim event occurs while playing the script. Use { event 1003 framenum 7 } in the QC."
	output OnScriptEvent08(void) : "Fires when a 'trigger' anim event occurs while playing the script. Use { event 1003 framenum 8 } in the QC."
]


@PointClass sphere(radius) iconsprite("editor/scripted_sentence.vmt") base(Targetname) = scripted_sentence : "Scripted Sentence"
[
	spawnflags(Flags) = 
	[
		1 : "Fire Once" 	: 1
		2 : "Followers Only"	: 0
		4 : "Interrupt Speech"	: 1
		8 : "Concurrent"	: 0
		16 : "Speak to Activator" : 1
	]

	sentence(string) : "Sentence Name" : ""
	entity(string) : "Speaker Type"
	delay(string) : "Additional Sentence Time" : "0"
	radius(integer) : "Search Radius" : 512
	refire(string) : "Delay Before Refire" : "3"
	listener(string) : "Listener Type"
	volume(string) : "Volume 0-10" : "10"
	attenuation(Choices) : "Sound Radius" : 0 =
	[
		0 : "Small Radius"
		1 : "Medium Radius"
		2 : "Large  Radius"
		3 : "Play Everywhere"
	]

	// Inputs
	input BeginSentence(void) : "Starts the scripted sentence."

	// Outputs
	output OnBeginSentence(void) : "Fires when the sentence begins"
	output OnEndSentence(void) : "Fires when the sentence ends"
]


@PointClass base(Targetname, Parentname) iconsprite("editor/info_target.vmt") sphere(m_flRadius) = scripted_target : "Scripted Target"
[
	StartDisabled(choices) : "Start Disabled" : 1 =
	[
		0 : "No"
		1 : "Yes"
	]

	m_iszEntity(npcclass)	: "Target NPC"
	m_flRadius(integer) : "Search Radius (0=everywhere)" : 0 : "Radius to search within for an NPC to use. 0 searches everywhere."

	MoveSpeed(integer)		: "Move Speed"			: 5		// How quickly should target move between scripted targets
	PauseDuration(integer)	: "Pause Duration"		: 0		// How long should target pause at scripted target
	EffectDuration(integer)	: "Effect Duration"		: 2		// How long should any associated effect last

	target(target_destination) : "Next Target"				// Next scripted target

	// Inputs
	input Enable(void) : "Enable this entity"
	input Disable(void) : "Disable this entity"

	// outputs
	output AtTarget(void)		: "Fires when NPC reaches this target"
	output LeaveTarget(void)	: "Fires when NPC leaves this target"
]

@PointClass base(Targetname, Parentname) iconsprite("editor/ai_relationship.vmt") sphere(radius) = ai_relationship : "AI Relationship - Sets relationships between groups of NPCs in the AI."
[
	subject(target_name_or_class) : "Subject(s)" : "" : "This is the NPC(s) whose disposition will change.  May be a targetname or a classname."
	target(target_name_or_class) : "Target(s)" : "" : "This is the NPC(s) about whom the Subject(s) will change their disposition.  May be a targetname or a classname."
	disposition(choices) : "Disposition" : 3 : "Te way the Subject(s) should feel about the Target(s)." =
	[
		1 : "Hate"
		2 : "Fear"
		3 : "Like"
		4 : "Neutral"
	]
	radius(float) : "Radius for subject" : 0 : "The ai_relationship will search for valid subjects within this radius of itself.  Use 0 for the entire map."
	rank(integer) : "Disposition Priority" : 10 : "How much the Subject(s) should Like/Hate/Fear the Target(s). Higher priority = stronger feeling."
	StartActive(choices) : "Start Active" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]
	Reciprocal(choices) : "Reciprocal" : 0 : "Set this to YES to have the new relationship mirrored by Target."  =
	[
		0 : "No"
		1 : "Yes"
	]

	// Inputs
	input ApplyRelationship(void) : "Apply the desired relationship changes."
	input RevertRelationship(void) : "Revert the relationship to its previous state."
]

@PointClass base(Targetname) = ai_ally_manager : "Monitors the number and type of npc_citizen allies and responds accordingly. When this entity receives a Replenish input "+
	"it will count the number of allies and send outputs based on how many allies are needed to match this entity's keyvalues. Also fires an output when all allies and/or all "+
	"medics are dead. This entity can be used to trigger one or more npc_maker entities with the SpawnAlly Output, for example.\n\n"+
	"Outputs can be used for purposes aside from spawning more NPCs, if you're so inclined. More than one ai_ally_manager can exist, but none will count more than 10 allies."
[
	maxallies(integer) : "Maximum number of allies" : 5
	maxmedics(integer) : "Maximum number of medics" : 1

	// Inputs
	input SetMaxAllies(integer) : "Set maximum number of allies."
	input SetMaxMedics(integer) : "Set maximum number of medics."
	input Replenish(void) : "Replenish player allies"

	// Outputs
	output SpawnMedicAlly(void) : "Fired in response to a Replenish input when the player needs a medic ally."
	output SpawnAlly0(void) : "In response to a Replenish input, a SpawnAlly output will be fired for each ally that the player needs.  This one is fired if the player needs one ally."
	output SpawnAlly1(void) : "Fired in addition to SpawnAlly0 if the player needs a second ally."
	output SpawnAlly2(void) : "Also fired if the player needs a third ally."
	output SpawnAlly3(void) : "See SpawnAlly0.  This is fired for the fourth ally that the player needs."
	output SpawnAlly4(void) : "Etc."
	output SpawnAlly5(void)
	output SpawnAlly6(void)
	output SpawnAlly7(void)
	output SpawnAlly8(void)
	output SpawnAlly9(void)

	output OnZeroAllies(void) : "Fired when the player has no more allies."
	output OnZeroMedicAllies(void) : "Fired when the player has no more medics."
]

@BaseClass base(Targetname) = LeadGoalBase
[
	actor(target_name_or_class) : "Actor(s) to affect"
	goal(string) : "Target Entity"
	WaitPointName(target_destination) : "Point to wait at if the target's not visible."
	WaitDistance(float) : "Wait until player gets this close."
	LeadDistance(float) : "Lead Distance." : "64" : "The player is considered to be lagging if he's beyond this distance."
	Run(choices) : "Run instead of Walk" : "0" =
	[
		"0" : "No"
		"1" : "Yes"
	]

	Retrieve(choices) : "Retrieve player?" : 1 =
	[
		0 : "No, just idle and wait"
		1 : "Yes, move to retrieve"
	]
	
	AttractPlayerConceptModifier(string)	: "Attract player concept modifier"
	WaitOverConceptModifier(string)		: "Player wait over concept modifier"
	ArrivalConceptModifier(string)		: "Arrival concept modifier"
	PostArrivalConceptModifier(string)	: "Post-arrival concepts modifier"
	SuccessConceptModifier(string)		: "Success concept modifier"
	FailureConceptModifier(string)		: "Failure concept modifier"
	
	// Spawnflags
	spawnflags(Flags) = 
	[
		1 : "No def success" : 0
		2 : "No def failure" : 0
		4 : "Use goal facing" : 1
	]

	// Inputs
	input Activate( void ) 		: "Begin the leading behavior"
	input Deactivate( void ) 	: "Stop the leading behavior"
	
	input SetSuccess( void )	: "Notify success of leading"
	// input SetFailure( void )	: "Notify failure of leading"
	
	// Outputs
	output OnArrival( void )	: "Fires when NPC reaches the lead point"
	output OnArrivalDone( void ) : "Fires when NPC has played out any arrival speech"
	output OnSuccess( void )	: "Fires when NPC achieves the goal"
	output OnFailure( void )	: "Fires when NPC fails to achieves the goal"
	output OnDone( void )		: "Fires when NPC completes behavior (any post-success or fail acting is complete)"
]

@PointClass base(LeadGoalBase) iconsprite("editor/ai_goal_lead.vmt") = ai_goal_lead : "AI Goal Lead"
[
	SearchType(choices) : "Search Type" : 0 : "How to search for the entities using the targetname." = 
	[
		0 : "Entity Name"
		1 : "Classname"
	] 
]

@PointClass base(LeadGoalBase) iconsprite("editor/ai_goal_lead.vmt") = ai_goal_lead_weapon : "AI Goal Lead (Weapon). A version of the ai_goal_lead entity that requires the player to have the specified weapon before the Actor(s) will lead the player to their target."
[
	WeaponName(choices) : "Weapon" : "weapon_bugbait" =
	[
		"weapon_bugbait" : "Bugbait"
		"weapon_smg1" : "SMG1"
		"weapon_ar2"  : "AR2"
	]

	MissingWeaponConceptModifier(string)	: "Missing weapon concept modifier"
	
	SearchType(choices) : "Search Type" : 0 : "How to search for the entities using the targetname." = 
	[
		0 : "Entity Name"
		1 : "Classname"
	] 
]

@PointClass base(Targetname) iconsprite("editor/ai_goal_follow.vmt") = ai_goal_follow : "AI goal:  follow.  Attempts to force an NPC or group of NPCs to follow another object."
[
	actor(target_name_or_class) : "Actor" : : "The NPC targetname or classname that should be made to follow the target."
	goal(string) : "Target Entity" : : "The name of the entity to follow.  If blank, and the actor likes the player, then defaults to player."

	SearchType(choices) : "Search Type" : 0 : "Whether the specified actor is an NPC's targetname or a general classname." = 
	[
		0 : "Entity Name"
		1 : "Classname"
	] 

	StartActive(choices) : "Start Active" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]

	Formation(choices) : "Formation" : 0 : "Controls some properties of how the actor should follow the target." =
	[
		0 : "Close circle"
		5 : "Medium circle"
		1 : "Wide circle"
		2 : "Antlion formation"
		3 : "Commander formation"
		4 : "Tight formation"
	]

	// Inputs
	input Activate(void) : "Begin following."
	input Deactivate(void) : "Cease following."
]

@PointClass size( -4 -4 -4, 4 4 4 ) base(Targetname, Angles, Parentname) studioprop("models/pigeon.mdl") = ai_battle_line : "Battle line"
[																									  
	// Spawnflags
	spawnflags(Flags) = 
	[
		1 : "Use parent's orientation" : 0
	]

	actor(target_name_or_class) : "Actor(s) or squad to affect"

	Active(choices) : "Active" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]

	Strict(choices) : "Strict" : 1 : "Player orders can override, applies to allies only" =
	[
		0 : "No"
		1 : "Yes"
	]

	input Activate(void)
	input Deactivate(void)
]

@PointClass base(Targetname) iconsprite("editor/ai_goal_standoff.vmt") = ai_goal_standoff : "AI Goal Standoff"
[
	actor(target_name_or_class) : "Actor(s) to affect"
//	goal(string) : "Target Entity (self by default) [NOT IMPLEMENTED]"

	SearchType(choices) : "Search Type" : 0 : "How to search for the entities using the targetname." = 
	[
		0 : "Entity Name"
		1 : "Classname"
	] 

	StartActive(choices) : "Start Active" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]

	HintGroupChangeReaction(Choices) : "Reaction to tactical change" : 1 : "What to do if leader moves, threat is neutralized, hint group changes, etc" =
	[
		0 : "Move when ready (default AI)"
		1 : "Move when seek cover"
		2 : "Move immediately"
	]

	Aggressiveness(Choices) : "Aggressiveness" : 2 =
	[
		0 : "Very low"
		1 : "Low"
		2 : "Medium"
		3 : "High"
		4 : "Very High"
		// Custom agression disabled
		// 		100 : "Custom"
	]

	PlayerBattleline(choices) : "Player battleline" : 1 : "Player defines a battle line, applies to allies only" =
	[
		0 : "No"
		1 : "Yes"
	]

	StayAtCover(choices) : "Stay at cover location" : 0 : "When have suitable cover, don't change it (disables advancing to battle line)" =
	[
		0 : "No"
		1 : "Yes"
	]

	AbandonIfEnemyHides(choices) : "Abandon if enemies hide" : 0 : "If no enemy detected recently, stop the standoff" =
	[
		0 : "No"
		1 : "Yes"
	]

	// Custom aggression
//	CustomCoverOnReload(choices)	: "Custom: Take cover to reload" : 1 =
//	[
//		0 : "No"
//		1 : "Yes"
//	]
//	CustomMinTimeShots(float)		: "Custom: Min time wait to shoot"	  : 2 : "Minimum duration of time after a burst of shooting before trying again"
//	CustomMaxTimeShots(float)		: "Custom: Max time wait to shoot"	  : 4 : "Minimum duration of time after a burst of shooting before trying again"
//	CustomMinShots(integer)			: "Custom: Min shots in a burst"	  : 1
//	CustomMaxShots(integer)			: "Custom: Max shots in a burst"	  : 4
//	CustomOddsCover(integer)		: "Custom: Odds cover on damage"	  : 25 : "If damaged, the chances react by taking immediate cover"

	// Inputs
	input Activate( void ) : "Begin contesting position"
	input Deactivate( void ) : "Cease contesting position"
	input SetAggressiveness(integer) : "Set aggressiveness"
]

@PointClass base(Targetname, Parentname, Angles) sphere(policeradius) iconsprite("editor/ai_goal_police.vmt") = ai_goal_police : "AI Goal Police"
[
	spawnflags(Flags) = 
	[
		2 : "Knock-out target past crossing plane"	: 0
		4 : "Do not leave post" : 0
	]

	policeradius(float) : "Radius" : 512 : "Radius to police"
	policetarget(string) : "Target" : "" : "Target to police"

	input EnableKnockOut(void) : "Tells the goal to make the active policing NPC knock out its target"
	input DisableKnockOut(void) : "Stop the active policing NPC from trying to knock out its target"

	output OnFirstWarning(void) : "Fires the first time a policing cop warns a target"
	output OnSecondWarning(void) : "Fires the second time a policing cop warns a target"
	output OnLastWarning(void) : "Fires when a policing cop warns a target for the last time"
	output OnSupressingTarget(void) : "Fires when a policing cop starts to suppress (ie. beat) a target"
	output OnKnockOut(void) : "Fires when a target has been knocked out"
]

@PointClass base(Targetname, Parentname, Angles) iconsprite("editor/assault_rally.vmt") line(255 255 255, targetname, assaultpoint) = assault_rallypoint : "(Assault) rally point"
[
	assaultpoint(target_destination) 	: "Assault Point" : "" : "Location to move to as assault begins"
	assaultdelay(float)		: "Assault Delay" : 0 : "How long to wait after cue is given before assault begins."
	rallysequence(string)	: "Rally Sequence" : "" : "Override the NPC's wait activity by entering a sequence name."
	priority(integer)		: "Priority" : 1 : "Higher priority rally points get selected first."

	output OnArrival(void)	: "Fires when the NPC reaches this rally point"
]

@PointClass base(Targetname, Parentname, Angles) iconsprite("editor/assault_point.vmt") line(255 255 255, targetname, nextassaultpoint) = assault_assaultpoint : "(Assault) assault point"
[
	assaultgroup(string) 	: "Assault Hint Group" : "" : "NPC's movements are constrained to this hint group once assault has begun"
	nextassaultpoint(target_destination) : "Next assault point (optional)"
	assaulttimeout(float)	: "Assault time out" : "3.0" : "This point is cleared when no enemies are seen for this long (seconds)"
	clearoncontact(choices) : "Clear on contact with enemies" : 0 : "If you come in contact with enemies while approaching the assault point, clear our assault point" =
	[
		0 : "No"
		1 : "Yes"
	]
	allowdiversion(choices) : "Allow diversion" : 0 : "If you come in contact with enemies while approaching the assault point, divert to kill them. Resume the assault once contact is lost." =
	[
		0 : "No"
		1 : "Yes"
	]

	nevertimeout(choices) : "Never Timeout" : 0 : "If set, the assault never ends for NPCs assaulting this point. Useful for forcing NPCs back to a point." =
	[
		0 : "No"
		1 : "Yes"
	]

	spawnflags(Flags) = 
	[
		1 : "Clear this point upon arrival, UNCONDITIONALLY"	: 0
	]

	// Inputs
	input SetClearOnContact(integer) : "Set the clear on contact flag."
	input SetAllowDiversion(integer) : "Set the allow diversion flag."

	// Outputs
	output OnArrival(void)	: "Fires when the NPC reaches this assault point"
	output OnAssaultClear(void)	: "Fires when this assault point is cleared of enemies"
]

@PointClass base(Targetname) = ai_goal_assault : "AI Goal Assault"
[
	actor(target_name_or_class)		: "Actor(s) to affect" : "" : "NPC's that should perform this assault"
	rallypoint(target_destination)	: "Rally Point Set" : "" : "Root name of rally points for this assault. Use an asterisk '*' after the root name to match all with the same root."

	SearchType(choices) : "Search Type" : 0 : "How to search for the entities using the targetname." = 
	[
		0 : "Entity Name"
		1 : "Classname"
	] 

	StartActive(choices) : "Start Active" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]

	AssaultCue(choices) : "Assault Cue" : 1 =
	[
		1 : "Entity System Input"
		2 : "Gunfire"
		3 : "Don't wait for a cue."
	]

	// Inputs
	input Activate( void ) : "Begin the assault behavior"
	input Deactivate( void ) : "Cease the assault behavior"
	input BeginAssault( void ) : "Begin assault phase"
]

@BaseClass base(Targetname) = BaseActBusy
[
	actor(target_name_or_class)	: "Actor(s) to affect" : "" : "NPC's that should act busy"

	StartActive(choices) : "Start Active" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]

	SearchType(choices) : "Search Type" : 0 : "How to search for the entities using the targetname." = 
	[
		0 : "Entity Name"
		1 : "Classname"
	] 

	busysearchrange(float) : "Search Range for Busy Hints" : 2048
	visibleonly(choices) : "Visible Busy Hints Only" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]

	// Inputs
	input Activate( void ) : "Begin acting busy"
	input Deactivate( void ) : "Cease acting busy"
	input SetBusySearchRange( float ) : "Update the busy search range for all actors."
	input ForceNPCToActBusy( string ) : "Force an NPC to act busy. Takes parameters, separated by spaces: <Targetname> <hint node targetname> <optional:teleport> <optional:$customactivityorsequence> <maximum time to actbusy>. If no hint node targetname is specified, it'll search for a random one. If no max time is specified, it'll use the default. Specifying 0 as the max time will make the NPC act busy until disturbed. If the optional teleport parameter is specified, the NPC will teleport to the act busy point. A custom move animation can be specified by prepending $ to the name of it. i.e. $ACT_RUN will make the NPC Run. Sequence names can be used instead of activities."
	input ForceThisNPCToActBusy( string ) : "Force an NPC outputted from another entity to act busy. (only usable from an output that specifies an entity)"
	input ForceThisNPCToLeave( string ) : "Force an NPC outputted from another entity to find a HINT_NPC_EXIT_POINT hintnode and vanish."

	// Outputs
	output OnNPCStartedBusy(string) : "Fired when an NPC targeted by this goal starts an ActBusy animation."
	output OnNPCFinishedBusy(string) : "Fired when an NPC targeted by this goal finishes an ActBusy."
	output OnNPCLeft(string) : "Fired when an NPC target by this goal finishes a forced Leave."
]

@PointClass base(BaseActBusy) = ai_goal_actbusy : "AI Goal Act Busy"
[
]

@PointClass base(BaseActBusy) = ai_goal_actbusy_queue : "AI Goal Act Busy Queue"
[
	node_exit(target_destination) : "Exit Node" : "" : "The name of the node the first NPC in the queue should move to when he leaves the head of the queue."
	node01(target_destination) : "Node 1" : "" : "The name of the first actbusy hint node in the queue."
	node02(target_destination) : "Node 2" : "" : "The name of the second actbusy hint node in the queue."
	node03(target_destination) : "Node 3" : "" : "The name of the third actbusy hint node in the queue."
	node04(target_destination) : "Node 4" : "" : "The name of the fourth actbusy hint node in the queue."
	node05(target_destination) : "Node 5" : "" : "The name of the fifth actbusy hint node in the queue."
	node06(target_destination) : "Node 6" : "" : "The name of the sixth actbusy hint node in the queue."
	node07(target_destination) : "Node 7" : "" : "The name of the seventh actbusy hint node in the queue."
	node08(target_destination) : "Node 8" : "" : "The name of the eighth actbusy hint node in the queue."
	node09(target_destination) : "Node 9" : "" : "The name of the ninth actbusy hint node in the queue."
	node10(target_destination) : "Node 10" : "" : "The name of the tenth actbusy hint node in the queue."
	node11(target_destination) : "Node 11" : "" : "The name of the eleventh actbusy hint node in the queue."
	node12(target_destination) : "Node 12" : "" : "The name of the twelfth actbusy hint node in the queue."
	node13(target_destination) : "Node 13" : "" : "The name of the thirteenth actbusy hint node in the queue."
	node14(target_destination) : "Node 14" : "" : "The name of the fourteenth actbusy hint node in the queue."
	node15(target_destination) : "Node 15" : "" : "The name of the fifteenth actbusy hint node in the queue."
	node16(target_destination) : "Node 16" : "" : "The name of the sixteenth actbusy hint node in the queue."
	node17(target_destination) : "Node 17" : "" : "The name of the seventeenth actbusy hint node in the queue."
	node18(target_destination) : "Node 18" : "" : "The name of the eighteenth actbusy hint node in the queue."
	node19(target_destination) : "Node 19" : "" : "The name of the nineteenth actbusy hint node in the queue."
	node20(target_destination) : "Node 20" : "" : "The name of the twentieth actbusy hint node in the queue."
	 
	mustreachfront(choices) : "Must Reach Front" : 0 : "If true, NPCs much reach the front node in the queue before they're allowed to leave the queue." =
	[
		0 : "No"
		1 : "Yes"
	]

	// Inputs
	input PlayerStartedBlocking(float) : "Tell the queue manager that the player has started blocking a spot in the queue."
	input PlayerStoppedBlocking(float) : "Tell the queue manager that the player has stopped blocking a spot in the queue."
	input MoveQueueUp(void) : "Force the queue to move up, sending the front-most NPC out of the queue."

	// Outputs
	output OnQueueMoved(float) : "Fired when the queue moves. Outputs the number of NPCs left in the queue."
	output OnNPCStartedLeavingQueue(string) : "Fired when the NPC at the head of the queue starts to leave. The activator is the NPC, and the string is the name of the NPC."
	output OnNPCLeftQueue(string) : "Fired when the NPC at the head of the queue leaves. The activator is the NPC, and the string is the name of the NPC."
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = ai_changetarget : "Used to change the 'target' key of another entity, such as an NPC or a trigger_teleport."
[
	target(target_destination) : "Target entity" : : "Name of entity whose target will be changed."
	m_iszNewTarget(string) : "New Target"

	input Activate(void) : "Changes the entity's target."
]

@PointClass base(Targetname) sphere(Radius)  size(-8 -8 -8, 8 8 8) = ai_changehintgroup : "Change Hint Group"
[
	SearchType(choices) : "Search Type" : 0 : "How to search for the entities to change." = 
	[
		0 : "Entity Name"
		1 : "Classname"
		2 : "Old Hint Group"
	] 
	SearchName(string) : "Name to search for"
	NewHintGroup(string) : "New Hint Group"
	Radius(string) : "Search Radius" : "0.0" : "Radius to search (0 for all of map)"
	hintlimiting(choices) : "Hint Limit Nav" : 0 : "Limits NPC to using specified hint group for navigation requests, does not limit local navigation." =
	[
		0 : "No"
		1 : "Yes"
	]

	input Activate( void ) : "Change the Hint Group"
]

@PointClass base(Targetname) = ai_script_conditions : "AI Script Conditions"
[
	Actor(target_destination) : "Actor" : : "NPC Target"
	
	StartDisabled(choices) : "Start Disabled" : 1 =
	[
		0 : "No"
		1 : "Yes"
	]

	MinimumState(choices) : "Minimum state" : 1 =
	[
		1 : "Idle"
		2 : "Alert"
		3 : "Combat"
	]

	MaximumState(choices) : "Maximum state" : 3 =
	[
		1 : "Idle"
		2 : "Alert"
		3 : "Combat"
	]
	
	ScriptStatus(choices) : "Actor is running a script?" : 0 =
	[
		0 : "No"
		1 : "Yes"
		2 : "Don't care"
	]
		
	RequiredTime(float)		: "Required Time"	  : 0 : "Duration of time that all the conditions must be true"
	MinTimeout(float)		: "Minimum time out"  : 0 : "Minimum time before OnConditionsTimeout is fired. 0 = never expire"
	MaxTimeout(float)		: "Maximum time out"  : 0 : "Maximum time before OnConditionsTimeout is fired. 0 = ignore"
	
	ActorSeePlayer(choices) : "Actor Sees Player" : 2 =
	[
		0 : "No"
		1 : "Yes"
		2 : "Don't care"
	]

	PlayerActorProximity(float)	: "Player distance" 	 : 0 : "The distance the player must/must not be to the actor. Negative values for NOT, 0 for ignore."
	PlayerActorFOV(float)		: "Player FOV for Actor " : 360 : "Specify angle of view cone in degrees. Negative value = NOT"
	PlayerActorFOVTrueCone(choices ) : "Play FOV to Actor is a true view cone" : 0 : "Player's view cone is evaluated as a true cone, not pie slice " = 
	[
		0 : "No - Tall pie slice"
		1 : "Yes - True view cone"
	]

	PlayerActorLOS(choices)		: "Player has LOS to Actor" : 2 : "Checks that the player has clear Line of Sight to the Actor" =
	[
		0 : "No"
		1 : "Yes"
		2 : "Don't care"
	]


	target(target_destination)	: "Target (Optional)" : : "Optional entity to include in conditions"
	ActorSeeTarget(choices) 	: "Actor Sees Target" : 2 =
	[
		0 : "No"
		1 : "Yes"
		2 : "Don't care"
	]

	ActorTargetProximity(float)		: "Target distance" 	 : 0 : "The distance the actor must/must not be to the Target. Negative values for NOT, 0 for ignore."
	PlayerTargetProximity(float)	: "Player distance from Target" 	 : 0 : "The distance the player must/must not be to the Target. Negative values for NOT, 0 for ignore."
	PlayerTargetFOV(float)			: "Player FOV for Target" : 360 : "Specify angle of view cone in degrees. Negative value = NOT"
	PlayerTargetFOVTrueCone(choices ) : "Play FOV to Target is a true view cone" : 0 : "Player's view cone is evaluated as a true cone, not pie slice " = 
	[
		0 : "No - Tall pie slice"
		1 : "Yes - True view cone"
	]

	PlayerTargetLOS(choices)		: "Player has LOS to Target" : 2 : "Checks that the player has clear Line of Sight to the Target" =
	[
		0 : "No"
		1 : "Yes"
		2 : "Don't care"
	]
	
	PlayerBlockingActor(choices)	: "Player blocking Actor" : 2 : "Checks that the player is blocking the Actor's path" =
	[
		0 : "No"
		1 : "Yes"
		2 : "Don't care"
	]

	
	// Outputs
	output OnConditionsSatisfied(void) : "Fires when AI conditions satisfied"
	output OnConditionsTimeout(void)   : "Fires when AI conditions timed out"

	// Inputs
	input Enable(void) : "Enable this entity"
	input Disable(void) : "Disable this entity"
]

@PointClass base(BaseScripted, Angles, DXLevelChoice) studioprop("models/editor/scriptedsequence.mdl") sphere(m_flRadius) = scripted_sequence :
	"Grabs an NPC and makes them play a specified set of animations. The NPC can be told to move to the scripted sequence position or can "+
	"be told to play the script wherever they currently are. "+
	"Multiple scripted sequences of the same name will frame-synchronize in the action animation once all the actors have moved to position. "+
	"This allows tight interaction between actors (one actor grabbing another, hitting them, etc.) The flow is as follows:\n\n"+
	"1) Move to position using the specified movement animation. If 'Move to Position' is set to NONE, skip to step 2.\n"+
	"2) If forced to wait for another actor to move to position, play the pre-action idle animation, otherwise skip to step 3. If there is no pre-action idle specified, ACT_IDLE is used.\n"+
	"3) Fire the OnBeginSequence output.\n"+
	"4) Play the action animation. If no action animation is specified, skip to step 5.\n"+
	"5) Play the post-action idle animation. If none is specified, skip to step 6. If the 'Loop in Post Idle' spawnflag is set, keep playing the post-action idle until the script is cancelled. If no post-action idle animation is specified, ACT_IDLE is used.\n"+
	"6) Fire the OnEndSequence output.\n"+
	"7) If a next script to play is specified, hand the NPC to the next script and repeat this process for that script.\n\n"+
	"The MoveToPosition input runs steps 1 and 2, then waits while playing the pre-action idle animation until the BeginSequence input is received."
[
	spawnflags(Flags) = 
	[
		4 : "Repeatable"	: 0
		8 : "Leave Corpse"	: 0
		16 : "Start on Spawn" : 0
		32: "No Interruptions"	: 0
		64: "Override AI"	: 0
		128: "No Script Movement" : 0
		256: "Loop in Post Idle" : 0
		512: "Priority Script" : 0
	]
]


@PointClass base(Targetname) sphere(m_flRadius) color(255 0 255) iconsprite("editor/aiscripted_schedule") = aiscripted_schedule :
	"Issues a command to an NPC without taking the NPC out of its AI. This does not seize control of the NPC as " +
	"a scripted_sequence does" 
[
	m_iszEntity(target_destination) : "Target NPC" : : "The name or classname of an NPC to use."
	m_flRadius(integer) : "Search Radius (0=everywhere)" : 0 : "Radius to search within for an NPC to use. 0 searches everywhere."

	graball(choices) 	: "All in radius" : 0: "Whether to grab all matching NPCs in the specified radius, instead of just one"  =
	[
		0 : "No"
		1 : "Yes"
	]

	spawnflags(Flags) = 
	[
		4 : "Repeatable" : 0
		1024 : "Search Cyclically" : 0
		2048 : "Don't Complain" : 0
	]

	forcestate(choices) : "AI state to set" : 0 =
	[
		0 : "<None>"
		1 : "Set state to IDLE"
		2 : "Set state to ALERT"
		3 : "Set state to COMBAT"
	]
		
	schedule(choices) : "Schedule to run" : 1 =
	[
		0 : "<None>"
		1 : "Walk to Goal Entity"
		2 : "Run to Goal Entity"
		3 : "Set enemy to Goal Entity"
		4 : "Walk Goal Path"
		5 : "Run Goal Path"
		6 : "Set enemy to Goal Entity AND Run to Goal Entity"
	]
	
	interruptability(choices) : "Interruptability" : 0 =
	[
		0 : "General"
		1 : "Damage or Death"
		2 : "Death"
	]

	goalent(target_destination) : "Goal entity" : : "Provides the name of a schedule-specific goal entity (see 'Schedule to run')"

	input StartSchedule(void) : "Starts the scripted schedule. This will first locate an NPC that " +
		"matches the given target, then tell the NPC to run the specified schedule."
]

@PointClass base(Targetname) = ai_citizen_response_system :
	"If placed in the level, allows gunships to inform citizens that they have died (the citizens can then tell Gordon all about it),"+
	"and allows other entities to tell a citizen that an important NPC has died (again, the nearest citizen tries to relay this information to Gordon)."
[
	input ResponseVitalNPC(void) : "Fire the TLK_VITALNPC_DIED ('No! No!') response."
]

@PointClass base(Targetname, Parentname) iconsprite("editor/ai_sound.vmt") = ai_sound :
	"This entity makes sounds or smells that can be sensed by NPCs, butnot by the player. This can be used " +
	"to cause reactions in nearby NPCs.\n\n" +
	"Sound Types\n" +
	"  Combat: Will cause most NPCs to become alert\n" +
	"  World: Will cause most NPCs to become alert\n" +
	"  Danger: Will cause most NPCs to move away from the position of the sound\n" +
	"  Bullet Impact: \n" +
	"  Carcass: \n" +
	"  Meat: \n" +
	"  Garbage: \n" +
	"  Thumper: causes antlions to run away briefly\n" +
	"  Readiness: (Low, Medium, High) Causes player companions that can hear this sound to change readiness"
[
	input InsertSound(Integer) : "Insert a sound in the AI sound list"

	soundtype(choices) : "Sound Type" : 0 : "The type of sound or smell will determine the reaction of NPCs that sense it." =
	[
		1: "Combat"
		2: "World"
		//4: "Player (Don't use)"
		8: "Danger"
		16: "Bullet Impact"
		32: "Carcass"
		64: "Meat"
		128: "Garbage"
		256: "Thumper"
		16384 : "Readiness - Low"
		32768 : "Readiness - Medium"
		65536 : "Readiness - High"
	]

	locationproxy(target_destination) : "Location Proxy" : "" : "The name of an entity to use as a proxy to determine the location at which to make the sound. If you specify an entity here, the sound will be made at that entity's location (!player included)" 
]

//-------------------------------------------------------------------------
//
// Solid Entities
//
//-------------------------------------------------------------------------

@SolidClass base(Targetname, Global, Parentname, Origin, EnableDisable) = func_healthcharger: "Wall health recharger" 
[
	output OutRemainingHealth(float) : "Remaining Health."
	output OnPlayerUse(void) : "Fired when the player +USEs the charger."
]

@SolidClass base(Targetname, Parentname, Origin) = func_recharge: "Battery recharger" 
[
	spawnflags(flags) =
	[
		8192  : "Citadel recharger" : 0
	]

	input Recharge(void) : "Recharge to full"

	output OutRemainingCharge(float) : "Remaining Charge."
	output OnHalfEmpty(void) : "Half-Empty"
	output OnEmpty(void) : "Empty"
	output OnFull(void) : "Recharged to full."
	output OnPlayerUse(void) : "Fired when the player +USEs the charger."
]

@SolidClass base(Targetname, Parentname, Global) = func_vehicleclip: "Vehicle Clip" 
[
]

@SolidClass base(func_movelinear) = func_lookdoor : "A door that moves either when looked by a targeted object or when " +
	"a target object comes near the door.  Behavior can be either based on viewing direction or proximity " +
	"alone, or on a combination of both.  If inverted the doors behavior will be the opposite." 
[
	spawnflags(flags) =
	[
		8192  : "LookDoor Threshold" : 0
		16384 : "LookDoor Invert"	 : 0
		32768 : "LookDoor From Open" : 0
	]

	ProximityDistance(string)		: "Proximity Distance"		: "0.0"  : "If non-zero, proximity range over which door will move"
	ProximityOffset(string)			: "Proximity Offset"		: "0.0"	 : "Offset from the target object"
	FieldOfView(string)				: "FieldOfView"				: "0.0"  : "If non-zero, field of view over which door will move"

	// Input
	input InvertOn(void)		: "InvertOn - when set behavior of door is inverted."
	input InvertOff(void)		: "InvertOff - when set behavior of door is normal."
]

//-------------------------------------------------------------------------
//
// Tanks
//
//-------------------------------------------------------------------------

// Call this only on entities that use CFuncTank, not CFuncTankGun
@BaseClass base(Targetname, Parentname, Origin, Angles, RenderFields, Global, DamageFilter) = BaseTank
[
	spawnflags(flags) =
	[
		1 : "Active" : 0
		16: "Only Direct (don't trace target if target's not in LOS)" : 0
		32: "Player Controllable" : 0
		64: "Take Damage" : 0
		256 : "Aiming assistance (player only: make bullets hit objects that they barely miss)" : 0
	    1024: "NPC Controllable" : 0
	    4096: "Allow friendlies to hit player" : 0
		8192: "If NPC-controlled, ignore range" : 0
	    32768: "Nonsolid" : 0
	]

	// health - goes with DamageFilter, immediately above it
	health(float) : "Health" : "100" : "If the 'Take Damage' flag is set, this is the amount of damage the tank can take before it dies."

	// controller stuff
	control_volume(target_destination) : "Control Volume" : "" : "Name of a trigger that specifies the volume in which a player must be to control this tank.  Trigger_multiple works nicely.  Note that the trigger must have its flags set such that it detects players (Clients)."
	npc_man_point(target_destination) : "NPC Man Point" : "" : "Point where NPC must stand to man this func_tank.  An info_target works nicely."

	// speed, range, location from which to fire
	yawrate(string) : "Yaw rate" : "30" : "Used to clamp the left/right turning speed of the gun.  Try 800 for a fast gun."
	yawrange(string) : "Yaw range" : "60" : "How far the gun is allowed to turn left or right, in degrees."
	yawtolerance(string) : "Yaw tolerance" : "15" : "Maximum distance the gun is allowed to turn once the range is breached.  If the gun turns beyond (range + tolerance), then it will snap back to its range until it is within (range + tolerance) again."
	pitchrate(string) : "Pitch rate" : "0" : "Used to clamp the up/down turning speed of the gun.  Try 800 for a fast gun."
	pitchrange(string) : "Pitch range" : "0" : "How far the gun is allowed to turn up or down, in degrees."
	pitchtolerance(string) : "Pitch tolerance" : "5" : "Maximum distance the gun is allowed to turn once the range is breached.  If the gun turns beyond (range + tolerance), then it will snap back to its range until it is within (range + tolerance) again."
	barrel(string) : "Barrel Length" : "0" : "Distance from the origin to the front of the barrel along the X axis.  Determines how far from the origin bullets should be shot from."
	barrely(string) : "Barrel Horizontal" : "0" : "Distance from the origin to the center of the barrel along the Y axis.  Determines how far from the origin bullets should be shot from."
	barrelz(string) : "Barrel Vertical" : "0" : "Distance from the origin to the center of the barrel along the Z axis.  Determines how far from the origin bullets should be shot from."

	// sprites
	spritesmoke(sprite) : "Smoke Sprite" : "materials/sprites/steam1.vmt" : "The sprite to display at the end of the barrel for smoke."
	spriteflash(sprite) : "Flash Sprite" : "materials/sprites/muzzleflash1.vmt" : "The sprite to display at the end of hte barrel for a flash."
	spritescale(string) : "Sprite scale" : "0.5" : "Amount by which to scale the smoke and flash sprites."

	// sounds
	rotatestartsound(sound) : "Rotate Start Sound" : "" : "Sound to play when the gun begins turning.  Don't use a sound that's intended to loop!"
	rotatesound(sound) : "Rotate Loop Sound" : "" : "Sound to loop while the gun is turning."
	rotatestopsound(sound) : "Rotate Stop Sound" : "" : "Sound to play when the gun stops turning.  Don't use a sound that's intended to loop!"

	// bullet stuff
	firerate(string) : "Rate of Fire" : "1" : "Rate of fire, in bullets/second.  Also determines how many bullets an NPC-controlled tank will fire at a time."
	ammo_count(integer) : "Ammunition Count" : -1 : "The number of bullets this tank can fire before it runs out.  Applies to both player and NPC use.  -1 == infinite ammo."
	effecthandling(choices) : "Play AR2 sound?" : 0 : "Whether to play the AR2 fire sound when a bullet is fired." =
	[
		"" : "No"
		"EH_AR2" : "Yes"
	]

	// accuracy and when to fire
	persistence(string) : "Firing persistence" : "1" : "When I lose sight of my target, how long should I continue firing at his last known position?"
	persistence2(string) : "Firing persistence2" : "0" : "After the persistence time has passed, I will occasionally fire at my target's last known position until this number of seconds passes."
	playerlocktimebeforefire(float) : "Player Lock Time" : "0" : "The tank must have the player as a target for this amount of time before it's allowed to fire."
	playergraceperiod(float) : "Post-NPC Attack Grace Period" : "0" : "If specified, NPCs manning this gun won't fire at the player, after firing at a non-player, for this amount of time."
	ignoregraceupto(float) : "Ignore Grace Upto" : "768" : "The player grace period is ignored if the player is within this distance of the func_tank."
	LeadTarget(choices) : "Lead Target" : "0" : "If the target is moving, should the tank attempt to improve its accuracy by aiming a little in front of it?" =
	[
		0 : "No"
		1 : "Yes"
	]
	minRange(float) : "Minimum target range" : "0" : "Targets will not be fired at unless it is between the minimum and maximum range.  0 = disable."
	maxRange(float) : "Maximum target range" : "0" : "Targets will not be fired at unless it is between the minimum and maximum range.  0 = disable."

	// attachment stuff
	gun_base_attach(string) : "Gun Base Attachment" : "" : "If Parent is specified, this is the attachment point on the parent to aim from."
	gun_barrel_attach(string) : "Gun Barrel Attachment" : "" : "If Parent is specified, this is the attachment point on the parent to fire from. If you specify this, you'll need to specify the Gun Base Attachment too."
	gun_yaw_pose_param(string) : "Gun Yaw Pose Param" : "" : "If a parent and both Pose Params are specified, the func_tank will steer a gun on the Parent using these parameters.  Available parameters can be found in the model's 'Sequence' tab in HLMV."
	gun_pitch_pose_param(string) : "Gun Pitch Pose Param" : "" : "If a parent and both Pose Params are specified, the func_tank will steer a gun on the Parent using these parameters.  Available parameters can be found in the model's 'Sequence' tab in HLMV."
	gun_yaw_pose_center(float) : "Gun Yaw Pose Center" : "0" : "The center yaw pose parameter of the gun on the parent; that is, once all Angles are considered, the degree of yaw that indicates the center of the gun's horizontal range."
	gun_pitch_pose_center(float) : "Gun Pitch Pose Center" : "0" : "The center pitch pose parameter of the gun on the parent; that is, once all Angles are considered, the degree of pitch that indicates the center of the gun's vertical range."

	// input
	input Activate(void)				: "Turn the gun on."
	input Deactivate(void)				: "Turn the gun off."
	input SetFireRate(string)			: "Set the gun's rate of fire in bullets/second."
	input SetDamage(string)				: "Set the damage per bullet."
	input SetTargetPosition(string)		: "Coordinates to aim at (X Y Z) if the tank is activated without a controller."
	input SetTargetDir(vector)			: "Vector that tells me the point relative to me that I should aim at if I'm activated without a controller.  (?)"
	input SetTargetEntityName(string)	: "Targetname of the entity to track and attack."
	//input SetTargetEntity(string)		: "Ehandle or targetname of the entity to track and attack."
	input ClearTargetEntity(void)		: "Forget the entity that the tank should be shooting.."
	input FindNPCToManTank(string)		: "Tell the specified NPC that he should begin controlling this func_tank, if he's not busy.  If no NPC is specified, find a nearby NPC who can man this tank."
	input StartFindingNPCs(void)		: "Start searching for NPCs to control this func_tank.  Continue searching indefinitely."
	input StopFindingNPCs(void)		: "Stop searching for NPCs to man this func_tank."
	input ForceNPCOff(void)			: "Force the NPC manning this func_tank (if any) to leave."
	input SetMaxRange(float)		: "Set the max range of the func_tank."

	output OnFire(void)				: "Fired when the tank fires."
	output OnAquireTarget(void)		: "Fired when the tank acquires a target and can shoot it."
	output OnLoseTarget(void)		: "Fired when the target hides or moves out of range."
	output OnAmmoDepleted(void)		: "Fired when the tank run out of ammo."
	output OnGotController(void)	: "Fired when an NPC begins to control the tank."
	output OnLostController(void)	: "Fired when the NPC who controls the tank stops controlling it."
	output OnGotPlayerController(void)	: "Fired when a player begins to control the tank."
	output OnLostPlayerController(void)	: "Fired when the player who controls the tank stops controlling it."
	output OnReadyToFire(void) : "Fired when the tank is ready to fire, after the last bullet's been fired and before the next one."
]

// Call this on entities that use CFuncTankGun
@SolidClass base(BaseTank) = func_tank : "A turret that fires bullets of various types.  It can be controlled by a player or an NPC, "+
	"or can fire at a target despite having no controller.  When you create the brushes that make up this entity, ensure that they face EAST, "+
	"and use the entity's Pitch/Yaw/Roll to point it in the direction you'd like it to face.  You can also parent a func_tank to another entity, "+
	"such as an APC, to use that entity and its attachments as mounted guns instead of the func_tank itself."
[
	bullet(choices) : "Bullets" : 1 : "Type of bullet to fire." = 
	[
		0: "None"
		1: "Pistol"
		2: "SMG1"
		3: "AR2"
	]
	bullet_damage(string) : "Damage Per Bullet" : "0" : "Amount of damage dealt by each bullet.  If 0, defaults to the chosen bullet type's damage."
	bullet_damage_vs_player(string) : "Damage Per Bullet Vs Player" : "0" : "Amount of damage dealt to a player by each bullet.  If set to 0, it'll use the Damage Per Bullet value."
	firespread(choices) : "Bullet accuracy" : 0 : "Size of the gun's firing cone." =
	[
		0: "Perfect Shot"
		1: "Small cone (about 4 degrees)"
		2: "Medium cone (about 6 degrees)"
		3: "Large cone (about 13 degrees)"
		4: "Extra-large cone (about 25 degrees)"
	]
]

@SolidClass base(BaseTank) = func_tankairboatgun : "Special case of func_tank intended to control the gun on an airboat.  Set its 'Airboat Gun "+
	"Targetname' to the name of an airboat, and it will automatically attach itself to the airboat in the appropriate spot and play the right "+
	"sounds.  See func_tank for a description of tanks in general."
[
	airboat_gun_model(target_destination) : "Airboat Gun Targetname" : "" : "Name of a prop that is the airboat gun model."
]

@SolidClass base(BaseTank) = func_tankapcrocket : "Special case of func_tank that shoots bursts of homing rockets into the air.  "+
	"This tank's rockets will not target anything unless the tank is controlling itself; that is, if an NPC or player tries to fire it, it "+
	"will do nothing but shoot rockets into the air that never come down.  See func_tank for a description of tanks in general."
[
	rocketspeed(float) : "Projectile speed" : 800 : "Speed the rocket will travel at."
	burstcount(integer) : "Burst shot count" : 10 : "Number of missiles to shoot in each burst."

	input DeathVolley(void) : "Fire a final burst of rockets, then kill the tank."
]

@SolidClass base(BaseTank) = func_tanklaser : "Special case of func_tank that, instead of bullets, fires laser bursts from a given env_laser "+
	"entity.  The env_laser will be moved to the point from which bullets would normally come.  See func_tank for a description of tanks in general."
[
	laserentity(target_destination) : "Env_laser entity"
]

@SolidClass base(BaseTank) = func_tankmortar : "Special case of func_tank that draws a very large arc from itself to the target, then bombs the "+
	"target with a bombshell.  See func_tank for a description of tanks in general."
[
	iMagnitude(Integer) : "Explosion magnitude" : 100 : "How powerful the explosion of the mortar should be."
	firedelay(string) : "Shell travel time" : 2 : "How long after the turret fires before the shell impacts."
	firestartsound(sound) : "Firing start sound" : "" : "Sound of the mortar firing."
	incomingsound(sound) : "Incoming shell sound" : "" : "Sound of the shell falling on the target"
	warningtime(float) : "Incoming warning time" : "1" : "How long before the shell impacts to play the warning sound"
	firevariance(float) : "Fire time variance" : "0" : "Adds a bit of randomness to the fire rate.  Changes the time the tank must wait between each fire by a random number of seconds between this value and its negative."

	input ShootGun(void) : "Fire one mortar at the target, if there is one."
	input FireAtWill(void) : "Allow tank to fire next shot as soon as ready."
]

@SolidClass base(BaseTank) = func_tankphyscannister : "This isn't a tank at all.  It activates physics_cannister entities within the cannister "+
	"volume when it's 'fired,' and can be controlled like a normal tank, but it won't shoot bullets and certainly won't deal damage.  See func_tank "+
	"for a description of tanks in general."
[
	barrel_volume(target_destination) : "Physics_cannister Volume" : "" : "Name of a trigger the specifies the volume in which cannisters must be placed.  Trigger_multiple will work.  Note that the trigger must have its flags set such that it detects physics objects."
]

@SolidClass base(func_tank) = func_tankpulselaser : "WARNING:  BUGGY ENTITY.\n\nSpecial case of func_tank that shoots a laser pulse instead of a bullet.  The pulse tends "+
	"to set flammable entities afire, and it sometimes ricochets off walls and floors (though it is not visible when it does this).  Also, the pulse makes a normal bullet "+
	"sound when it hits a wall, because its intended sounds were not included in HL2.  See func_tank for a description of tanks in general."
[
	PulseSpeed(float)		: "Pulse Speed"		 : 1000		: "How fast the laser pulse travels."
	PulseColor(color255)	: "Pulse Color"		 : "255 0 0" : "The color of the pulse."
	PulseWidth(float)		: "Pulse Width"		 : "20"		: "The width of the pulse sprite."
	PulseLife(float)		: "Pulse Life"		 : 2			: "Amount of time for which the pulse can travel before dying."
	PulseLag(float)			: "Pulse Lag"		 : "0.05"	: "How long after firing the pulse the tank should end the pulse's tail."
	PulseFireSound(sound)   : "Pulse Fire Sound" : ""		: "Sound played when pulse fires."
]

@SolidClass base(BaseTank) = func_tankrocket : "Special case of func_tank that fires RPGs (rockets) instead of bullets.  See func_tank for a "+
	"description of tanks in general."
[
	rocketspeed(float) : "Projectile speed" : 800 : "Speed the rocket will travel at."
	bullet_damage(string) : "Damage Per Rocket" : "50" : "Amount of damage dealt by each rocket."
	bullet_damage_vs_player(string) : "Damage Per Rocket Vs Player" : "50" : "Amount of damage dealt to a player by each rocket."
]

//-------------------------------------------------------------------------
//
// Items and Weapons
//
//-------------------------------------------------------------------------

@BaseClass base(Targetname, Angles, Parentname, RenderFields) color(0 0 200) = WeaponItemBase
[
	input Ignite(void) : "Sets the item on fire."
	output OnIgnite(void) : "Fired when the item is set afire."
]

@BaseClass base(WeaponItemBase) = Weapon
[
	spawnflags(Flags) =
	[
		1 : "Start asleep (don't fall to ground)" : 0
	]

	output OnPlayerUse(void) : "Fires when the player +uses this weapon"
	output OnPlayerPickup(void) : "Fires when the player picks up this weapon"
	output OnNPCPickup(void) : "Fires when an NPC picks up this weapon"
]

@BaseClass base(WeaponItemBase) = Item
[
	output OnPlayerTouch(void) : "Fires when the player touches this object"
]

@PointClass base(Weapon) studioprop("models/weapons/w_crowbar.mdl") = weapon_crowbar : "Crowbar" []
@PointClass base(Weapon) studioprop("models/weapons/w_stunbaton.mdl") = weapon_stunstick : "StunStick" []
@PointClass base(Weapon) studioprop("models/weapons/w_pistol.mdl") = weapon_pistol : "Pistol" []
@PointClass base(Weapon) studioprop("models/weapons/w_irifle.mdl") = weapon_ar2 : "Assault Rifle 2" []
@PointClass base(Weapon) studioprop("models/weapons/w_rocket_launcher.mdl") = weapon_rpg : "Rocket-propelled grenade launcher, missile launcher." []
@PointClass base(Weapon) studioprop("models/weapons/w_smg1.mdl") = weapon_smg1 : "SMG1" []
@PointClass base(Weapon) studioprop("models/weapons/w_357.mdl") = weapon_357 : "357" []
@PointClass base(Weapon) studioprop("models/weapons/w_crossbow.mdl") = weapon_crossbow : "Crossbow" []
@PointClass base(Weapon) studioprop("models/weapons/w_shotgun.mdl") = weapon_shotgun : "Shotgun" []
@PointClass base(Weapon) studioprop("models/weapons/w_grenade.mdl") = weapon_frag : "Frag Grenade" []
@PointClass base(Weapon) studioprop("models/weapons/w_physics.mdl") = weapon_physgun : "Physics Gun.  Buggy." []
@PointClass base(Weapon) studioprop("models/weapons/w_physics.mdl") = weapon_physcannon : "Physics cannon, gravity gun."
[
	spawnflags(Flags) =
	[
		2 : "Start without grab functionality." : 0
	]

	input EnableGrab(void) : "Enable the grab functionality."
]
@PointClass base(Weapon) studioprop("models/Weapons/w_bugbait.mdl") = weapon_bugbait: "Bug bait, pheropods." []
@PointClass base(Weapon) studioprop("models/weapons/W_Alyx_Gun.mdl") = weapon_alyxgun: "Alyx's gun.  Buggy." []
@PointClass base(Weapon) studioprop("models/weapons/W_annabelle.mdl") = weapon_annabelle: "Annabelle (Grigori's shotgun).  Buggy." []
@PointClass base(Weapon) studioprop("models/weapons/W_slam.mdl") = weapon_slam: "HL2DM SLAM:  laser tripmine, remote-detonation explosive" []

@PointClass base(Item) studioprop("models/items/healthkit.mdl") = item_dynamic_resupply : "Dynamic item.  Changes based on the ammo type that the player needs."
[
	spawnflags(Flags) =
	[
		1 : "Use Master's values" : 1
		2 : "Is Master" : 0
	]

	DesiredHealth(float) : "Desired Health Ratio" : "1" : "A ratio from 0 to 1. Attempt to fill the player up to this percentage of his max health."
	DesiredArmor(float) : "Desired Armor Ratio" : "0.3" : "A ratio from 0 to 1. Attempt to fill the player up to this percentage of his max armor."
	DesiredAmmoPistol(float) : "Desired Pistol Ammo Ratio" : "0.5" : "A ratio from 0 to 1. Attempt to fill the player up to this percentage of his max ammo carrying capacity."
	DesiredAmmoSMG1(float) : "Desired SMG1 Ammo Ratio" : "0.5" : "A ratio from 0 to 1. Attempt to fill the player up to this percentage of his max ammo carrying capacity."
	DesiredAmmoSMG1_Grenade(float) : "Desired SMG1 Grenade Ammo Ratio" : "0.1" : "A ratio from 0 to 1. Attempt to fill the player up to this percentage of his max ammo carrying capacity."
	DesiredAmmoAR2(float) : "Desired AR2 Ammo Ratio" : "0.4" : "A ratio from 0 to 1. Attempt to fill the player up to this percentage of his max ammo carrying capacity."
	DesiredAmmoBuckshot(float) : "Desired Shotgun Ammo Ratio" : "0.5" : "A ratio from 0 to 1. Attempt to fill the player up to this percentage of his max ammo carrying capacity."
	DesiredAmmoRPG_Round(float) : "Desired RPG Ammo Ratio" : "0" : "A ratio from 0 to 1. Attempt to fill the player up to this percentage of his max ammo carrying capacity."
	DesiredAmmoGrenade(float) : "Desired Grenade Ammo Ratio" : "0.1" : "A ratio from 0 to 1. Attempt to fill the player up to this percentage of his max ammo carrying capacity."
	DesiredAmmo357(float) : "Desired 357 Ammo Ratio" : "0" : "A ratio from 0 to 1. Attempt to fill the player up to this percentage of his max ammo carrying capacity."
	DesiredAmmoCrossbow(float) : "Desired Crossbow Ammo Ratio" : "0" : "A ratio from 0 to 1. Attempt to fill the player up to this percentage of his max ammo carrying capacity."

	input CalculateType(void) : "Force the dynamic resupply to calculate which item it should spawn."
	input BecomeMaster(void) : "Make this resupply the master resupply. All other resupplies set to Use Master's Values will now use this resupply's values."
]

@PointClass base(Item) studioprop("models/items/boxsrounds.mdl")= item_ammo_pistol : "Box of Pistol ammo" []
@PointClass base(Item) studioprop("models/items/largeBoxSRounds.mdl")= item_ammo_pistol_large : "Large Box of Pistol ammo" []
@PointClass base(Item) studioprop("models/items/BoxMRounds.mdl")= item_ammo_smg1 : "Box of SMG1 ammo" []
@PointClass base(Item) studioprop("models/items/LargeBoxMRounds.mdl")= item_ammo_smg1_large : "Large Box of SMG1 ammo" []
@PointClass base(Item) studioprop("models/items/combine_rifle_cartridge01.mdl")= item_ammo_ar2 : "Box of AR2 ammo" []
@PointClass base(Item) studioprop("models/items/combine_rifle_cartridge01.mdl")= item_ammo_ar2_large : "Large Box of AR2 ammo" []
@PointClass base(Item) studioprop("models/items/357ammo.mdl")= item_ammo_357 : "Box of 357 ammo" []
@PointClass base(Item) studioprop("models/items/357ammobox.mdl")= item_ammo_357_large : "Large Box of 357 ammo" []
@PointClass base(Item) studioprop("models/items/CrossbowRounds.mdl")= item_ammo_crossbow : "Box of Crossbow ammo" []
@PointClass base(Item) studioprop("models/items/BoxBuckshot.mdl")= item_box_buckshot : "Box Buckshot" []
@PointClass base(Item) studioprop("models/weapons/w_missile_closed.mdl")= item_rpg_round : "RPG Round" []
@PointClass base(Item) studioprop("models/items/AR2_Grenade.mdl")= item_ammo_smg1_grenade : "SMG1 Grenade" []
@PointClass base(Item) studioprop("models/items/battery.mdl") = item_battery : "HEV battery" []
@PointClass base(Item) studioprop("models/items/healthkit.mdl") = item_healthkit : "Small Health Kit" []
@PointClass base(Item) studioprop("models/healthvial.mdl") = item_healthvial : "Personal Health Kit" []
@PointClass base(Item) studioprop("models/items/combine_rifle_ammo01.mdl") = item_ammo_ar2_altfire : "AR2 Alt-fire Round" []
@PointClass base(Item) studioprop("models/items/hevsuit.mdl") = item_suit : "HEV Suit" 
[
	spawnflags(Flags) =
	[
		1 : "Short Logon" : 0
	]
]

@PointClass base(Targetname, Angles, RenderFields) studioprop("models/items/ammocrate_rockets.mdl") = item_ammo_crate : "Ammo crate."
[
	AmmoType(choices) : "Ammo Type" : 0 =
	[
		0 : "Pistol"
		1 : "SMG1"
		2 : "AR2"
		3 : "RPG Rounds"
		4 : "Buckshot"
		5 : "Grenades"
		6 : "357"
		7 : "XBowBolt"
		8 : "AR2 Alt-Fire Round"
	]

	// Inputs
	output OnUsed(void) : "Fired when used by the player."
]

@PointClass base(BasePropPhysics) studioprop("models/items/item_item_crate.mdl") = item_item_crate : "A crate that contains an item."
[
	CrateType(choices) : "Crate Contains" : 0 =
	[
		0 : "Contains specified item"
	]

	ItemClass(pointentityclass) : "Item Type" : "item_dynamic_resupply" : "Classname of the entity to spawn when the crate is broken."
	ItemCount(integer) : "Item Count" : 1 : "Number of items to spawn."
]

@PointClass base(Targetname, Angles) studioprop( "models/props_combine/health_charger001.mdl" ) = item_healthcharger : "Health Charger"
[
	output OutRemainingHealth(float) : "Remaining Health."
	output OnPlayerUse(void) : "Fired when the player +USEs the charger."
]

@PointClass base(Targetname, Angles) studioprop( "models/props_combine/suit_charger001.mdl" ) = item_suitcharger : "Battery recharger"
[
	spawnflags(flags) =
	[
		8192  : "Citadel recharger (give full health and 200 armor)" : 0
		16384 : "Kleiner's recharger (give exactly 25 armor)" : 0
	]

	input Recharge(void) : "Recharge this charger to full."

	output OutRemainingCharge(float) : "Fired when the amount of charge changes.  Passes the remaining charge along as a parameter."
	output OnHalfEmpty(void) : "Fired when half empty."
	output OnEmpty(void) : "Fired when empty."
	output OnFull(void) : "Fired when fully recharged."
	output OnPlayerUse(void) : "Fired when the player uses the charger."
]

//
// end weapons + items
//

@SolidClass base(Trigger) = trigger_rpgfire : "A volumetric trigger that triggers whenever an RPG is fired within it."
[
	output OnTrigger(void) : "Fired whenever the trigger is activated."
]

@SolidClass base(Trigger) = trigger_vphysics_motion :
	"A volumetric trigger that affects the motion of vphysics objects that touch it."
[
	spawnflags(Flags) =
	[
		4096 : "Can move (through hierarchical attachment)" : 0
	]

	filtername(filterclass) : "Filter Name" : : "Filter to use to see if activator triggers me. See filter_activator_name for more explanation."
	SetGravityScale(float) : "Scale gravity of objects in the field." : "1.0"
	input SetGravityScale(float) : "Scale gravity of objects in the field."

	SetAdditionalAirDensity(float) : "Additional air density for drag" : "0"
	input SetAdditionalAirDensity(float) : "Additional air density for drag"

	SetVelocityLimit(float) : "Max velocity in field (0 disables)" : "0.0"
	input SetVelocityLimit(float) : "Max velocity in field."

	SetVelocityLimitDelta(float) : "Max amount to reduce velocity per second when it exceeds the velocity limit (0 disables)" : "0.0"
	input SetVelocityLimitDelta(float) : "Max amount to reduce velocity per second"
	input SetVelocityLimitTime(string) : "Accepts two arguments: the first is the new velocity limit, the second is the time it takes to ramp to that value"

	SetVelocityScale(float) : "Velocity scale/drag" : "1.0"
	input SetVelocityScale(float) : "Velocity scale/drag"

	SetAngVelocityLimit(float) : "Max angular velocity in field (degrees/s, 0 disables)" : "0.0"
	input SetAngVelocityLimit(float) : "Max angular velocity in field."

	SetAngVelocityScale(float) : "Angular Velocity scale/drag" : "1.0"
	input SetAngVelocityScale(float) : "Angular Velocity scale/drag"

	SetLinearForce(float) : "Linear force (0 disables)" : "0.0"
//	input SetLinearForce(float) : "Linear force (0 disables)"

	SetLinearForceAngles(angle) : "Direction of linear force (Pitch Yaw Roll (Y Z X))" : "0 0 0"
//	input SetLinearForceAngles(angle) : "Direction of linear force (Pitch Yaw Roll (Y Z X))"

	ParticleTrailMaterial(string) : "Particle Trail Material" : : "Name of a material to use for the particle trail, no name means no particle trail"
	ParticleTrailLifetime(float) : "Particle Trail Lifetime" : 4 : "Lifetime of the particles to emit"
	ParticleTrailStartSize(float) : "Particle Trail Starting Sprite Size" : 2 : "Starting size of the sprite to emit"
	ParticleTrailEndSize(float) : "Particle Trail Ending Sprite Size" : 3 : "Ending size of the sprite to emit"
]

@PointClass base(Targetname) size( 16 16 16) sphere(radius) color( 255 255 0 ) = point_bugbait : "Bugbait sensor point"
[
	Enabled(choices) : "Start Enabled" : 1 =
	[
		0 : "No"
		1 : "Yes"
	]

	spawnflags(Flags) =
	[
		1: "Do not call antlions to position" : 0
		2: "Don't activate on thrown bugbait splashes" : 0
		4: "Don't activate on squeezed bugbait" : 0
	]

	radius(integer) : "Sensor Radius" : 512

	// Inputs
	input	Enable(void) : "Enable the sensor."
	input	Disable(void): "Disable the sensor."
	input	Toggle(void) : "Toggle the sensor."

	// Outputs
	output OnBaited(void) : "Fires when bugbait lands within a radius of the sensor."
]

@PointClass base(Targetname, Angles) size(16 16 16) line(255 255 255, targetname, target) color(247 181 82) = path_corner : "Generic path point"
[
	spawnflags(Flags) =
	[
		1: "Wait for retrigger" : 0
		2: "Teleport to THIS path_corner" : 0
	]
	target(target_destination) : "Next stop target"
	wait(integer) : "Wait here (secs)" : 0
	speed(integer) : "New Train Speed" : 0
	yaw_speed(integer) : "New Train rot. Speed" : 0

	// Inputs 
	input SetNextPathCorner(string) : "Sets next pathcorner"

	// Outputs
	output OnPass(void) : "Fires when a path follower passes this point"
]

@PointClass size( -4 -4 -4, 4 4 4 ) base(Targetname, Parentname) studioprop("models/props_combine/combine_mine01.mdl") = combine_mine : "Combine Land Mine"
[
	bounce(choices) : "Bounce" : 1 : "Whether the mine should bounce up in the air before exploding." =
	[
		0: "No"
		1: "Yes"
	]

	LockSilently(choices) : "Lock Silently" : 1 : "If yes, mine plays no sound when clamps close" =
	[
		0: "No"
		1: "Yes"
	]

	StartDisarmed(choices) : "Start Disarmed" : 0 : "If yes, mine begins dormant." =
	[
		0 : "No"
		1 : "Yes"
	]

	// Outputs
	output OnPulledUp(void) : "Fires when this mine is uprooted with physgun"

	// Inputs
	input Disarm(void) : "Disarm this mine (open hooks and shut off) if not placed by player."

]

//-------------------------------------------------------------------------
//
// Vehicles.
//
//-------------------------------------------------------------------------
@BaseClass base(Targetname, Origin, Global, prop_static_base) = BaseVehicle
[
	vehiclescript(choices) : "Vehicle Script File" : "scripts/vehicles/jeep_test.txt" : "Vehicle script file:  controls variables such as inertia, turn speed, etc." =
	[
		"scripts/vehicles/airboat.txt" : "airboat"
		"scripts/vehicles/apc.txt" : "apc"
		"scripts/vehicles/apc_npc.txt" : "apc_npc"
		"scripts/vehicles/crane.txt" : "crane"
		"scripts/vehicles/digger.txt" : "digger"
		"scripts/vehicles/driveway.txt" : "driveway"
		"scripts/vehicles/fastdigger.txt" : "fastdigger"
		"scripts/vehicles/jeep_test.txt" : "jeep_test"
		"scripts/vehicles/jetski.txt" : "jetski"
		"scripts/vehicles/prisonder_pod.txt" : "prisoner_pod"
	]
	actionScale(float) : "Scale of action input / framerate" : "1"

	input Action(float) : "Set the speed of the action animation"

	input TurnOn(void)	: "Turn on: Start engine & enable throttle"
	input TurnOff(void)	: "Turn off: Stop engine, disable throttle, engage brakes."

	input Lock(void)	: "Prevent the player from entering or exiting the vehicle."
	input Unlock(void)	: "Re-allow the player to enter or exit the vehicle."
]


@BaseClass base(BaseVehicle) = BaseDriveableVehicle
[
	VehicleLocked(choices) : "Start locked" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]	

	output PlayerOn(void) : "Player entered the vehicle"
	output PlayerOff(void) : "Player exited the vehicle"
	
	output PressedAttack(void) : "Player Pressed attack key"
	output PressedAttack2(void) : "Player Pressed attack2 key"

	output AttackAxis(string) : "State of attack button [0,1]"
	output Attack2Axis(string) : "State of attack2 button [0,1]"
	input HandBrakeOn(void) : "Turns the handbrake on"
	input HandBrakeOff(void): "Releases the handbrake"
]

@PointClass base(BaseVehicle) studioprop() = prop_vehicle :
	"Studiomodel vehicle that can be driven via inputs."
[
	input Steer(float) : "Steer the vehicle +/-1"
	input Throttle(float) : "Throttle +/-1"
]

@PointClass base(Targetname, Angles) studioprop() = point_apc_controller : "APC Controller"
[
	spawnflags(flags) =
	[
		1 : "Active" : 0
	]

	yawrate(string) : "Yaw rate" : "30"
	yawtolerance(string) : "Yaw tolerance" : "15"
	pitchrate(string) : "Pitch rate" : "0"
	pitchtolerance(string) : "Pitch tolerance" : "20"
	rotatestartsound(sound) : "Rotate Start Sound" : ""
	rotatesound(sound) : "Rotate Loop Sound" : ""
	rotatestopsound(sound) : "Rotate Stop Sound" : ""
	minRange(string) : "Minmum target range" : "0"
	maxRange(string) : "Maximum target range" : "0"
	targetentityname(string) : "Name of entity I should follow/attack" : ""

	// input
	input Activate(void)				: "Turn the APC rockets on"
	input Deactivate(void)				: "Turn the APC rockets off (go dormant)"

	output OnFireAtTarget(void)			: "Fires when a valid target is found and the APC should shoot rockets"
]

@PointClass base(BaseDriveableVehicle) studioprop() = prop_vehicle_apc :
	"APC with mounted guns, can only be driven by a vehicle driver or a npc_apcdriver."
[
	missilehint(target_destination) : "Missile Hint Target" : "" : "Name of one or more info_apc_missile_hint entities to use to determine what to hit."
	input FireMissileAt(target_destination)	: "A target to fire a missile at"
	input Destroy(void)	: "Causes the APC to blow up."
	output OnFiredMissile(void) : "Fired when the APC shoots a missile."
	output OnDeath(void) : "Fired when the APC is killed."
]

@SolidClass base(Targetname, Origin, Angles, EnableDisable) = info_apc_missile_hint :
	"Something that helps APC missiles guide. If the missile can hit the associated target entity"+
	"between the time it takes the current enemy to enter + leave the hint, then the missile will guide to the entity."
[
	target(target_destination) : "Target Entity" : "" : "The entity that the missile will guide towards if the conditions are met."
]

@PointClass base(BaseDriveableVehicle) studioprop() = prop_vehicle_jeep :
	"Driveable studiomodel jeep."
[
	input StartRemoveTauCannon(void)		: "Start the tau removal sequence."
	input FinishRemoveTauCannon(void)		: "Finish the tau removal sequence."
]

@PointClass base(BaseDriveableVehicle) studioprop() = vehicle_viewcontroller : 
	"Vehicle hack to control player view"
[
	input ForcePlayerIn(string)				: "Force the player into the vehicle. The animation to use can be specified in the parameter. Without a parameter, the player just teleports."
	input ForcePlayerOut(void)				: "Force the player out of the vehicle."
]

@PointClass base(BaseDriveableVehicle) studioprop() = prop_vehicle_airboat :
	"Driveable studiomodel airboat."
[
	model(studio) : "World model" : "models/airboat.mdl"
	EnableGun(choices) : "Has Gun" : 0 : "Whether the airboat's gun is enabled or disabled." =
	[
		0 : "No"
		1 : "Yes"
	]
	input EnableGun(bool) : "Enables or disables the airboat gun and associated crosshair."
	input InputStartRotorWashForces(void) : "The airboat will start to be blown around by the helicopter rotor wash."
	input InputStopRotorWashForces(void) : "The airboat will no longer be blown around by the helicopter rotor wash."
]

@PointClass base(BaseDriveableVehicle) studioprop() = prop_vehicle_cannon :
	"Driveable studiomodel cannon."
[
]

@PointClass base(BaseDriveableVehicle) studioprop() = prop_vehicle_crane :
	"Driveable studiomodel crane."
[
	magnetname(target_destination) : "Magnet entity" : ""

	input ForcePlayerIn(void) : "Force the player to get into the crane. Only works in singleplayer."
]

@PointClass base(BaseDriveableVehicle, Parentname) studioprop() = prop_vehicle_prisoner_pod :
	"Combine prisoner pod that the player can ride in."
[
	model(studio) : "World model" : "models/vehicles/prisoner_pod.mdl"
	
	input Open(void) : "Plays the pod's open animation and unlocks the pod for entry or exit."
	input Close(void) : "Plays the pod's close animation and locks the pod for entry or exit."
	input EnterVehicle(void) : "Forces the activator (or player) into the pod."
	input EnterVehicleImmediate(void) : "Forces the activator (or player) into the pod without enter/exit animations."
	input ExitVehicle(void) : "Boots the prisoner out of the pod."
	
	output OnOpen(void) : "Fired when the pod is open enough to enter."
	output OnClose(void) : "Fired when the pod too closed to enter."
]

//-------------------------------------------------------------------------
// Script entities
//-------------------------------------------------------------------------
@PointClass base(Targetname) = script_intro : "Script: Custom entity used to handle the intro sequence."
[
	// Inputs
	input Activate(void) : "Take control of the player's view and start blending the two scenes."
	input Deactivate(void) : "Stop controlling the view."
	input SetCameraViewEntity(string) : "Set the viewpoint to blend with the player's viewpoint."
	input SetBlendMode(integer) : "Set the blending mode to use."
	input SetFOV(integer) : "Set the fov for the second camera."
	input SetNextFOV(integer) : "Set the FOV to blend to over time. Follow this with a SetFOVBlendTime input to start the fov blend."
	input SetFOVBlendTime(float) : "Set the amount of time it should take to blend to the next fov target, and start blending."
	input SetNextBlendMode(integer) : "Set the blending mode to blend to over time. Follow this with a SetNextBlendTime input to start the mode blend."
	input SetNextBlendTime(float) : "Set the amount of time it should take to blend to the next mode, and start blending."
	input FadeTo(string) : "Fade to a specific alpha amount of an amount of time. Parameters: <alpha> <duration>"
	input SetFadeColor(string) : "Set the fade color. Parameters: <Red> <Green> <Blue>"
]

//-------------------------------------------------------------------------
//
// Special effects
//
//-------------------------------------------------------------------------

@PointClass base(Targetname,Parentname,Angles) = env_citadel_energy_core : "Special effect (sprite + particles) for the energy cores in citadel."
[
	spawnflags(Flags) = 
	[
		1 : "No small particles" : 0
		2 : "Start on" : 0
	]

	scale(float) : "Scale" : 1 : "Scale of the effect.  1 is the default size, 2 is twice that, etc."

	// Inputs
	input StartCharge(float) : "Start charging the effect over specified number of seconds."
	input StartDischarge(void) : "Start the core discharge."
	input Stop(float) : "Stop the effect over the specified number of seconds."
]

@PointClass base(Targetname,Parentname) size(-4 -4 -4, 4 4 4) color(0 0 255) line( 0 0 255, targetname, EndTargetName) = env_alyxemp : "Special effect (laser + sprite + particles) for Alyx's EMP device."
[
	EndTargetName(target_destination) : "Target Entity" : "" : "Entity to use as a target endpoint.  Info_target works well."

	// Inputs
	input StartCharge(float) : "Start charging the effect over specified number of seconds."
	input StartDischarge(void) : "Start the EMP discharge."
	input Stop(float) : "Stop the effect over the specified number of seconds."
	input SetTargetEnt(string) : "Set the target entity for the effect."
]

//-------------------------------------------------------------------------
//
// HL2DM entities
//
//-------------------------------------------------------------------------
@FilterClass base(BaseFilter) size(-8 -8 -8, 8 8 8) = filter_activator_team :
	"A filter that filters by the team of the activator."
[
	filterteam(choices) : "Filter Team Number" : 2 : "The team number to filter by.  If the filter mode is Allow, only entities whose "+
		"team number matches the given team will pass the filter. If the filter mode is Disallow, "+
		"all entities EXCEPT those whose team number matches the given team will pass the filter." =
	[
		0 : "0 - Unassigned (deathmatch)"
		1 : "1 - Spectators"
		2 : "2 - Combine"
		3 : "3 - Rebels"
	]
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = game_score : "An entity that awards/deducts points from the player who activates it." 
[
	spawnflags(flags) =
	[
		1: "Allow Negative" : 0
		2: "Team Points" : 0
	]
	points(integer) : "Points to add (+/-)" : 1

	input ApplyScore(void) : "Award or deduct the specified number of points from the activator or his team."
]

@PointClass base(PlayerClass) studioprop("models/editor/playerstart.mdl") = info_player_deathmatch :
	"This entity indicates the position and facing direction at which the player will spawn during a deathmatch game. Any number of "+
	"info_player_deathmatch entities may be placed in a map.  This entity will not function in single-player HL2."
[
]

@PointClass base(PlayerClass) studioprop("models/editor/playerstart.mdl") = info_start_combine :
	"This entity indicates the position and facing direction at which a Combine player will spawn during a teamplay game mode.  Any number of "+
	"info_start_combine entities may be placed in a map."
[
]

@PointClass base(PlayerClass) studioprop("models/editor/playerstart.mdl") = info_start_resistance :
	"This entity indicates the position and facing direction at which a Resistance player will spawn during a teamplay game mode.  Any number of "+
	"info_start_resistance entities may be placed in a map."
[
]

@PointClass base(PlayerClass) studioprop("models/editor/playerstart.mdl") = info_start_aperture :
	"This entity indicates the position and facing direction at which an Aperture player will spawn during a teamplay game mode.  Any number of "+
	"info_start_aperture entities may be placed in a map."
[
]

@PointClass base(prop_physics) studioprop() sphere(fademindist) sphere(fademaxdist) = prop_physics_multiplayer :
	"This class is the same as prop_physics, except the runtime collisions use a more bouncy method that avoids " +
	"the prediction errors normal physics objects get."
[
]

@SolidClass base(func_physbox) = func_physbox_multiplayer : 
	"This class is the same as func_physbox, except the runtime collisions use a more bouncy method that avoids " +
	"the prediction errors normal physics objects get."
[
]

@PointClass base(prop_physics) studioprop() sphere(fademindist) sphere(fademaxdist) = prop_physics_respawnable :
	"This class is the same as prop_physics, except it respawns after it breaks.  This entity will only function in HL2DM, not single-player HL2."
[
	RespawnTime(float) : "Respawn Time" : 60 : "Number of seconds to wait before respawning after this prop breaks."
]

//-------------------------------------------------------------------------
//
// Deprecated/redundant stuff--I'm not sure why anyone uses it, but it's here for those who do
//
//-------------------------------------------------------------------------

@SolidClass base(Targetname, Parentname, RenderFields, Origin) = func_wall : "A brush entity wall.\n\n"+
	"This entity is deprecated.  It has been superseded by func_brush and func_detail but will function fine in-game."
[
]

@SolidClass base(func_wall) = func_illusionary : "A nonsolid brush entity.\n\n"+
	"This entity is deprecated.  It has been superseded by func_brush but will function fine in-game."
[
]

@SolidClass base(func_wall) = func_wall_toggle : "A brush entity that can be toggled between solid/visible and nonsolid/invisible.\n\n"+
	"This entity is deprecated.  It has been superseded by func_brush but will function fine in-game."
[
	spawnflags(flags) =
	[
		1 : "Starts Invisible" : 0
	]
	input  Toggle(void) : "Toggle the brush between on (solid, visible) and off (nonsolid, invisible)."
]

@SolidClass base(trigger_multiple) = trigger_once : "A trigger_multiple that can only be triggered once.\n\n"+
	"This entity is redundant.  It is a timesaving trigger_multiple, but it works fine."
[
	wait(integer) readonly : "Delay Before Reset" : -1 : "Amount of time, in seconds, after the trigger_multiple has triggered before it can be triggered again. If set to -1, it will never trigger again."
]

@PointClass base(PlayerClass) studio("models/editor/playerstart.mdl") = info_teleport_destination : "An entity intended for use as the destination of a trigger_teleport.\n\n"+
	"This is an info_target that displays a player model in Hammer (as a representation of how the player will come out of the teleport)."
[
]

@PointClass base(path_corner) = path_corner_crash : "Generic path entity.\n\n"+
	"This entity is redundant.  It is exactly the same as path_corner, but it functions fine in-game."
[
]